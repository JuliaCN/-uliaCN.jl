{"Base.nextind":[{"Tuple{AbstractString,Integer,Integer}":"    nextind(str::AbstractString, i::Integer, n::Integer=1) -> Int\n\n* Case `n == 1`\n\n  If `i` is in bounds in `s` return the index of the start of the character whose\n  encoding starts after index `i`. In other words, if `i` is the start of a\n  character, return the start of the next character; if `i` is not the start\n  of a character, move forward until the start of a character and return that index.\n  If `i` is equal to `0` return `1`.\n  If `i` is in bounds but greater or equal to `lastindex(str)` return `ncodeunits(str)+1`.\n  Otherwise throw `BoundsError`.\n\n* Case `n > 1`\n\n  Behaves like applying `n` times `nextind` for `n==1`. The only difference\n  is that if `n` is so large that applying `nextind` would reach `ncodeunits(str)+1` then\n  each remaining iteration increases the returned value by `1`. This means that in this\n  case `nextind` can return a value greater than `ncodeunits(str)+1`.\n\n* Case `n == 0`\n\n  Return `i` only if `i` is a valid index in `s` or is equal to `0`.\n  Otherwise `StringIndexError` or `BoundsError` is thrown.\n\n# Examples\n```jldoctest\njulia> nextind(\"α\", 0)\n1\n\njulia> nextind(\"α\", 1)\n3\n\njulia> nextind(\"α\", 3)\nERROR: BoundsError: attempt to access String\n  at index [3]\n[...]\n\njulia> nextind(\"α\", 0, 2)\n3\n\njulia> nextind(\"α\", 1, 2)\n4\n```\n"}],"Base.deepcopy":[{"Tuple{Any}":"    deepcopy(x)\n\nCreate a deep copy of `x`: everything is copied recursively, resulting in a fully\nindependent object. For example, deep-copying an array produces a new array whose elements\nare deep copies of the original elements. Calling `deepcopy` on an object should generally\nhave the same effect as serializing and then deserializing it.\n\nAs a special case, functions can only be actually deep-copied if they are anonymous,\notherwise they are just copied. The difference is only relevant in the case of closures,\ni.e. functions which may contain hidden internal references.\n\nWhile it isn't normally necessary, user-defined types can override the default `deepcopy`\nbehavior by defining a specialized version of the function\n`deepcopy_internal(x::T, dict::IdDict)` (which shouldn't otherwise be used),\nwhere `T` is the type to be specialized for, and `dict` keeps track of objects copied\nso far within the recursion. Within the definition, `deepcopy_internal` should be used\nin place of `deepcopy`, and the `dict` variable should be\nupdated as appropriate before returning.\n"}],"Base.IndexCartesian":[{"Union{}":"    IndexCartesian()\n\nSubtype of [`IndexStyle`](@ref) used to describe arrays which\nare optimally indexed by a Cartesian index. This is the default\nfor new custom [`AbstractArray`](@ref) subtypes.\n\nA Cartesian indexing style uses multiple integer indices to describe the position in\na multidimensional array, with exactly one index per dimension. This means that\nrequesting [`eachindex`](@ref) from an array that is `IndexCartesian` will return\na range of [`CartesianIndices`](@ref).\n\nA `N`-dimensional custom array that reports its `IndexStyle` as `IndexCartesian` needs\nto implement indexing (and indexed assignment) with exactly `N` `Int` indices;\nall other indexing expressions — including linear indexing — will\nbe recomputed to the equivalent Cartesian location.  For example, if `A` were a `2×3` custom\nmatrix with cartesian indexing, and we referenced `A[5]`, this would be\nrecomputed to the equivalent Cartesian index and call `A[1, 3]` since `5 = 2*1 + 3`.\n\nIt is significantly more expensive to compute Cartesian indices from a linear index than it is\nto go the other way.  The former operation requires division — a very costly operation — whereas\nthe latter only uses multiplication and addition and is essentially free. This asymmetry means it\nis far more costly to use linear indexing with an `IndexCartesian` array than it is to use\nCartesian indexing with an `IndexLinear` array.\n\nSee also [`IndexLinear`](@ref).\n"}],"Base.strides":[{"Union{}":"    strides(A)\n\nReturn a tuple of the memory strides in each dimension.\n\n# Examples\n```jldoctest\njulia> A = fill(1, (3,4,5));\n\njulia> strides(A)\n(1, 3, 12)\n```\n"}],"Base.allunique":[{"Tuple{Any}":"    allunique(itr) -> Bool\n\nReturn `true` if all values from `itr` are distinct when compared with [`isequal`](@ref).\n\n# Examples\n```jldoctest\njulia> a = [1; 2; 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> allunique([a, a])\nfalse\n```\n"}],"Base.shell_escape":[{"Tuple{Vararg{AbstractString,N} where N}":"    shell_escape(args::Union{Cmd,AbstractString...}; special::AbstractString=\"\")\n\nThe unexported `shell_escape` function is the inverse of the unexported `shell_split` function:\nit takes a string or command object and escapes any special characters in such a way that calling\n`shell_split` on it would give back the array of words in the original command. The `special`\nkeyword argument controls what characters in addition to whitespace, backslashes, quotes and\ndollar signs are considered to be special (default: none).\n\n# Examples\n```jldoctest\njulia> Base.shell_escape(\"cat\", \"/foo/bar baz\", \"&&\", \"echo\", \"done\")\n\"cat '/foo/bar baz' && echo done\"\n\njulia> Base.shell_escape(\"echo\", \"this\", \"&&\", \"that\")\n\"echo this && that\"\n```\n"}],"Base.values":[{"Tuple{Any}":"    values(iterator)\n\nFor an iterator or collection that has keys and values, return an iterator\nover the values.\nThis function simply returns its argument by default, since the elements\nof a general iterator are normally considered its \"values\".\n\n# Examples\n```jldoctest\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> values(d)\nBase.ValueIterator for a Dict{String,Int64} with 2 entries. Values:\n  2\n  1\n\njulia> values([2])\n1-element Array{Int64,1}:\n 2\n```\n"},{"Tuple{AbstractDict}":"    values(a::AbstractDict)\n\nReturn an iterator over all values in a collection.\n`collect(values(a))` returns an array of values.\nWhen the values are stored internally in a hash table,\nas is the case for `Dict`,\nthe order in which they are returned may vary.\nBut `keys(a)` and `values(a)` both iterate `a` and\nreturn the elements in the same order.\n\n# Examples\n```jldoctest\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> collect(values(D))\n2-element Array{Int64,1}:\n 2\n 3\n```\n"}],"Base.iterate":[{"Union{}":"    iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}\n\nAdvance the iterator to obtain the next element. If no elements\nremain, `nothing` should be returned. Otherwise, a 2-tuple of the\nnext element and the new iteration state should be returned.\n"},{"Tuple{AbstractString,Integer}":"    iterate(s::AbstractString, i::Integer) -> Union{Tuple{<:AbstractChar, Int}, Nothing}\n\nReturn a tuple of the character in `s` at index `i` with the index of the start\nof the following character in `s`. This is the key method that allows strings to\nbe iterated, yielding a sequences of characters. If `i` is out of bounds in `s`\nthen a bounds error is raised. The `iterate` function, as part of the iteration\nprotocol may assume that `i` is the start of a character in `s`.\n\nSee also: [`getindex`](@ref), [`checkbounds`](@ref)\n"}],"Base.MappingRF":[{"Union{}":"    MappingRF(f, rf) -> rf′\n\nCreate a mapping reducing function `rf′(acc, x) = rf(acc, f(x))`.\n"}],"Base.parameter_upper_bound":[{"Tuple{UnionAll,Any}":"    Base.parameter_upper_bound(t::UnionAll, idx)\n\nDetermine the upper bound of a type parameter in the underlying datatype.\nThis method should generally not be relied upon:\ncode instead should usually use static parameters in dispatch to extract these values.\n\n# Examples\n```jldoctest\njulia> struct Foo{T<:AbstractFloat, N}\n           x::Tuple{T, N}\n       end\n\njulia> Base.parameter_upper_bound(Foo, 1)\nAbstractFloat\n\njulia> Base.parameter_upper_bound(Foo, 2)\nAny\n```\n"}],"Base.ismissing":[{"Tuple{Any}":"    ismissing(x)\n\nIndicate whether `x` is [`missing`](@ref).\n"}],"Base.seekstart":[{"Tuple{IO}":"    seekstart(s)\n\nSeek a stream to its beginning.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> read(io, Char)\n'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n\njulia> seekstart(io);\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n```\n"}],"Base.kill":[{"Tuple{Base.Process,Integer}":"    kill(p::Process, signum=Base.SIGTERM)\n\nSend a signal to a process. The default is to terminate the process.\nReturns successfully if the process has already exited, but throws an\nerror if killing the process failed for other reasons (e.g. insufficient\npermissions).\n"}],"Base.getindex":[{"Union{}":"    getindex(collection, key...)\n\nRetrieve the value(s) stored at the given key or index within a collection. The syntax\n`a[i,j,...]` is converted by the compiler to `getindex(a, i, j, ...)`.\n\n# Examples\n```jldoctest\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> getindex(A, \"a\")\n1\n```\n"},{"Tuple{AbstractArray,Vararg{Any,N} where N}":"    getindex(A, inds...)\n\nReturn a subset of array `A` as specified by `inds`, where each `ind` may be an\n`Int`, an [`AbstractRange`](@ref), or a [`Vector`](@ref). See the manual section on\n[array indexing](@ref man-array-indexing) for details.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> getindex(A, 1)\n1\n\njulia> getindex(A, [2, 1])\n2-element Array{Int64,1}:\n 3\n 1\n\njulia> getindex(A, 2:4)\n3-element Array{Int64,1}:\n 3\n 2\n 4\n```\n"},{"Union{Tuple{T}, Tuple{Type{T},Vararg{Any,N} where N}} where T":"    getindex(type[, elements...])\n\nConstruct a 1-d array of the specified type. This is usually called with the syntax\n`Type[]`. Element values can be specified using `Type[a,b,c,...]`.\n\n# Examples\n```jldoctest\njulia> Int8[1, 2, 3]\n3-element Array{Int8,1}:\n 1\n 2\n 3\n\njulia> getindex(Int8, 1, 2, 3)\n3-element Array{Int8,1}:\n 1\n 2\n 3\n```\n"}],"Base.indexin":[{"Tuple{Any,AbstractArray}":"    indexin(a, b)\n\nReturn an array containing the first index in `b` for\neach value in `a` that is a member of `b`. The output\narray contains `nothing` wherever `a` is not a member of `b`.\n\n# Examples\n```jldoctest\njulia> a = ['a', 'b', 'c', 'b', 'd', 'a'];\n\njulia> b = ['a', 'b', 'c'];\n\njulia> indexin(a, b)\n6-element Array{Union{Nothing, Int64},1}:\n 1\n 2\n 3\n 2\n  nothing\n 1\n\njulia> indexin(b, a)\n3-element Array{Union{Nothing, Int64},1}:\n 1\n 2\n 3\n```\n"}],"Base.deleteat!":[{"Tuple{Array{T,1} where T,Integer}":"    deleteat!(a::Vector, i::Integer)\n\nRemove the item at the given `i` and return the modified `a`. Subsequent items\nare shifted to fill the resulting gap.\n\n# Examples\n```jldoctest\njulia> deleteat!([6, 5, 4, 3, 2, 1], 2)\n5-element Array{Int64,1}:\n 6\n 4\n 3\n 2\n 1\n```\n"},{"Tuple{Array{T,1} where T,Any}":"    deleteat!(a::Vector, inds)\n\nRemove the items at the indices given by `inds`, and return the modified `a`.\nSubsequent items are shifted to fill the resulting gap.\n\n`inds` can be either an iterator or a collection of sorted and unique integer indices,\nor a boolean vector of the same length as `a` with `true` indicating entries to delete.\n\n# Examples\n```jldoctest\njulia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))\nERROR: ArgumentError: indices must be unique and sorted\nStacktrace:\n[...]\n```\n"}],"Base.channeled_tasks":[{"Tuple{Int64,Vararg{Any,N} where N}":"    channeled_tasks(n::Int, funcs...; ctypes=fill(Any,n), csizes=fill(0,n))\n\nA convenience method to create `n` channels and bind them to tasks started\nfrom the provided functions in a single call. Each `func` must accept `n` arguments\nwhich are the created channels. Channel types and sizes may be specified via\nkeyword arguments `ctypes` and `csizes` respectively. If unspecified, all channels are\nof type `Channel{Any}(0)`.\n\nReturns a tuple, `(Array{Channel}, Array{Task})`, of the created channels and tasks.\n"}],"Base.gensym":[{"Tuple{}":"    gensym([tag])\n\nGenerates a symbol which will not conflict with other variable names.\n"}],"Base.<":[{"Tuple{Any}":"    <(x)\n\nCreate a function that compares its argument to `x` using [`<`](@ref), i.e.\na function equivalent to `y -> y < x`.\nThe returned function is of type `Base.Fix2{typeof(<)}`, which can be\nused to implement specialized methods.\n\n!!! compat \"Julia 1.2\"\n    This functionality requires at least Julia 1.2.\n"},{"Tuple{Any,Any}":"    <(x, y)\n\nLess-than comparison operator. Falls back to [`isless`](@ref).\nBecause of the behavior of floating-point NaN values, this operator implements\na partial order.\n\n# Implementation\nNew numeric types with a canonical partial order should implement this function for\ntwo arguments of the new type.\nTypes with a canonical total order should implement [`isless`](@ref) instead.\n(x < y) | (x == y)\n\n# Examples\n```jldoctest\njulia> 'a' < 'b'\ntrue\n\njulia> \"abc\" < \"abd\"\ntrue\n\njulia> 5 < 3\nfalse\n```\n"}],"Base.cconvert":[{"Union{}":"    cconvert(T,x)\n\nConvert `x` to a value to be passed to C code as type `T`, typically by calling `convert(T, x)`.\n\nIn cases where `x` cannot be safely converted to `T`, unlike [`convert`](@ref), `cconvert` may\nreturn an object of a type different from `T`, which however is suitable for\n[`unsafe_convert`](@ref) to handle. The result of this function should be kept valid (for the GC)\nuntil the result of [`unsafe_convert`](@ref) is not needed anymore.\nThis can be used to allocate memory that will be accessed by the `ccall`.\nIf multiple objects need to be allocated, a tuple of the objects can be used as return value.\n\nNeither `convert` nor `cconvert` should take a Julia object and turn it into a `Ptr`.\n"}],"Base.asyncmap":[{"Tuple{Any,Vararg{Any,N} where N}":"    asyncmap(f, c...; ntasks=0, batch_size=nothing)\n\nUses multiple concurrent tasks to map `f` over a collection (or multiple\nequal length collections). For multiple collection arguments, `f` is\napplied elementwise.\n\n`ntasks` specifies the number of tasks to run concurrently.\nDepending on the length of the collections, if `ntasks` is unspecified,\nup to 100 tasks will be used for concurrent mapping.\n\n`ntasks` can also be specified as a zero-arg function. In this case, the\nnumber of tasks to run in parallel is checked before processing every element and a new\ntask started if the value of `ntasks_func` is less than the current number\nof tasks.\n\nIf `batch_size` is specified, the collection is processed in batch mode. `f` must\nthen be a function that must accept a `Vector` of argument tuples and must\nreturn a vector of results. The input vector will have a length of `batch_size` or less.\n\nThe following examples highlight execution in different tasks by returning\nthe `objectid` of the tasks in which the mapping function is executed.\n\nFirst, with `ntasks` undefined, each element is processed in a different task.\n```\njulia> tskoid() = objectid(current_task());\n\njulia> asyncmap(x->tskoid(), 1:5)\n5-element Array{UInt64,1}:\n 0x6e15e66c75c75853\n 0x440f8819a1baa682\n 0x9fb3eeadd0c83985\n 0xebd3e35fe90d4050\n 0x29efc93edce2b961\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5)))\n5\n```\n\nWith `ntasks=2` all elements are processed in 2 tasks.\n```\njulia> asyncmap(x->tskoid(), 1:5; ntasks=2)\n5-element Array{UInt64,1}:\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))\n2\n```\n\nWith `batch_size` defined, the mapping function needs to be changed to accept an array\nof argument tuples and return an array of results. `map` is used in the modified mapping\nfunction to achieve this.\n```\njulia> batch_func(input) = map(x->string(\"args_tuple: \", x, \", element_val: \", x[1], \", task: \", tskoid()), input)\nbatch_func (generic function with 1 method)\n\njulia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)\n5-element Array{String,1}:\n \"args_tuple: (1,), element_val: 1, task: 9118321258196414413\"\n \"args_tuple: (2,), element_val: 2, task: 4904288162898683522\"\n \"args_tuple: (3,), element_val: 3, task: 9118321258196414413\"\n \"args_tuple: (4,), element_val: 4, task: 4904288162898683522\"\n \"args_tuple: (5,), element_val: 5, task: 9118321258196414413\"\n```\n\n!!! note\n    Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently,\n    `asyncmap` is beneficial only when the mapping function involves any I/O - disk, network, remote\n    worker invocation, etc.\n\n"}],"Base.unsafe_store!":[{"Union{Tuple{Ptr{Any},Any}, Tuple{Ptr{Any},Any,Integer}}":"    unsafe_store!(p::Ptr{T}, x, i::Integer=1)\n\nStore a value of type `T` to the address of the `i`th element (1-indexed) starting at `p`.\nThis is equivalent to the C expression `p[i-1] = x`.\n\nThe `unsafe` prefix on this function indicates that no validation is performed on the\npointer `p` to ensure that it is valid. Incorrect usage may corrupt or segfault your\nprogram, in the same manner as C.\n"}],"Base.findmin":[{"Tuple{Any}":"    findmin(itr) -> (x, index)\n\nReturn the minimum element of the collection `itr` and its index. If there are multiple\nminimal elements, then the first one will be returned.\nIf any data element is `NaN`, this element is returned.\nThe result is in line with `min`.\n\nThe collection must not be empty.\n\n# Examples\n```jldoctest\njulia> findmin([8,0.1,-9,pi])\n(-9.0, 3)\n\njulia> findmin([7,1,1,6])\n(1, 2)\n\njulia> findmin([7,1,1,NaN])\n(NaN, 4)\n```\n"},{"Tuple{AbstractArray}":"    findmin(A; dims) -> (minval, index)\n\nFor an array input, returns the value and index of the minimum over the given dimensions.\n`NaN` is treated as less than all other values.\n\n# Examples\n```jldoctest\njulia> A = [1.0 2; 3 4]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> findmin(A, dims=1)\n([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])\n\njulia> findmin(A, dims=2)\n([1.0; 3.0], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1)])\n```\n"}],"Base.promote_shape":[{"Tuple{Tuple{Vararg{Int64,N}} where N,Tuple{Vararg{Int64,N}} where N}":"    promote_shape(s1, s2)\n\nCheck two array shapes for compatibility, allowing trailing singleton dimensions, and return\nwhichever shape has more dimensions.\n\n# Examples\n```jldoctest\njulia> a = fill(1, (3,4,1,1,1));\n\njulia> b = fill(1, (3,4));\n\njulia> promote_shape(a,b)\n(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))\n\njulia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))\n(2, 3, 1, 4, 1)\n```\n"}],"Base.eps":[{"Tuple{Type{#s662} where #s662<:AbstractFloat}":"    eps(::Type{T}) where T<:AbstractFloat\n    eps()\n\nReturn the *machine epsilon* of the floating point type `T` (`T = Float64` by\ndefault). This is defined as the gap between 1 and the next largest value representable by\n`typeof(one(T))`, and is equivalent to `eps(one(T))`.  (Since `eps(T)` is a\nbound on the *relative error* of `T`, it is a \"dimensionless\" quantity like [`one`](@ref).)\n\n# Examples\n```jldoctest\njulia> eps()\n2.220446049250313e-16\n\njulia> eps(Float32)\n1.1920929f-7\n\njulia> 1.0 + eps()\n1.0000000000000002\n\njulia> 1.0 + eps()/2\n1.0\n```\n"},{"Tuple{AbstractFloat}":"    eps(x::AbstractFloat)\n\nReturn the *unit in last place* (ulp) of `x`. This is the distance between consecutive\nrepresentable floating point values at `x`. In most cases, if the distance on either side\nof `x` is different, then the larger of the two is taken, that is\n\n    eps(x) == max(x-prevfloat(x), nextfloat(x)-x)\n\nThe exceptions to this rule are the smallest and largest finite values\n(e.g. `nextfloat(-Inf)` and `prevfloat(Inf)` for [`Float64`](@ref)), which round to the\nsmaller of the values.\n\nThe rationale for this behavior is that `eps` bounds the floating point rounding\nerror. Under the default `RoundNearest` rounding mode, if ``y`` is a real number and ``x``\nis the nearest floating point number to ``y``, then\n\n```math\n|y-x| \\leq \\operatorname{eps}(x)/2.\n```\n\n# Examples\n```jldoctest\njulia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(prevfloat(2.0))\n2.220446049250313e-16\n\njulia> eps(2.0)\n4.440892098500626e-16\n\njulia> x = prevfloat(Inf)      # largest finite Float64\n1.7976931348623157e308\n\njulia> x + eps(x)/2            # rounds up\nInf\n\njulia> x + prevfloat(eps(x)/2) # rounds down\n1.7976931348623157e308\n```\n"}],"Base.valtype":[{"Union{Tuple{Type{#s662} where #s662<:AbstractDict{K,V}}, Tuple{V}, Tuple{K}} where V where K":"    valtype(type)\n\nGet the value type of an dictionary type. Behaves similarly to [`eltype`](@ref).\n\n# Examples\n```jldoctest\njulia> valtype(Dict(Int32(1) => \"foo\"))\nString\n```\n"},{"Tuple{Type{#s662} where #s662<:AbstractArray}":"    valtype(T::Type{<:AbstractArray})\n    valtype(A::AbstractArray)\n\nReturn the value type of an array. This is identical to `eltype` and is\nprovided mainly for compatibility with the dictionary interface.\n\n# Examples\n```jldoctest\njulia> valtype([\"one\", \"two\", \"three\"])\nString\n```\n\n!!! compat \"Julia 1.2\"\n     For arrays, this function requires at least Julia 1.2.\n"}],"Base.lcm":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Integer":"    lcm(x,y)\n\nLeast common (non-negative) multiple.\nThe arguments may be integer and rational numbers.\n\n!!! compat \"Julia 1.4\"\n    Rational arguments require Julia 1.4 or later.\n\n# Examples\n```jldoctest\njulia> lcm(2,3)\n6\n\njulia> lcm(-2,3)\n6\n```\n"}],"Base.SecretBuffer!":[{"Tuple{Array{UInt8,1}}":"    SecretBuffer!(data::Vector{UInt8})\n\nInitialize a new `SecretBuffer` from `data`, securely zeroing `data` afterwards.\n"}],"Base.isnothing":[{"Tuple{Any}":"    isnothing(x)\n\nReturn `true` if `x === nothing`, and return `false` if not.\n\n!!! compat \"Julia 1.1\"\n    This function requires at least Julia 1.1.\n"}],"Base.OneTo":[{"Union{}":"    Base.OneTo(n)\n\nDefine an `AbstractUnitRange` that behaves like `1:n`, with the added\ndistinction that the lower limit is guaranteed (by the type system) to\nbe 1.\n"}],"Base.nonmissingtype":[{"Union{Tuple{Type{T}}, Tuple{T}} where T":"    nonmissingtype(T::Type)\n\nIf `T` is a union of types containing `Missing`, return a new type with\n`Missing` removed.\n\n# Examples\n```jldoctest\njulia> nonmissingtype(Union{Int64,Missing})\nInt64\n\njulia> nonmissingtype(Any)\nAny\n```\n\n!!! compat \"Julia 1.3\"\n  This function is exported as of Julia 1.3.\n"}],"Base.falses":[{"Tuple{Vararg{Union{Integer, AbstractUnitRange},N} where N}":"    falses(dims)\n\nCreate a `BitArray` with all values set to `false`.\n\n# Examples\n```jldoctest\njulia> falses(2,3)\n2×3 BitArray{2}:\n 0  0  0\n 0  0  0\n```\n"}],"Base.first":[{"Tuple{Any}":"    first(coll)\n\nGet the first element of an iterable collection. Return the start point of an\n[`AbstractRange`](@ref) even if it is empty.\n\n# Examples\n```jldoctest\njulia> first(2:2:10)\n2\n\njulia> first([1; 2; 3; 4])\n1\n```\n"},{"Tuple{AbstractString,Integer}":"    first(s::AbstractString, n::Integer)\n\nGet a string consisting of the first `n` characters of `s`.\n\n```jldoctest\njulia> first(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 1)\n\"∀\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 3)\n\"∀ϵ≠\"\n```\n"}],"Base.setdiff":[{"Tuple{AbstractSet,Vararg{Any,N} where N}":"    setdiff(s, itrs...)\n\nConstruct the set of elements in `s` but not in any of the iterables in `itrs`.\nMaintain order with arrays.\n\n# Examples\n```jldoctest\njulia> setdiff([1,2,3], [3,4,5])\n2-element Array{Int64,1}:\n 1\n 2\n```\n"}],"Base.Cstring":[{"Union{}":"    Cstring\n\nA C-style string composed of the native character type\n[`Cchar`](@ref)s. `Cstring`s are NUL-terminated. For\nC-style strings composed of the native wide character\ntype, see [`Cwstring`](@ref). For more information\nabout string interopability with C, see the\n[manual](@ref man-bits-types).\n"}],"Base.isiterable":[{"Tuple{Any}":"    isiterable(T) -> Bool\n\nTest if type `T` is an iterable collection type or not,\nthat is whether it has an `iterate` method or not.\n"}],"Base.isempty":[{"Tuple{Any}":"    isempty(collection) -> Bool\n\nDetermine whether a collection is empty (has no elements).\n\n# Examples\n```jldoctest\njulia> isempty([])\ntrue\n\njulia> isempty([1 2 3])\nfalse\n```\n"},{"Tuple{Base.GenericCondition}":"    isempty(condition)\n\nReturn `true` if no tasks are waiting on the condition, `false` otherwise.\n"}],"Base.isbinaryoperator":[{"Tuple{Symbol}":"    isbinaryoperator(s::Symbol)\n\nReturn `true` if the symbol can be used as a binary (infix) operator, `false` otherwise.\n\n# Examples\n```jldoctest\njulia> Base.isbinaryoperator(:-), Base.isbinaryoperator(:√), Base.isbinaryoperator(:f)\n(true, false, false)\n```\n"}],"Base.isless":[{"Union{}":"    isless(x, y)\n\nTest whether `x` is less than `y`, according to a fixed total order.\n`isless` is not defined on all pairs of values `(x, y)`. However, if it\nis defined, it is expected to satisfy the following:\n- If `isless(x, y)` is defined, then so is `isless(y, x)` and `isequal(x, y)`,\n  and exactly one of those three yields `true`.\n- The relation defined by `isless` is transitive, i.e.,\n  `isless(x, y) && isless(y, z)` implies `isless(x, z)`.\n\nValues that are normally unordered, such as `NaN`,\nare ordered in an arbitrary but consistent fashion.\n[`missing`](@ref) values are ordered last.\n\nThis is the default comparison used by [`sort`](@ref).\n\n# Implementation\nNon-numeric types with a total order should implement this function.\nNumeric types only need to implement it if they have special values such as `NaN`.\nTypes with a partial order should implement [`<`](@ref).\n"},{"Tuple{Tuple,Tuple}":"    isless(t1::Tuple, t2::Tuple)\n\nReturns true when t1 is less than t2 in lexicographic order.\n"},{"Tuple{AbstractString,AbstractString}":"    isless(a::AbstractString, b::AbstractString) -> Bool\n\nTest whether string `a` comes before string `b` in alphabetical order\n(technically, in lexicographical order by Unicode code points).\n\n# Examples\n```jldoctest\njulia> isless(\"a\", \"b\")\ntrue\n\njulia> isless(\"β\", \"α\")\nfalse\n\njulia> isless(\"a\", \"a\")\nfalse\n```\n"}],"Base.pop!":[{"Tuple{Array{T,1} where T}":"    pop!(collection) -> item\n\nRemove an item in `collection` and return it. If `collection` is an\nordered container, the last item is returned.\n\n# Examples\n```jldoctest\njulia> A=[1, 2, 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> pop!(A)\n3\n\njulia> A\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> S = Set([1, 2])\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> pop!(S)\n2\n\njulia> S\nSet{Int64} with 1 element:\n  1\n\njulia> pop!(Dict(1=>2))\n1 => 2\n```\n"},{"Tuple{Any,Any,Any}":"    pop!(collection, key[, default])\n\nDelete and return the mapping for `key` if it exists in `collection`, otherwise return\n`default`, or throw an error if `default` is not specified.\n\n# Examples\n```jldoctest\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n```\n"}],"Base.schedule":[{"Tuple{Task,Any}":"    schedule(t::Task, [val]; error=false)\n\nAdd a [`Task`](@ref) to the scheduler's queue. This causes the task to run constantly when the system\nis otherwise idle, unless the task performs a blocking operation such as [`wait`](@ref).\n\nIf a second argument `val` is provided, it will be passed to the task (via the return value of\n[`yieldto`](@ref)) when it runs again. If `error` is `true`, the value is raised as an exception in\nthe woken task.\n\n# Examples\n```jldoctest\njulia> a5() = sum(i for i in 1:1000);\n\njulia> b = Task(a5);\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskstarted(b)\ntrue\n\njulia> istaskdone(b)\ntrue\n```\n"}],"Base.typeintersect":[{"Tuple{Any,Any}":"    typeintersect(T, S)\n\nCompute a type that contains the intersection of `T` and `S`. Usually this will be the\nsmallest such type or one close to it.\n"}],"Base.reverseind":[{"Tuple{AbstractString,Integer}":"    reverseind(v, i)\n\nGiven an index `i` in [`reverse(v)`](@ref), return the corresponding index in\n`v` so that `v[reverseind(v,i)] == reverse(v)[i]`. (This can be nontrivial in\ncases where `v` contains non-ASCII characters.)\n\n# Examples\n```jldoctest\njulia> r = reverse(\"Julia\")\n\"ailuJ\"\n\njulia> for i in 1:length(r)\n           print(r[reverseind(\"Julia\", i)])\n       end\nJulia\n```\n"}],"Base.promote_type":[{"Union{}":"    promote_type(type1, type2)\n\nPromotion refers to converting values of mixed types to a single common type.\n`promote_type` represents the default promotion behavior in Julia when\noperators (usually mathematical) are given arguments of differing types.\n`promote_type` generally tries to return a type which can at least approximate\nmost values of either input type without excessively widening.  Some loss is\ntolerated; for example, `promote_type(Int64, Float64)` returns\n[`Float64`](@ref) even though strictly, not all [`Int64`](@ref) values can be\nrepresented exactly as `Float64` values.\n\n```jldoctest\njulia> promote_type(Int64, Float64)\nFloat64\n\njulia> promote_type(Int32, Int64)\nInt64\n\njulia> promote_type(Float32, BigInt)\nBigFloat\n\njulia> promote_type(Int16, Float16)\nFloat16\n\njulia> promote_type(Int64, Float16)\nFloat16\n\njulia> promote_type(Int8, UInt16)\nUInt16\n```\n"}],"Base.BitSet":[{"Tuple{Any}":"    BitSet([itr])\n\nConstruct a sorted set of `Int`s generated by the given iterable object, or an\nempty set. Implemented as a bit string, and therefore designed for dense integer sets.\nIf the set will be sparse (for example, holding a few\nvery large integers), use [`Set`](@ref) instead.\n"}],"Base.minmax":[{"Tuple{Any,Any}":"    minmax(x, y)\n\nReturn `(min(x,y), max(x,y))`. See also: [`extrema`](@ref) that returns `(minimum(x), maximum(x))`.\n\n# Examples\n```jldoctest\njulia> minmax('c','b')\n('b', 'c')\n```\n"}],"Base.asyncmap!":[{"Tuple{Any,Any,Any,Vararg{Any,N} where N}":"    asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)\n\nLike [`asyncmap`](@ref), but stores output in `results` rather than\nreturning a collection.\n"}],"Base.any":[{"Tuple{Any}":"    any(itr) -> Bool\n\nTest whether any elements of a boolean collection are `true`, returning `true` as\nsoon as the first `true` value in `itr` is encountered (short-circuiting).\n\nIf the input contains [`missing`](@ref) values, return `missing` if all non-missing\nvalues are `false` (or equivalently, if the input contains no `true` value), following\n[three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic).\n\n# Examples\n```jldoctest\njulia> a = [true,false,false,true]\n4-element Array{Bool,1}:\n 1\n 0\n 0\n 1\n\njulia> any(a)\ntrue\n\njulia> any((println(i); v) for (i, v) in enumerate(a))\n1\ntrue\n\njulia> any([missing, true])\ntrue\n\njulia> any([false, missing])\nmissing\n```\n"},{"Tuple{AbstractArray}":"    any(A; dims)\n\nTest whether any values along the given dimensions of an array are `true`.\n\n# Examples\n```jldoctest\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n 1  0\n 1  0\n\njulia> any(A, dims=1)\n1×2 Array{Bool,2}:\n 1  0\n\njulia> any(A, dims=2)\n2×1 Array{Bool,2}:\n 1\n 1\n```\n"},{"Tuple{Any,Any}":"    any(p, itr) -> Bool\n\nDetermine whether predicate `p` returns `true` for any elements of `itr`, returning\n`true` as soon as the first item in `itr` for which `p` returns `true` is encountered\n(short-circuiting).\n\nIf the input contains [`missing`](@ref) values, return `missing` if all non-missing\nvalues are `false` (or equivalently, if the input contains no `true` value), following\n[three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic).\n\n# Examples\n```jldoctest\njulia> any(i->(4<=i<=6), [3,5,7])\ntrue\n\njulia> any(i -> (println(i); i > 3), 1:10)\n1\n2\n3\n4\ntrue\n\njulia> any(i -> i > 0, [1, missing])\ntrue\n\njulia> any(i -> i > 0, [-1, missing])\nmissing\n\njulia> any(i -> i > 0, [-1, 0])\nfalse\n```\n"}],"Base.permute!":[{"Tuple{Any,AbstractArray{T,1} where T}":"    permute!(v, p)\n\nPermute vector `v` in-place, according to permutation `p`. No checking is done\nto verify that `p` is a permutation.\n\nTo return a new permutation, use `v[p]`. Note that this is generally faster than\n`permute!(v,p)` for large vectors.\n\nSee also [`invpermute!`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> permute!(A, perm);\n\njulia> A\n4-element Array{Int64,1}:\n 1\n 4\n 3\n 1\n```\n"}],"Base.FilteringRF":[{"Union{}":"    FilteringRF(f, rf) -> rf′\n\nCreate a filtering reducing function `rf′(acc, x) = f(x) ? rf(acc, x) : acc`.\n"}],"Base.xor":[{"Tuple{Bool,Bool}":"    xor(x, y)\n    ⊻(x, y)\n\nBitwise exclusive or of `x` and `y`. Implements\n[three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic),\nreturning [`missing`](@ref) if one of the arguments is `missing`.\n\nThe infix operation `a ⊻ b` is a synonym for `xor(a,b)`, and\n`⊻` can be typed by tab-completing `\\xor` or `\\veebar` in the Julia REPL.\n\n# Examples\n```jldoctest\njulia> xor(true, false)\ntrue\n\njulia> xor(true, true)\nfalse\n\njulia> xor(true, missing)\nmissing\n\njulia> false ⊻ false\nfalse\n\njulia> [true; true; false] .⊻ [true; false; false]\n3-element BitArray{1}:\n 0\n 1\n 0\n```\n"}],"Base.readuntil":[{"Tuple{AbstractString,Vararg{Any,N} where N}":"    readuntil(stream::IO, delim; keep::Bool = false)\n    readuntil(filename::AbstractString, delim; keep::Bool = false)\n\nRead a string from an I/O stream or a file, up to the given delimiter.\nThe delimiter can be a `UInt8`, `AbstractChar`, string, or vector.\nKeyword argument `keep` controls whether the delimiter is included in the result.\nThe text is assumed to be encoded in UTF-8.\n\n# Examples\n```jldoctest\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readuntil(\"my_file.txt\", 'L')\n\"Julia\"\n\njulia> readuntil(\"my_file.txt\", '.', keep = true)\n\"JuliaLang is a GitHub organization.\"\n\njulia> rm(\"my_file.txt\")\n```\n"}],"Base.Dict":[{"Union{}":"    Dict([itr])\n\n`Dict{K,V}()` constructs a hash table with keys of type `K` and values of type `V`.\nKeys are compared with [`isequal`](@ref) and hashed with [`hash`](@ref).\n\nGiven a single iterable argument, constructs a [`Dict`](@ref) whose key-value pairs\nare taken from 2-tuples `(key,value)` generated by the argument.\n\n# Examples\n```jldoctest\njulia> Dict([(\"A\", 1), (\"B\", 2)])\nDict{String,Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n```\n\nAlternatively, a sequence of pair arguments may be passed.\n\n```jldoctest\njulia> Dict(\"A\"=>1, \"B\"=>2)\nDict{String,Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n```\n"}],"Base.exit":[{"Tuple{Any}":"    exit(code=0)\n\nStop the program with an exit code. The default exit code is zero, indicating that the\nprogram completed successfully. In an interactive session, `exit()` can be called with\nthe keyboard shortcut `^D`.\n"}],"Base.Clonglong":[{"Union{}":"    Clonglong\n\nEquivalent to the native `signed long long` c-type ([`Int64`](@ref)).\n"}],"Base.thisind":[{"Tuple{AbstractString,Integer}":"    thisind(s::AbstractString, i::Integer) -> Int\n\nIf `i` is in bounds in `s` return the index of the start of the character whose\nencoding code unit `i` is part of. In other words, if `i` is the start of a\ncharacter, return `i`; if `i` is not the start of a character, rewind until the\nstart of a character and return that index. If `i` is equal to 0 or `ncodeunits(s)+1`\nreturn `i`. In all other cases throw `BoundsError`.\n\n# Examples\n```jldoctest\njulia> thisind(\"α\", 0)\n0\n\njulia> thisind(\"α\", 1)\n1\n\njulia> thisind(\"α\", 2)\n1\n\njulia> thisind(\"α\", 3)\n3\n\njulia> thisind(\"α\", 4)\nERROR: BoundsError: attempt to access String\n  at index [4]\n[...]\n\njulia> thisind(\"α\", -1)\nERROR: BoundsError: attempt to access String\n  at index [-1]\n[...]\n```\n"}],"Base.strip":[{"Tuple{AbstractString}":"    strip([pred=isspace,] str::AbstractString) -> SubString\n    strip(str::AbstractString, chars) -> SubString\n\nRemove leading and trailing characters from `str`, either those specified by `chars` or\nthose for which the function `pred` returns `true`.\n\nThe default behaviour is to remove leading whitespace and delimiters: see\n[`isspace`](@ref) for precise details.\n\nThe optional `chars` argument specifies which characters to remove: it can be a single\ncharacter, vector or set of characters.\n\n!!! compat \"Julia 1.2\"\n    The method which accepts a predicate function requires Julia 1.2 or later.\n\n# Examples\n```jldoctest\njulia> strip(\"{3, 5}\\n\", ['{', '}', '\\n'])\n\"3, 5\"\n```\n"}],"Base.reshape":[{"Union{}":"    reshape(A, dims...) -> AbstractArray\n    reshape(A, dims) -> AbstractArray\n\nReturn an array with the same data as `A`, but with different\ndimension sizes or number of dimensions. The two arrays share the same\nunderlying data, so that the result is mutable if and only if `A` is\nmutable, and setting elements of one alters the values of the other.\n\nThe new dimensions may be specified either as a list of arguments or\nas a shape tuple. At most one dimension may be specified with a `:`,\nin which case its length is computed such that its product with all\nthe specified dimensions is equal to the length of the original array\n`A`. The total number of elements must not change.\n\n# Examples\n```jldoctest\njulia> A = Vector(1:16)\n16-element Array{Int64,1}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n\njulia> reshape(A, (4, 4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reshape(A, 2, :)\n2×8 Array{Int64,2}:\n 1  3  5  7   9  11  13  15\n 2  4  6  8  10  12  14  16\n\njulia> reshape(1:6, 2, 3)\n2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:\n 1  3  5\n 2  4  6\n```\n"}],"Base.splitprec":[{"Union{Tuple{F}, Tuple{Type{F},Integer}} where F<:AbstractFloat":"    hi, lo = splitprec(F::Type{<:AbstractFloat}, i::Integer)\n\nRepresent an integer `i` as a pair of floating-point numbers `hi` and\n`lo` (of type `F`) such that:\n- `widen(hi) + widen(lo) ≈ i`. It is exact if 1.5 * (number of precision bits in `F`) is greater than the number of bits in `i`.\n- all bits in `hi` are more significant than any of the bits in `lo`\n- `hi` can be exactly multiplied by the `hi` component of another call to `splitprec`.\n\nIn particular, while `convert(Float64, i)` can be lossy since Float64\nhas only 53 bits of precision, `splitprec(Float64, i)` is exact for\nany Int64/UInt64.\n"}],"Base.stdin":[{"Union{}":"    stdin\n\nGlobal variable referring to the standard input stream.\n"}],"Base.widemul":[{"Tuple{Number,Number}":"    widemul(x, y)\n\nMultiply `x` and `y`, giving the result as a larger type.\n\n# Examples\n```jldoctest\njulia> widemul(Float32(3.), 4.)\n12.0\n```\n"}],"Base.cat":[{"Tuple":"    cat(A...; dims=dims)\n\nConcatenate the input arrays along the specified dimensions in the iterable `dims`. For\ndimensions not in `dims`, all input arrays should have the same size, which will also be the\nsize of the output array along that dimension. For dimensions in `dims`, the size of the\noutput array is the sum of the sizes of the input arrays along that dimension. If `dims` is\na single number, the different arrays are tightly stacked along that dimension. If `dims` is\nan iterable containing several dimensions, this allows one to construct block diagonal\nmatrices and their higher-dimensional analogues by simultaneously increasing several\ndimensions for every new input array and putting zero blocks elsewhere. For example,\n`cat(matrices...; dims=(1,2))` builds a block diagonal matrix, i.e. a block matrix with\n`matrices[1]`, `matrices[2]`, ... as diagonal blocks and matching zero blocks away from the\ndiagonal.\n"}],"Base.Pipe":[{"Tuple{}":"Construct an uninitialized Pipe object.\n\nThe appropriate end of the pipe will be automatically initialized if\nthe object is used in process spawning. This can be useful to easily\nobtain references in process pipelines, e.g.:\n\n```\njulia> err = Pipe()\n\n# After this `err` will be initialized and you may read `foo`'s\n# stderr from the `err` pipe.\njulia> run(pipeline(pipeline(`foo`, stderr=err), `cat`), wait=false)\n```\n"}],"Base.htol":[{"Tuple{Any}":"    htol(x)\n\nConvert the endianness of a value from that used by the Host to Little-endian.\n"}],"Base.cumprod!":[{"Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}":"    cumprod!(y::AbstractVector, x::AbstractVector)\n\nCumulative product of a vector `x`, storing the result in `y`.\nSee also [`cumprod`](@ref).\n"},{"Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Any}} where T":"    cumprod!(B, A; dims::Integer)\n\nCumulative product of `A` along the dimension `dims`, storing the result in `B`.\nSee also [`cumprod`](@ref).\n"}],"Base.Timer":[{"Union{}":"    Timer(delay; interval = 0)\n\nCreate a timer that wakes up tasks waiting for it (by calling [`wait`](@ref) on the timer object).\n\nWaiting tasks are woken after an initial delay of `delay` seconds, and then repeating with the given\n`interval` in seconds. If `interval` is equal to `0`, the timer is only triggered once. When\nthe timer is closed (by [`close`](@ref) waiting tasks are woken with an error. Use [`isopen`](@ref)\nto check whether a timer is still active.\n"},{"Tuple{Function,Real}":"    Timer(callback::Function, delay; interval = 0)\n\nCreate a timer that wakes up tasks waiting for it (by calling [`wait`](@ref) on the timer object) and\ncalls the function `callback`.\n\nWaiting tasks are woken and the function `callback` is called after an initial delay of `delay` seconds,\nand then repeating with the given `interval` in seconds. If `interval` is equal to `0`, the timer\nis only triggered once. The function `callback` is called with a single argument, the timer itself.\nWhen the timer is closed (by [`close`](@ref) waiting tasks are woken with an error. Use [`isopen`](@ref)\nto check whether a timer is still active.\n\n# Examples\n\nHere the first number is printed after a delay of two seconds, then the following numbers are printed quickly.\n\n```julia-repl\njulia> begin\n           i = 0\n           cb(timer) = (global i += 1; println(i))\n           t = Timer(cb, 2, interval=0.2)\n           wait(t)\n           sleep(0.5)\n           close(t)\n       end\n1\n2\n3\n```\n"}],"Base.Dims":[{"Union{}":"    Dims{N}\n\nAn `NTuple` of `N` `Int`s used to represent the dimensions\nof an [`AbstractArray`](@ref).\n"}],"Base.code_typed":[{"Tuple{Any,Any}":"    code_typed(f, types; optimize=true, debuginfo=:default)\n\nReturns an array of type-inferred lowered form (IR) for the methods matching the given\ngeneric function and type signature. The keyword argument `optimize` controls whether\nadditional optimizations, such as inlining, are also applied.\nThe keyword `debuginfo` controls the amount of code metadata present in the output,\npossible options are `:source` or `:none`.\n"}],"Base.KeyError":[{"Union{}":"    KeyError(key)\n\nAn indexing operation into an `AbstractDict` (`Dict`) or `Set` like object tried to access or\ndelete a non-existent element.\n"}],"Base.iswritable":[{"Union{}":"    iswritable(io) -> Bool\n\nReturn `true` if the specified IO object is writable (if that can be determined).\n\n# Examples\n```jldoctest\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           iswritable(io)\n       end\ntrue\n\njulia> open(\"myfile.txt\", \"r\") do io\n           iswritable(io)\n       end\nfalse\n\njulia> rm(\"myfile.txt\")\n```\n"}],"Base.padding":[{"Tuple{Any}":"    Compute the location of padding in a type.\n"}],"Base.require":[{"Tuple{Module,Symbol}":"    require(into::Module, module::Symbol)\n\nThis function is part of the implementation of [`using`](@ref) / [`import`](@ref), if a module is not\nalready defined in `Main`. It can also be called directly to force reloading a module,\nregardless of whether it has been loaded before (for example, when interactively developing\nlibraries).\n\nLoads a source file, in the context of the `Main` module, on every active node, searching\nstandard locations for files. `require` is considered a top-level operation, so it sets the\ncurrent `include` path but does not use it to search for files (see help for [`include`](@ref)).\nThis function is typically used to load library code, and is implicitly called by `using` to\nload packages.\n\nWhen searching for files, `require` first looks for package code in the global array\n[`LOAD_PATH`](@ref). `require` is case-sensitive on all platforms, including those with\ncase-insensitive filesystems like macOS and Windows.\n\nFor more details regarding code loading, see the manual sections on [modules](@ref modules) and\n[parallel computing](@ref code-availability).\n"}],"Base.eachrow":[{"Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}":"    eachrow(A::AbstractVecOrMat)\n\nCreate a generator that iterates over the first dimension of vector or matrix `A`,\nreturning the rows as views.\n\nSee also [`eachcol`](@ref) and [`eachslice`](@ref).\n\n!!! compat \"Julia 1.1\"\n     This function requires at least Julia 1.1.\n"}],"Base.indentation":[{"Tuple{AbstractString}":"    indentation(str::AbstractString; tabwidth=8) -> (Int, Bool)\n\nCalculate the width of leading white space. Return the width and a flag to indicate\nif the string is empty.\n\n# Examples\n```jldoctest\njulia> Base.indentation(\"\")\n(0, true)\n\njulia> Base.indentation(\"  a\")\n(2, false)\n\njulia> Base.indentation(\"\\ta\"; tabwidth=3)\n(3, false)\n```\n"}],"Base.WeakKeyDict":[{"Union{}":"    WeakKeyDict([itr])\n\n`WeakKeyDict()` constructs a hash table where the keys are weak\nreferences to objects which may be garbage collected even when\nreferenced in a hash table.\n\nSee [`Dict`](@ref) for further help.  Note, unlike [`Dict`](@ref),\n`WeakKeyDict` does not convert keys on insertion.\n"}],"Base.Cfloat":[{"Union{}":"    Cfloat\n\nEquivalent to the native `float` c-type ([`Float32`](@ref)).\n"}],"Base.view":[{"Union{Tuple{N}, Tuple{AbstractArray,Vararg{Any,N}}} where N":"    view(A, inds...)\n\nLike [`getindex`](@ref), but returns a view into the parent array `A` with the\ngiven indices instead of making a copy.  Calling [`getindex`](@ref) or\n[`setindex!`](@ref) on the returned `SubArray` computes the\nindices to the parent array on the fly without checking bounds.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = view(A, :, 1)\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\n 0\n 0\n\njulia> A # Note A has changed even though we modified b\n2×2 Array{Int64,2}:\n 0  2\n 0  4\n```\n"}],"Base.@boundscheck":[{"Tuple{Any}":"    @boundscheck(blk)\n\nAnnotates the expression `blk` as a bounds checking block, allowing it to be elided by [`@inbounds`](@ref).\n\n!!! note\n    The function in which `@boundscheck` is written must be inlined into\n    its caller in order for `@inbounds` to have effect.\n\n# Examples\n```jldoctest; filter = r\"Stacktrace:(\\n \\[[0-9]+\\].*)*\"\njulia> @inline function g(A, i)\n           @boundscheck checkbounds(A, i)\n           return \"accessing ($A)[$i]\"\n       end;\n\njulia> f1() = return g(1:2, -1);\n\njulia> f2() = @inbounds return g(1:2, -1);\n\njulia> f1()\nERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]\nStacktrace:\n [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455\n [2] checkbounds at ./abstractarray.jl:420 [inlined]\n [3] g at ./none:2 [inlined]\n [4] f1() at ./none:1\n [5] top-level scope\n\njulia> f2()\n\"accessing (1:2)[-1]\"\n```\n\n!!! warning\n\n    The `@boundscheck` annotation allows you, as a library writer, to opt-in to\n    allowing *other code* to remove your bounds checks with [`@inbounds`](@ref).\n    As noted there, the caller must verify—using information they can access—that\n    their accesses are valid before using `@inbounds`. For indexing into your\n    [`AbstractArray`](@ref) subclasses, for example, this involves checking the\n    indices against its [`size`](@ref). Therefore, `@boundscheck` annotations\n    should only be added to a [`getindex`](@ref) or [`setindex!`](@ref)\n    implementation after you are certain its behavior is correct.\n"}],"Base.copyto!":[{"Tuple{AbstractArray,CartesianIndices,AbstractArray,CartesianIndices}":"    copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest\n\nCopy the block of `src` in the range of `Rsrc` to the block of `dest`\nin the range of `Rdest`. The sizes of the two regions must match.\n"},{"Tuple{Any,Any}":"    copyto!(dest::AbstractArray, src) -> dest\n\n\nCopy all elements from collection `src` to array `dest`, whose length must be greater than\nor equal to the length `n` of `src`. The first `n` elements of `dest` are overwritten,\nthe other elements are left untouched.\n\n# Examples\n```jldoctest\njulia> x = [1., 0., 3., 0., 5.];\n\njulia> y = zeros(7);\n\njulia> copyto!(y, x);\n\njulia> y\n7-element Array{Float64,1}:\n 1.0\n 0.0\n 3.0\n 0.0\n 5.0\n 0.0\n 0.0\n```\n"},{"Union{Tuple{T}, Tuple{Array{T,N} where N,Integer,Array{T,N} where N,Integer,Integer}} where T":"    copyto!(dest, do, src, so, N)\n\nCopy `N` elements from collection `src` starting at offset `so`, to array `dest` starting at\noffset `do`. Return `dest`.\n"}],"Base.isambiguous":[{"Tuple{Method,Method}":"    Base.isambiguous(m1, m2; ambiguous_bottom=false) -> Bool\n\nDetermine whether two methods `m1` and `m2` (typically of the same\nfunction) are ambiguous.  This test is performed in the context of\nother methods of the same function; in isolation, `m1` and `m2` might\nbe ambiguous, but if a third method resolving the ambiguity has been\ndefined, this returns `false`.\n\nFor parametric types, the `ambiguous_bottom` keyword argument controls whether\n`Union{}` counts as an ambiguous intersection of type parameters – when `true`,\nit is considered ambiguous, when `false` it is not.\n\n# Examples\n```jldoctest\njulia> foo(x::Complex{<:Integer}) = 1\nfoo (generic function with 1 method)\n\njulia> foo(x::Complex{<:Rational}) = 2\nfoo (generic function with 2 methods)\n\njulia> m1, m2 = collect(methods(foo));\n\njulia> typeintersect(m1.sig, m2.sig)\nTuple{typeof(foo),Complex{Union{}}}\n\njulia> Base.isambiguous(m1, m2, ambiguous_bottom=true)\ntrue\n\njulia> Base.isambiguous(m1, m2, ambiguous_bottom=false)\nfalse\n```\n"}],"Base.promote_rule":[{"Union{}":"    promote_rule(type1, type2)\n\nSpecifies what type should be used by [`promote`](@ref) when given values of types `type1` and\n`type2`. This function should not be called directly, but should have definitions added to\nit for new types as appropriate.\n"}],"Base.download":[{"Tuple{Any,Any}":"    download(url::AbstractString, [localfile::AbstractString])\n\nDownload a file from the given url, optionally renaming it to the given local file name. If\nno filename is given this will download into a randomly-named file in your temp directory.\nNote that this function relies on the availability of external tools such as `curl`, `wget`\nor `fetch` to download the file and is provided for convenience. For production use or\nsituations in which more options are needed, please use a package that provides the desired\nfunctionality instead.\n\nReturns the filename of the downloaded file.\n"}],"Base.notify":[{"Tuple{Base.GenericCondition,Any}":"    notify(condition, val=nothing; all=true, error=false)\n\nWake up tasks waiting for a condition, passing them `val`. If `all` is `true` (the default),\nall waiting tasks are woken, otherwise only one is. If `error` is `true`, the passed value\nis raised as an exception in the woken tasks.\n\nReturn the count of tasks woken up. Return 0 if no tasks are waiting on `condition`.\n"}],"Base.checkindex":[{"Tuple{Type{Bool},AbstractUnitRange,Any}":"    checkindex(Bool, inds::AbstractUnitRange, index)\n\nReturn `true` if the given `index` is within the bounds of\n`inds`. Custom types that would like to behave as indices for all\narrays can extend this method in order to provide a specialized bounds\nchecking implementation.\n\n# Examples\n```jldoctest\njulia> checkindex(Bool, 1:20, 8)\ntrue\n\njulia> checkindex(Bool, 1:20, 21)\nfalse\n```\n"}],"Base.one":[{"Union{Tuple{Type{T}}, Tuple{T}} where T<:Number":"    one(x)\n    one(T::type)\n\nReturn a multiplicative identity for `x`: a value such that\n`one(x)*x == x*one(x) == x`.  Alternatively `one(T)` can\ntake a type `T`, in which case `one` returns a multiplicative\nidentity for any `x` of type `T`.\n\nIf possible, `one(x)` returns a value of the same type as `x`,\nand `one(T)` returns a value of type `T`.  However, this may\nnot be the case for types representing dimensionful quantities\n(e.g. time in days), since the multiplicative\nidentity must be dimensionless.  In that case, `one(x)`\nshould return an identity value of the same precision\n(and shape, for matrices) as `x`.\n\nIf you want a quantity that is of the same type as `x`, or of type `T`,\neven if `x` is dimensionful, use [`oneunit`](@ref) instead.\n\n# Examples\n```jldoctest\njulia> one(3.7)\n1.0\n\njulia> one(Int)\n1\n\njulia> import Dates; one(Dates.Day(1))\n1\n```\n"}],"Base.Slice":[{"Union{}":"   Slice(indices)\n\nRepresent an AbstractUnitRange of indices as a vector of the indices themselves,\nwith special handling to signal they represent a complete slice of a dimension (:).\n\nUpon calling `to_indices`, Colons are converted to Slice objects to represent\nthe indices over which the Colon spans. Slice objects are themselves unit\nranges with the same indices as those they wrap. This means that indexing into\nSlice objects with an integer always returns that exact integer, and they\niterate over all the wrapped indices, even supporting offset indices.\n"}],"Base.skipmissing":[{"Tuple{Any}":"    skipmissing(itr)\n\nReturn an iterator over the elements in `itr` skipping [`missing`](@ref) values.\nThe returned object can be indexed using indices of `itr` if the latter is indexable.\nIndices corresponding to missing values are not valid: they are skipped by [`keys`](@ref)\nand [`eachindex`](@ref), and a `MissingException` is thrown when trying to use them.\n\nUse [`collect`](@ref) to obtain an `Array` containing the non-`missing` values in\n`itr`. Note that even if `itr` is a multidimensional array, the result will always\nbe a `Vector` since it is not possible to remove missings while preserving dimensions\nof the input.\n\n# Examples\n```jldoctest\njulia> x = skipmissing([1, missing, 2])\nBase.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[1, missing, 2])\n\njulia> sum(x)\n3\n\njulia> x[1]\n1\n\njulia> x[2]\nERROR: MissingException: the value at index (2,) is missing\n[...]\n\njulia> argmax(x)\n3\n\njulia> collect(keys(x))\n2-element Array{Int64,1}:\n 1\n 3\n\njulia> collect(skipmissing([1, missing, 2]))\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> collect(skipmissing([1 missing; 2 missing]))\n2-element Array{Int64,1}:\n 1\n 2\n```\n"}],"Base.redirect_stdin":[{"Union{}":"    redirect_stdin([stream]) -> (rd, wr)\n\nLike [`redirect_stdout`](@ref), but for [`stdin`](@ref).\nNote that the order of the return tuple is still `(rd, wr)`,\ni.e. data to be read from [`stdin`](@ref) may be written to `wr`.\n\n!!! note\n    `stream` must be a `TTY`, a `Pipe`, or a socket.\n"},{"Tuple{Function,Any}":"    redirect_stdin(f::Function, stream)\n\nRun the function `f` while redirecting [`stdin`](@ref) to `stream`.\nUpon completion, [`stdin`](@ref) is restored to its prior setting.\n\n!!! note\n    `stream` must be a `TTY`, a `Pipe`, or a socket.\n"}],"Base.diff":[{"Union{Tuple{AbstractArray{T,N}}, Tuple{N}, Tuple{T}} where N where T":"    diff(A::AbstractVector)\n    diff(A::AbstractArray; dims::Integer)\n\nFinite difference operator on a vector or a multidimensional array `A`. In the\nlatter case the dimension to operate on needs to be specified with the `dims`\nkeyword argument.\n\n!!! compat \"Julia 1.1\"\n    `diff` for arrays with dimension higher than 2 requires at least Julia 1.1.\n\n# Examples\n```jldoctest\njulia> a = [2 4; 6 16]\n2×2 Array{Int64,2}:\n 2   4\n 6  16\n\njulia> diff(a, dims=2)\n2×1 Array{Int64,2}:\n  2\n 10\n\njulia> diff(vec(a))\n3-element Array{Int64,1}:\n  4\n -2\n 12\n```\n"}],"Base.ProcessFailedException":[{"Union{}":"    ProcessFailedException\n\nIndicates problematic exit status of a process.\nWhen running commands or pipelines, this is thrown to indicate\na nonzero exit code was returned (i.e. that the invoked process failed).\n"}],"Base.showerror":[{"Tuple{IO,Any}":"    showerror(io, e)\n\nShow a descriptive representation of an exception object `e`.\nThis method is used to display the exception after a call to [`throw`](@ref).\n\n# Examples\n```jldoctest\njulia> struct MyException <: Exception\n           msg::AbstractString\n       end\n\njulia> function Base.showerror(io::IO, err::MyException)\n           print(io, \"MyException: \")\n           print(io, err.msg)\n       end\n\njulia> err = MyException(\"test exception\")\nMyException(\"test exception\")\n\njulia> sprint(showerror, err)\n\"MyException: test exception\"\n\njulia> throw(MyException(\"test exception\"))\nERROR: MyException: test exception\n```\n"}],"Base.ceil":[{"Union{}":"    ceil([T,] x)\n    ceil(x; digits::Integer= [, base = 10])\n    ceil(x; sigdigits::Integer= [, base = 10])\n\n`ceil(x)` returns the nearest integral value of the same type as `x` that is greater than or\nequal to `x`.\n\n`ceil(T, x)` converts the result to type `T`, throwing an `InexactError` if the value is not\nrepresentable.\n\n`digits`, `sigdigits` and `base` work as for [`round`](@ref).\n"}],"Base.@inbounds":[{"Tuple{Any}":"    @inbounds(blk)\n\nEliminates array bounds checking within expressions.\n\nIn the example below the in-range check for referencing\nelement `i` of array `A` is skipped to improve performance.\n\n```julia\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i = 1:length(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n```\n\n!!! warning\n\n    Using `@inbounds` may return incorrect results/crashes/corruption\n    for out-of-bounds indices. The user is responsible for checking it manually.\n    Only use `@inbounds` when it is certain from the information locally available\n    that all accesses are in bounds.\n"}],"Base.task_local_storage":[{"Tuple{Any}":"    task_local_storage(key)\n\nLook up the value of a key in the current task's task-local storage.\n"},{"Tuple{Function,Any,Any}":"    task_local_storage(body, key, value)\n\nCall the function `body` with a modified task-local storage, in which `value` is assigned to\n`key`; the previous value of `key`, or lack thereof, is restored afterwards. Useful\nfor emulating dynamic scoping.\n"},{"Tuple{Any,Any}":"    task_local_storage(key, value)\n\nAssign a value to a key in the current task's task-local storage.\n"}],"Base.circshift":[{"Tuple{AbstractArray,Any}":"    circshift(A, shifts)\n\nCircularly shift, i.e. rotate, the data in an array. The second argument is a tuple or\nvector giving the amount to shift in each dimension, or an integer to shift only in the\nfirst dimension.\n\n# Examples\n```jldoctest\njulia> b = reshape(Vector(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> circshift(b, (0,2))\n4×4 Array{Int64,2}:\n  9  13  1  5\n 10  14  2  6\n 11  15  3  7\n 12  16  4  8\n\njulia> circshift(b, (-1,0))\n4×4 Array{Int64,2}:\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n 1  5   9  13\n\njulia> a = BitArray([true, true, false, false, true])\n5-element BitArray{1}:\n 1\n 1\n 0\n 0\n 1\n\njulia> circshift(a, 1)\n5-element BitArray{1}:\n 1\n 1\n 1\n 0\n 0\n\njulia> circshift(a, -1)\n5-element BitArray{1}:\n 1\n 0\n 0\n 1\n 1\n```\n\nSee also [`circshift!`](@ref).\n"}],"Base.show_invalid":[{"Union{}":"    show_invalid(io::IO, c::AbstractChar)\n\nCalled by `show(io, c)` when [`isoverlong(c)`](@ref) or\n[`ismalformed(c)`](@ref) return `true`.   Subclasses\nof `AbstractChar` should define `Base.show_invalid` methods\nif they support storing invalid character data.\n"}],"Base.min":[{"Tuple{Any,Any}":"    min(x, y, ...)\n\nReturn the minimum of the arguments. See also the [`minimum`](@ref) function\nto take the minimum element from a collection.\n\n# Examples\n```jldoctest\njulia> min(2, 5, 1)\n1\n```\n"}],"Base.text_colors":[{"Union{}":"Dictionary of color codes for the terminal.\n\nAvailable colors are: `:normal`,\n`:default`,\n`:bold`,\n`:black`,\n`:blink`,\n`:blue`,\n`:cyan`,\n`:green`,\n`:hidden`,\n`:light_black`,\n`:light_blue`,\n`:light_cyan`,\n`:light_green`,\n`:light_magenta`,\n`:light_red`,\n`:light_yellow`,\n`:magenta`,\n`:nothing`,\n`:red`,\n`:reverse`,\n`:underline`,\n`:white`, or \n`:yellow` as well as the integers 0 to 255 inclusive.\n\nThe color `:default` will print text in the default color while the color `:normal`\nwill print text with all text properties (like boldness) reset.\nPrinting with the color `:nothing` will print the string without modifications.\n"}],"Base.Matrix":[{"Union{}":"    Matrix{T} <: AbstractMatrix{T}\n\nTwo-dimensional dense array with elements of type `T`, often used to represent\na mathematical matrix. Alias for [`Array{T,2}`](@ref).\n"}],"Base.typemin":[{"Union{}":"    typemin(T)\n\nThe lowest value representable by the given (real) numeric DataType `T`.\n\n# Examples\n```jldoctest\njulia> typemin(Float16)\n-Inf16\n\njulia> typemin(Float32)\n-Inf32\n```\n"}],"Base.@macroexpand":[{"Tuple{Any}":"    @macroexpand\n\nReturn equivalent expression with all macros removed (expanded).\n\nThere are differences between `@macroexpand` and [`macroexpand`](@ref).\n\n* While [`macroexpand`](@ref) takes a keyword argument `recursive`, `@macroexpand`\nis always recursive. For a non recursive macro version, see [`@macroexpand1`](@ref).\n\n* While [`macroexpand`](@ref) has an explicit `module` argument, `@macroexpand` always\nexpands with respect to the module in which it is called.\nThis is best seen in the following example:\n```julia-repl\njulia> module M\n           macro m()\n               1\n           end\n           function f()\n               (@macroexpand(@m),\n                macroexpand(M, :(@m)),\n                macroexpand(Main, :(@m))\n               )\n           end\n       end\nM\n\njulia> macro m()\n           2\n       end\n@m (macro with 1 method)\n\njulia> M.f()\n(1, 1, 2)\n```\nWith `@macroexpand` the expression expands where `@macroexpand` appears in the code (module `M` in the example).\nWith `macroexpand` the expression expands in the module given as the first argument.\n"}],"Base.@assert":[{"Tuple{Any,Vararg{Any,N} where N}":"    @assert cond [text]\n\nThrow an [`AssertionError`](@ref) if `cond` is `false`. Preferred syntax for writing assertions.\nMessage `text` is optionally displayed upon assertion failure.\n\n!!! warning\n    An assert might be disabled at various optimization levels.\n    Assert should therefore only be used as a debugging tool\n    and not used for authentication verification (e.g., verifying passwords),\n    nor should side effects needed for the function to work correctly\n    be used inside of asserts.\n\n# Examples\n```jldoctest\njulia> @assert iseven(3) \"3 is an odd number!\"\nERROR: AssertionError: 3 is an odd number!\n\njulia> @assert isodd(3) \"What even are numbers?\"\n```\n"}],"Base.zero":[{"Tuple{Number}":"    zero(x)\n\nGet the additive identity element for the type of `x` (`x` can also specify the type itself).\n\n# Examples\n```jldoctest\njulia> zero(1)\n0\n\njulia> zero(big\"2.0\")\n0.0\n\njulia> zero(rand(2,2))\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n```\n"}],"Base.esc":[{"Tuple{Any}":"    esc(e)\n\nOnly valid in the context of an [`Expr`](@ref) returned from a macro. Prevents the macro hygiene\npass from turning embedded variables into gensym variables. See the [Macros](@ref man-macros)\nsection of the Metaprogramming chapter of the manual for more details and examples.\n"}],"Base.AsyncCollector":[{"Tuple{Any,Any,Vararg{Any,N} where N}":"    AsyncCollector(f, results, c...; ntasks=0, batch_size=nothing) -> iterator\n\nReturn an iterator which applies `f` to each element of `c` asynchronously\nand collects output into `results`.\n\nKeyword args `ntasks` and `batch_size` have the same behavior as in\n[`asyncmap`](@ref). If `batch_size` is specified, `f` must\nbe a function which operates on an array of argument tuples.\n\n!!! note\n    `iterate(::AsyncCollector, state) -> (nothing, state)`. A successful return\n    from `iterate` indicates that the next element from the input collection is\n    being processed asynchronously. It blocks until a free worker task becomes\n    available.\n\n!!! note\n    `for _ in AsyncCollector(f, results, c...; ntasks=1) end` is equivalent to\n    `map!(f, results, c...)`.\n"}],"Base.map!":[{"Tuple{Any,Base.ValueIterator}":"    map!(f, values(dict::AbstractDict))\n\nModifies `dict` by transforming each value from `val` to `f(val)`.\nNote that the type of `dict` cannot be changed: if `f(val)` is not an instance of the value type\nof `dict` then it will be converted to the value type if possible and otherwise raise an error.\n\n# Examples\n```jldoctest\njulia> d = Dict(:a => 1, :b => 2)\nDict{Symbol,Int64} with 2 entries:\n  :a => 1\n  :b => 2\n\njulia> map!(v -> v-1, values(d))\nBase.ValueIterator for a Dict{Symbol,Int64} with 2 entries. Values:\n  0\n  1\n```\n"},{"Union{Tuple{F}, Tuple{F,AbstractArray,Vararg{AbstractArray,N} where N}} where F":"    map!(function, destination, collection...)\n\nLike [`map`](@ref), but stores the result in `destination` rather than a new\ncollection. `destination` must be at least as large as the first collection.\n\n# Examples\n```jldoctest\njulia> a = zeros(3);\n\njulia> map!(x -> x * 2, a, [1, 2, 3]);\n\njulia> a\n3-element Array{Float64,1}:\n 2.0\n 4.0\n 6.0\n```\n"}],"Base.ignorestatus":[{"Tuple{Cmd}":"    ignorestatus(command)\n\nMark a command object so that running it will not throw an error if the result code is non-zero.\n"}],"Base.process_exited":[{"Tuple{Base.Process}":"    process_exited(p::Process)\n\nDetermine whether a process has exited.\n"}],"Base.systemerror":[{"Tuple{Any,Bool}":"    systemerror(sysfunc[, errno::Cint=Libc.errno()])\n    systemerror(sysfunc, iftrue::Bool)\n\nRaises a `SystemError` for `errno` with the descriptive string `sysfunc` if `iftrue` is `true`\n"}],"Base.disable_sigint":[{"Tuple{Function}":"    disable_sigint(f::Function)\n\nDisable Ctrl-C handler during execution of a function on the current task,\nfor calling external code that may call julia code that is not interrupt safe.\nIntended to be called using `do` block syntax as follows:\n\n    disable_sigint() do\n        # interrupt-unsafe code\n        ...\n    end\n\nThis is not needed on worker threads (`Threads.threadid() != 1`) since the\n`InterruptException` will only be delivered to the master thread.\nExternal functions that do not call julia code or julia runtime\nautomatically disable sigint during their execution.\n"}],"Base.isdispatchtuple":[{"Tuple{Any}":"    isdispatchtuple(T)\n\nDetermine whether type `T` is a tuple \"leaf type\",\nmeaning it could appear as a type signature in dispatch\nand has no subtypes (or supertypes) which could appear in a call.\n"}],"Base.ENV":[{"Union{}":"    ENV\n\nReference to the singleton `EnvDict`, providing a dictionary interface to system environment\nvariables.\n\n(On Windows, system environment variables are case-insensitive, and `ENV` correspondingly converts\nall keys to uppercase for display, iteration, and copying. Portable code should not rely on the\nability to distinguish variables by case, and should beware that setting an ostensibly lowercase\nvariable may result in an uppercase `ENV` key.)\n"}],"Base.typejoin":[{"Tuple{}":"    typejoin(T, S)\n\n\nReturn the closest common ancestor of `T` and `S`, i.e. the narrowest type from which\nthey both inherit.\n"}],"Base.stdout":[{"Union{}":"    stdout\n\nGlobal variable referring to the standard out stream.\n"}],"Base.replace_ref_end!":[{"Tuple{Any}":"    replace_ref_end!(ex)\n\nRecursively replace occurrences of the symbol :end in a \"ref\" expression (i.e. A[...]) `ex`\nwith the appropriate function calls (`lastindex` or `size`). Replacement uses\nthe closest enclosing ref, so\n\n    A[B[end]]\n\nshould transform to\n\n    A[B[lastindex(B)]]\n\n"}],"Base.detach":[{"Tuple{Cmd}":"    detach(command)\n\nMark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.\n"}],"Base.Rational":[{"Union{}":"    Rational{T<:Integer} <: Real\n\nRational number type, with numerator and denominator of type `T`.\nRationals are checked for overflow.\n"}],"Base.isbitstype":[{"Tuple{Type}":"    isbitstype(T)\n\nReturn `true` if type `T` is a \"plain data\" type,\nmeaning it is immutable and contains no references to other values,\nonly `primitive` types and other `isbitstype` types.\nTypical examples are numeric types such as [`UInt8`](@ref),\n[`Float64`](@ref), and [`Complex{Float64}`](@ref).\nThis category of types is significant since they are valid as type parameters,\nmay not track [`isdefined`](@ref) / [`isassigned`](@ref) status,\nand have a defined layout that is compatible with C.\n\n# Examples\n```jldoctest\njulia> isbitstype(Complex{Float64})\ntrue\n\njulia> isbitstype(Complex)\nfalse\n```\n"}],"Base.AbstractLock":[{"Union{}":"    AbstractLock\n\nAbstract supertype describing types that\nimplement the synchronization primitives:\n[`lock`](@ref), [`trylock`](@ref), [`unlock`](@ref), and [`islocked`](@ref).\n"}],"Base.eachindex":[{"Tuple{AbstractArray}":"    eachindex(A...)\n\nCreate an iterable object for visiting each index of an `AbstractArray` `A` in an efficient\nmanner. For array types that have opted into fast linear indexing (like `Array`), this is\nsimply the range `1:length(A)`. For other array types, return a specialized Cartesian\nrange to efficiently index into the array with indices specified for every dimension. For\nother iterables, including strings and dictionaries, return an iterator object\nsupporting arbitrary index types (e.g. unevenly spaced or non-integer indices).\n\nIf you supply more than one `AbstractArray` argument, `eachindex` will create an\niterable object that is fast for all arguments (a [`UnitRange`](@ref)\nif all inputs have fast linear indexing, a [`CartesianIndices`](@ref)\notherwise).\nIf the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception\nwill be thrown.\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4];\n\njulia> for i in eachindex(A) # linear indexing\n           println(i)\n       end\n1\n2\n3\n4\n\njulia> for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing\n           println(i)\n       end\nCartesianIndex(1, 1)\nCartesianIndex(2, 1)\n```\n"}],"Base.@noinline":[{"Tuple{Any}":"    @noinline\n\nGive a hint to the compiler that it should not inline a function.\n\nSmall functions are typically inlined automatically.\nBy using `@noinline` on small functions, auto-inlining can be\nprevented. This is shown in the following example:\n\n```julia\n@noinline function smallfunction(x)\n    #=\n        Function Definition\n    =#\nend\n\nIf the function is trivial (for example returning a constant) it might get inlined anyway.\n```\n"}],"Base.nameof":[{"Tuple{Module}":"    nameof(m::Module) -> Symbol\n\nGet the name of a `Module` as a [`Symbol`](@ref).\n\n# Examples\n```jldoctest\njulia> nameof(Base.Broadcast)\n:Broadcast\n```\n"},{"Tuple{Function}":"    nameof(f::Function) -> Symbol\n\nGet the name of a generic `Function` as a symbol. For anonymous functions,\nthis is a compiler-generated name. For explicitly-declared subtypes of\n`Function`, it is the name of the function's type.\n"},{"Tuple{DataType}":"    nameof(t::DataType) -> Symbol\n\nGet the name of a (potentially `UnionAll`-wrapped) `DataType` (without its parent module)\nas a symbol.\n\n# Examples\n```jldoctest\njulia> module Foo\n           struct S{T}\n           end\n       end\nFoo\n\njulia> nameof(Foo.S{T} where T)\n:S\n```\n"}],"Base.@macroexpand1":[{"Tuple{Any}":"    @macroexpand1\n\nNon recursive version of [`@macroexpand`](@ref).\n"}],"Base.isodd":[{"Tuple{Integer}":"    isodd(x::Integer) -> Bool\n\nReturn `true` if `x` is odd (that is, not divisible by 2), and `false` otherwise.\n\n# Examples\n```jldoctest\njulia> isodd(9)\ntrue\n\njulia> isodd(10)\nfalse\n```\n"}],"Base.^":[{"Tuple{Number,Number}":"    ^(x, y)\n\nExponentiation operator. If `x` is a matrix, computes matrix exponentiation.\n\nIf `y` is an `Int` literal (e.g. `2` in `x^2` or `-3` in `x^-3`), the Julia code\n`x^y` is transformed by the compiler to `Base.literal_pow(^, x, Val(y))`, to\nenable compile-time specialization on the value of the exponent.\n(As a default fallback we have `Base.literal_pow(^, x, Val(y)) = ^(x,y)`,\nwhere usually `^ == Base.^` unless `^` has been defined in the calling\nnamespace.)\n\n```jldoctest\njulia> 3^5\n243\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> A^3\n2×2 Array{Int64,2}:\n 37   54\n 81  118\n```\n"},{"Tuple{Regex,Integer}":"    ^(s::Regex, n::Integer)\n\nRepeat a regex `n` times.\n\n!!! compat \"Julia 1.3\"\n     This method requires at least Julia 1.3.\n\n# Examples\n```jldoctest\njulia> r\"Test \"^2\nr\"(?:Test ){2}\"\n\njulia> match(r\"Test \"^2, \"Test Test \")\nRegexMatch(\"Test Test \")\n```\n"},{"Tuple{Union{AbstractChar, AbstractString},Integer}":"    ^(s::Union{AbstractString,AbstractChar}, n::Integer)\n\nRepeat a string or character `n` times. This can also be written as `repeat(s, n)`.\n\nSee also: [`repeat`](@ref)\n\n# Examples\n```jldoctest\njulia> \"Test \"^3\n\"Test Test Test \"\n```\n"}],"Base.:":[{"Union{Tuple{T}, Tuple{T,Any,T}} where T":"    (:)(start, [step], stop)\n\nRange operator. `a:b` constructs a range from `a` to `b` with a step size of 1 (a [`UnitRange`](@ref))\n, and `a:s:b` is similar but uses a step size of `s` (a [`StepRange`](@ref)).\n\n`:` is also used in indexing to select whole dimensions\n and for [`Symbol`](@ref) literals, as in e.g. `:hello`.\n"}],"Base.abs":[{"Union{}":"    abs(x)\n\nThe absolute value of `x`.\n\nWhen `abs` is applied to signed integers, overflow may occur,\nresulting in the return of a negative value. This overflow occurs only\nwhen `abs` is applied to the minimum representable value of a signed\ninteger. That is, when `x == typemin(typeof(x))`, `abs(x) == x < 0`,\nnot `-x` as might be expected.\n\n# Examples\n```jldoctest\njulia> abs(-3)\n3\n\njulia> abs(1 + im)\n1.4142135623730951\n\njulia> abs(typemin(Int64))\n-9223372036854775808\n```\n"}],"Base.unsafe_read":[{"Tuple{IO,Ptr{UInt8},UInt64}":"    unsafe_read(io::IO, ref, nbytes::UInt)\n\nCopy `nbytes` from the `IO` stream object into `ref` (converted to a pointer).\n\nIt is recommended that subtypes `T<:IO` override the following method signature\nto provide more efficient implementations:\n`unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)`\n"}],"Base.unsafe_load":[{"Union{Tuple{Ptr}, Tuple{Ptr,Integer}}":"    unsafe_load(p::Ptr{T}, i::Integer=1)\n\nLoad a value of type `T` from the address of the `i`th element (1-indexed) starting at `p`.\nThis is equivalent to the C expression `p[i-1]`.\n\nThe `unsafe` prefix on this function indicates that no validation is performed on the\npointer `p` to ensure that it is valid. Incorrect usage may segfault your program or return\ngarbage answers, in the same manner as C.\n"}],"Base.⊆":[{"Union{}":"    issubset(a, b) -> Bool\n    ⊆(a, b) -> Bool\n    ⊇(b, a) -> Bool\n\nDetermine whether every element of `a` is also in `b`, using [`in`](@ref).\n\n# Examples\n```jldoctest\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> [1, 2, 3] ⊆ [1, 2]\nfalse\n\njulia> [1, 2, 3] ⊇ [1, 2]\ntrue\n```\n"}],"Base.fieldcount":[{"Tuple{Any}":"    fieldcount(t::Type)\n\nGet the number of fields that an instance of the given type would have.\nAn error is thrown if the type is too abstract to determine this.\n"}],"Base.pathof":[{"Tuple{Module}":"    pathof(m::Module)\n\nReturn the path of the `m.jl` file that was used to `import` module `m`,\nor `nothing` if `m` was not imported from a package.\n\nUse [`dirname`](@ref) to get the directory part and [`basename`](@ref)\nto get the file name part of the path.\n"}],"Base.issetequal":[{"Tuple{AbstractSet,AbstractSet}":"    issetequal(a, b) -> Bool\n\nDetermine whether `a` and `b` have the same elements. Equivalent\nto `a ⊆ b && b ⊆ a` but more efficient when possible.\n\n# Examples\n```jldoctest\njulia> issetequal([1, 2], [1, 2, 3])\nfalse\n\njulia> issetequal([1, 2], [2, 1])\ntrue\n```\n"}],"Base.fieldtypes":[{"Tuple{Type}":"    fieldtypes(T::Type)\n\nThe declared types of all fields in a composite DataType `T` as a tuple.\n\n!!! compat \"Julia 1.1\"\n    This function requires at least Julia 1.1.\n\n# Examples\n```jldoctest\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldtypes(Foo)\n(Int64, String)\n```\n"}],"Base.PROGRAM_FILE":[{"Union{}":"    PROGRAM_FILE\n\nA string containing the script name passed to Julia from the command line. Note that the\nscript name remains unchanged from within included files. Alternatively see\n[`@__FILE__`](@ref).\n"}],"Base.findnext":[{"Tuple{Function,Any,Any}":"    findnext(predicate::Function, A, i)\n\nFind the next index after or including `i` of an element of `A`\nfor which `predicate` returns `true`, or `nothing` if not found.\n\nIndices are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [1, 4, 2, 2];\n\njulia> findnext(isodd, A, 1)\n1\n\njulia> findnext(isodd, A, 2) # returns nothing, but not printed in the REPL\n\njulia> A = [1 4; 2 2];\n\njulia> findnext(isodd, A, CartesianIndex(1, 1))\nCartesianIndex(1, 1)\n```\n"},{"Tuple{Any,Any}":"    findnext(A, i)\n\nFind the next index after or including `i` of a `true` element of `A`,\nor `nothing` if not found.\n\nIndices are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [false, false, true, false]\n4-element Array{Bool,1}:\n 0\n 0\n 1\n 0\n\njulia> findnext(A, 1)\n3\n\njulia> findnext(A, 4) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true false]\n2×2 Array{Bool,2}:\n 0  0\n 1  0\n\njulia> findnext(A, CartesianIndex(1, 1))\nCartesianIndex(2, 1)\n```\n"},{"Tuple{AbstractString,AbstractString,Integer}":"    findnext(pattern::AbstractString, string::AbstractString, start::Integer)\n    findnext(pattern::Regex, string::String, start::Integer)\n\nFind the next occurrence of `pattern` in `string` starting at position `start`.\n`pattern` can be either a string, or a regular expression, in which case `string`\nmust be of type `String`.\n\nThe return value is a range of indices where the matching sequence is found, such that\n`s[findnext(x, s, i)] == x`:\n\n`findnext(\"substring\", string, i)` == `start:stop` such that\n`string[start:stop] == \"substring\"` and `i <= start`, or `nothing` if unmatched.\n\n# Examples\n```jldoctest\njulia> findnext(\"z\", \"Hello to the world\", 1) === nothing\ntrue\n\njulia> findnext(\"o\", \"Hello to the world\", 6)\n8:8\n\njulia> findnext(\"Lang\", \"JuliaLang\", 2)\n6:9\n```\n"},{"Tuple{AbstractChar,AbstractString,Integer}":"    findnext(ch::AbstractChar, string::AbstractString, start::Integer)\n\nFind the next occurrence of character `ch` in `string` starting at position `start`.\n\n!!! compat \"Julia 1.3\"\n    This method requires at least Julia 1.3.\n\n# Examples\n```jldoctest\njulia> findnext('z', \"Hello to the world\", 1) === nothing\ntrue\n\njulia> findnext('o', \"Hello to the world\", 6)\n8\n```\n"}],"Base.LOAD_PATH":[{"Union{}":"    LOAD_PATH\n\nAn array of paths for `using` and `import` statements to consider as project\nenvironments or package directories when loading code. It is populated based on\nthe [`JULIA_LOAD_PATH`](@ref JULIA_LOAD_PATH) environment variable if set;\notherwise it defaults to `[\"@\", \"@v#.#\", \"@stdlib\"]`. Entries starting with `@`\nhave special meanings:\n\n- `@` refers to the \"current active environment\", the initial value of which is\n  initially determined by the [`JULIA_PROJECT`](@ref JULIA_PROJECT) environment\n  variable or the `--project` command-line option.\n\n- `@stdlib` expands to the absolute path of the current Julia installation's\n  standard library directory.\n\n- `@name` refers to a named environment, which are stored in depots (see\n  [`JULIA_DEPOT_PATH`](@ref JULIA_DEPOT_PATH)) under the `environments`\n  subdirectory. The user's named environments are stored in\n  `~/.julia/environments` so `@name` would refer to the environment in\n  `~/.julia/environments/name` if it exists and contains a `Project.toml` file.\n  If `name` contains `#` characters, then they are replaced with the major, minor\n  and patch components of the Julia version number. For example, if you are\n  running Julia 1.2 then `@v#.#` expands to `@v1.2` and will look for an\n  environment by that name, typically at `~/.julia/environments/v1.2`.\n\nThe fully expanded value of `LOAD_PATH` that is searched for projects and packages\ncan be seen by calling the `Base.load_path()` function.\n\nSee also:\n[`JULIA_LOAD_PATH`](@ref JULIA_LOAD_PATH),\n[`JULIA_PROJECT`](@ref JULIA_PROJECT),\n[`JULIA_DEPOT_PATH`](@ref JULIA_DEPOT_PATH), and\n[Code Loading](@ref Code-Loading).\n"}],"Base.size":[{"Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Any}} where N where T":"    size(A::AbstractArray, [dim])\n\nReturn a tuple containing the dimensions of `A`. Optionally you can specify a\ndimension to just get the length of that dimension.\n\nNote that `size` may not be defined for arrays with non-standard indices, in which case [`axes`](@ref)\nmay be useful. See the manual chapter on [arrays with custom indices](@ref man-custom-indices).\n\n# Examples\n```jldoctest\njulia> A = fill(1, (2,3,4));\n\njulia> size(A)\n(2, 3, 4)\n\njulia> size(A, 2)\n3\n```\n"}],"Base._xfadjoint":[{"Tuple{Any,Any}":"    _xfadjoint(op, itr) -> op′, itr′\n\nGiven a pair of reducing function `op` and an iterator `itr`, return a pair\n`(op′, itr′)` of similar types.  If the iterator `itr` is transformed by an\niterator transform `ixf` whose adjoint transducer `xf` is known, `op′ = xf(op)`\nand `itr′ = ixf⁻¹(itr)` is returned.  Otherwise, `op` and `itr` are returned\nas-is.  For example, transducer `rf -> MappingRF(f, rf)` is the adjoint of\niterator transform `itr -> Generator(f, itr)`.\n\nNested iterator transforms are converted recursively.  That is to say,\ngiven `op` and\n\n    itr = (ixf₁ ∘ ixf₂ ∘ ... ∘ ixfₙ)(itr′)\n\nwhat is returned is `itr′` and\n\n    op′ = (xfₙ ∘ ... ∘ xf₂ ∘ xf₁)(op)\n"}],"Base.@gensym":[{"Tuple":"    @gensym\n\nGenerates a gensym symbol for a variable. For example, `@gensym x y` is transformed into\n`x = gensym(\"x\"); y = gensym(\"y\")`.\n"}],"Base.get!":[{"Tuple{Function,Any,Any}":"    get!(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store\n`key => f()`, and return `f()`.\n\nThis is intended to be called using `do` block syntax:\n```julia\nget!(dict, key) do\n    # default value calculated here\n    time()\nend\n```\n"},{"Tuple{Any,Any,Any}":"    get!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store\n`key => default`, and return `default`.\n\n# Examples\n```jldoctest\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> get!(d, \"a\", 5)\n1\n\njulia> get!(d, \"d\", 4)\n4\n\njulia> d\nDict{String,Int64} with 4 entries:\n  \"c\" => 3\n  \"b\" => 2\n  \"a\" => 1\n  \"d\" => 4\n```\n"}],"Base.retry":[{"Tuple{Any}":"    retry(f;  delays=ExponentialBackOff(), check=nothing) -> Function\n\nReturn an anonymous function that calls function `f`.  If an exception arises,\n`f` is repeatedly called again, each time `check` returns `true`, after waiting the\nnumber of seconds specified in `delays`.  `check` should input `delays`'s\ncurrent state and the `Exception`.\n\n!!! compat \"Julia 1.2\"\n    Before Julia 1.2 this signature was restricted to `f::Function`.\n\n# Examples\n```julia\nretry(f, delays=fill(5.0, 3))\nretry(f, delays=rand(5:10, 2))\nretry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))\nretry(http_get, check=(s,e)->e.status == \"503\")(url)\nretry(read, check=(s,e)->isa(e, IOError))(io, 128; all=false)\n```\n"}],"Base.timedwait":[{"Tuple{Function,Float64}":"    timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)\n\nWaits until `testcb` returns `true` or for `secs` seconds, whichever is earlier.\n`testcb` is polled every `pollint` seconds.\n\nReturns :ok, :timed_out, or :error\n"}],"Base.foldl":[{"Tuple{Any,Any}":"    foldl(op, itr; [init])\n\nLike [`reduce`](@ref), but with guaranteed left associativity. If provided, the keyword\nargument `init` will be used exactly once. In general, it will be necessary to provide\n`init` to work with empty collections.\n\n# Examples\n```jldoctest\njulia> foldl(=>, 1:4)\n((1 => 2) => 3) => 4\n\njulia> foldl(=>, 1:4; init=0)\n(((0 => 1) => 2) => 3) => 4\n```\n"}],"Base.isbitsunion":[{"Tuple{Union}":"    Base.isbitsunion(::Type{T})\n\nReturn whether a type is an \"is-bits\" Union type, meaning each type included in a Union is [`isbitstype`](@ref).\n\n# Examples\n```jldoctest\njulia> Base.isbitsunion(Union{Float64, UInt8})\ntrue\n\njulia> Base.isbitsunion(Union{Float64, String})\nfalse\n```\n"}],"Base.mark":[{"Tuple{IO}":"    mark(s)\n\nAdd a mark at the current position of stream `s`. Return the marked position.\n\nSee also [`unmark`](@ref), [`reset`](@ref), [`ismarked`](@ref).\n"}],"Base.isperm":[{"Tuple{Any}":"    isperm(v) -> Bool\n\nReturn `true` if `v` is a valid permutation.\n\n# Examples\n```jldoctest\njulia> isperm([1; 2])\ntrue\n\njulia> isperm([1; 3])\nfalse\n```\n"}],"Base.findmax!":[{"Tuple{AbstractArray,AbstractArray,AbstractArray}":"    findmax!(rval, rind, A) -> (maxval, index)\n\nFind the maximum of `A` and the corresponding linear index along singleton\ndimensions of `rval` and `rind`, and store the results in `rval` and `rind`.\n`NaN` is treated as greater than all other values.\n"}],"Base.Regex":[{"Union{}":"    Regex(pattern[, flags])\n\nA type representing a regular expression. `Regex` objects can be used to match strings\nwith [`match`](@ref).\n\n`Regex` objects can be created using the [`@r_str`](@ref) string macro. The\n`Regex(pattern[, flags])` constructor is usually used if the `pattern` string needs\nto be interpolated. See the documentation of the string macro for details on flags.\n"}],"Base.__precompile__":[{"Union{Tuple{}, Tuple{Bool}}":"    __precompile__(isprecompilable::Bool)\n\nSpecify whether the file calling this function is precompilable, defaulting to `true`.\nIf a module or file is *not* safely precompilable, it should call `__precompile__(false)` in\norder to throw an error if Julia attempts to precompile it.\n"}],"Base.dump":[{"Tuple{Any}":"    dump(x; maxdepth=8)\n\nShow every part of the representation of a value.\nThe depth of the output is truncated at `maxdepth`.\n\n# Examples\n```jldoctest\njulia> struct MyStruct\n           x\n           y\n       end\n\njulia> x = MyStruct(1, (2,3));\n\njulia> dump(x)\nMyStruct\n  x: Int64 1\n  y: Tuple{Int64,Int64}\n    1: Int64 2\n    2: Int64 3\n\njulia> dump(x; maxdepth = 1)\nMyStruct\n  x: Int64 1\n  y: Tuple{Int64,Int64}\n```\n"}],"Base.getpass":[{"Union{}":"    Base.getpass(message::AbstractString) -> Base.SecretBuffer\n\nDisplay a message and wait for the user to input a secret, returning an `IO`\nobject containing the secret.\n\nNote that on Windows, the secret might be displayed as it is typed; see\n`Base.winprompt` for securely retrieving username/password pairs from a\ngraphical interface.\n"}],"Base.setindex!":[{"Union{}":"    setindex!(collection, value, key...)\n\nStore the given value at the given key or index within a collection. The syntax `a[i,j,...] =\nx` is converted by the compiler to `(setindex!(a, x, i, j, ...); x)`.\n"},{"Tuple{AbstractArray,Any,Vararg{Any,N} where N}":"    setindex!(A, X, inds...)\n    A[inds...] = X\n\nStore values from array `X` within some subset of `A` as specified by `inds`.\nThe syntax `A[inds...] = X` is equivalent to `setindex!(A, X, inds...)`.\n\n# Examples\n```jldoctest\njulia> A = zeros(2,2);\n\njulia> setindex!(A, [10, 20], [1, 2]);\n\njulia> A[[3, 4]] = [30, 40];\n\njulia> A\n2×2 Array{Float64,2}:\n 10.0  30.0\n 20.0  40.0\n```\n"}],"Base.release":[{"Tuple{Base.Semaphore}":"    release(s::Semaphore)\n\nReturn one permit to the pool,\npossibly allowing another task to acquire it\nand resume execution.\n"}],"Base.iseven":[{"Tuple{Integer}":"    iseven(x::Integer) -> Bool\n\nReturn `true` is `x` is even (that is, divisible by 2), and `false` otherwise.\n\n# Examples\n```jldoctest\njulia> iseven(9)\nfalse\n\njulia> iseven(10)\ntrue\n```\n"}],"Base.sizehint!":[{"Union{}":"    sizehint!(s, n)\n\nSuggest that collection `s` reserve capacity for at least `n` elements. This can improve performance.\n"}],"Base.IOContext":[{"Tuple{IO,Pair,Vararg{Pair,N} where N}":"    IOContext(io::IO, KV::Pair...)\n\nCreate an `IOContext` that wraps a given stream, adding the specified `key=>value` pairs to\nthe properties of that stream (note that `io` can itself be an `IOContext`).\n\n - use `(key => value) in io` to see if this particular combination is in the properties set\n - use `get(io, key, default)` to retrieve the most recent value for a particular key\n\nThe following properties are in common use:\n\n - `:compact`: Boolean specifying that small values should be printed more compactly, e.g.\n   that numbers should be printed with fewer digits. This is set when printing array\n   elements.\n - `:limit`: Boolean specifying that containers should be truncated, e.g. showing `…` in\n   place of most elements.\n - `:displaysize`: A `Tuple{Int,Int}` giving the size in rows and columns to use for text\n   output. This can be used to override the display size for called functions, but to\n   get the size of the screen use the `displaysize` function.\n - `:typeinfo`: a `Type` characterizing the information already printed\n   concerning the type of the object about to be displayed. This is mainly useful when\n   displaying a collection of objects of the same type, so that redundant type information\n   can be avoided (e.g. `[Float16(0)]` can be shown as \"Float16[0.0]\" instead\n   of \"Float16[Float16(0.0)]\" : while displaying the elements of the array, the `:typeinfo`\n   property will be set to `Float16`).\n - `:color`: Boolean specifying whether ANSI color/escape codes are supported/expected.\n   By default, this is determined by whether `io` is a compatible terminal and by any\n   `--color` command-line flag when `julia` was launched.\n\n# Examples\n\n```jldoctest\njulia> io = IOBuffer();\n\njulia> printstyled(IOContext(io, :color => true), \"string\", color=:red)\n\njulia> String(take!(io))\n\"\\e[31mstring\\e[39m\"\n\njulia> printstyled(io, \"string\", color=:red)\n\njulia> String(take!(io))\n\"string\"\n```\n\n```jldoctest\njulia> print(IOContext(stdout, :compact => false), 1.12341234)\n1.12341234\njulia> print(IOContext(stdout, :compact => true), 1.12341234)\n1.12341\n```\n\n```jldoctest\njulia> function f(io::IO)\n           if get(io, :short, false)\n               print(io, \"short\")\n           else\n               print(io, \"loooooong\")\n           end\n       end\nf (generic function with 1 method)\n\njulia> f(stdout)\nloooooong\njulia> f(IOContext(stdout, :short => true))\nshort\n```\n"},{"Union{}":"    IOContext\n\n`IOContext` provides a mechanism for passing output configuration settings among [`show`](@ref) methods.\n\nIn short, it is an immutable dictionary that is a subclass of `IO`. It supports standard\ndictionary operations such as [`getindex`](@ref), and can also be used as an I/O stream.\n"},{"Tuple{IO,IO}":"    IOContext(io::IO, context::IOContext)\n\nCreate an `IOContext` that wraps an alternate `IO` but inherits the properties of `context`.\n"}],"Base.>:":[{"Union{}":"    >:(T1, T2)\n\nSupertype operator, equivalent to `T2 <: T1`.\n"}],"Base.>":[{"Tuple{Any}":"    >(x)\n\nCreate a function that compares its argument to `x` using [`>`](@ref), i.e.\na function equivalent to `y -> y > x`.\nThe returned function is of type `Base.Fix2{typeof(>)}`, which can be\nused to implement specialized methods.\n\n!!! compat \"Julia 1.2\"\n    This functionality requires at least Julia 1.2.\n"},{"Tuple{Any,Any}":"    >(x, y)\n\nGreater-than comparison operator. Falls back to `y < x`.\n\n# Implementation\nGenerally, new types should implement [`<`](@ref) instead of this function,\nand rely on the fallback definition `>(x, y) = y < x`.\n\n# Examples\n```jldoctest\njulia> 'a' > 'b'\nfalse\n\njulia> 7 > 3 > 1\ntrue\n\njulia> \"abc\" > \"abd\"\nfalse\n\njulia> 5 > 3\ntrue\n```\n"}],"Base.RangeStepStyle":[{"Union{}":"    RangeStepStyle(instance)\n    RangeStepStyle(T::Type)\n\nIndicate whether an instance or a type supports constructing a range with\na perfectly regular step or not. A regular step means that\n[`step`](@ref) will always be exactly equal to the difference between two\nsubsequent elements in a range, i.e. for a range `r::AbstractRange{T}`:\n```julia\nall(diff(r) .== step(r))\n```\n\nWhen a type `T` always leads to ranges with regular steps, it should\ndefine the following method:\n```julia\nBase.RangeStepStyle(::Type{<:AbstractRange{<:T}}) = Base.RangeStepRegular()\n```\nThis will allow [`hash`](@ref) to use an O(1) algorithm for `AbstractRange{T}`\nobjects instead of the default O(N) algorithm (with N the length of the range).\n\nIn some cases, whether the step will be regular depends not only on the\nelement type `T`, but also on the type of the step `S`. In that case, more\nspecific methods should be defined:\n```julia\nBase.RangeStepStyle(::Type{<:OrdinalRange{<:T, <:S}}) = Base.RangeStepRegular()\n```\n\nBy default, all range types are assumed to be `RangeStepIrregular`, except\nranges with an element type which is a subtype of `Integer`.\n"}],"Base.argmax":[{"Tuple{Any}":"    argmax(itr) -> Integer\n\nReturn the index of the maximum element in a collection. If there are multiple maximal\nelements, then the first one will be returned.\n\nThe collection must not be empty.\n\n# Examples\n```jldoctest\njulia> argmax([8,0.1,-9,pi])\n1\n\njulia> argmax([1,7,7,6])\n2\n\njulia> argmax([1,7,7,NaN])\n4\n```\n"},{"Tuple{AbstractArray}":"    argmax(A; dims) -> indices\n\nFor an array input, return the indices of the maximum elements over the given dimensions.\n`NaN` is treated as greater than all other values.\n\n# Examples\n```jldoctest\njulia> A = [1.0 2; 3 4]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> argmax(A, dims=1)\n1×2 Array{CartesianIndex{2},2}:\n CartesianIndex(2, 1)  CartesianIndex(2, 2)\n\njulia> argmax(A, dims=2)\n2×1 Array{CartesianIndex{2},2}:\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n```\n"}],"Base.put!":[{"Union{Tuple{T}, Tuple{Channel{T},Any}} where T":"    put!(c::Channel, v)\n\nAppend an item `v` to the channel `c`. Blocks if the channel is full.\n\nFor unbuffered channels, blocks until a [`take!`](@ref) is performed by a different\ntask.\n\n!!! compat \"Julia 1.1\"\n    `v` now gets converted to the channel's type with [`convert`](@ref) as `put!` is called.\n"}],"Base.println":[{"Tuple{IO,Vararg{Any,N} where N}":"    println([io::IO], xs...)\n\nPrint (using [`print`](@ref)) `xs` followed by a newline.\nIf `io` is not supplied, prints to [`stdout`](@ref).\n\n# Examples\n```jldoctest\njulia> println(\"Hello, world\")\nHello, world\n\njulia> io = IOBuffer();\n\njulia> println(io, \"Hello, world\")\n\njulia> String(take!(io))\n\"Hello, world\\n\"\n```\n"}],"Base.unsafe_trunc":[{"Union{}":"    unsafe_trunc(T, x)\n\nReturn the nearest integral value of type `T` whose absolute value is\nless than or equal to `x`. If the value is not representable by `T`, an arbitrary value will\nbe returned.\n"}],"Base.empty!":[{"Union{Tuple{Dict{K,V}}, Tuple{V}, Tuple{K}} where V where K":"    empty!(collection) -> collection\n\nRemove all elements from a `collection`.\n\n# Examples\n```jldoctest\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String,Int64} with 0 entries\n```\n"}],"Base.which":[{"Tuple{Any,Any}":"    which(f, types)\n\nReturns the method of `f` (a `Method` object) that would be called for arguments of the given `types`.\n\nIf `types` is an abstract type, then the method that would be called by `invoke` is returned.\n"},{"Tuple{Module,Symbol}":"    which(module, symbol)\n\nReturn the module in which the binding for the variable referenced by `symbol` in `module` was created.\n"}],"Base.isimmutable":[{"Tuple{Any}":"    isimmutable(v) -> Bool\n\nReturn `true` iff value `v` is immutable.  See [Mutable Composite Types](@ref)\nfor a discussion of immutability. Note that this function works on values, so if you give it\na type, it will tell you that a value of `DataType` is mutable.\n\n# Examples\n```jldoctest\njulia> isimmutable(1)\ntrue\n\njulia> isimmutable([1,2])\nfalse\n```\n"}],"Base.ImmutableDict":[{"Union{}":"    ImmutableDict\n\nImmutableDict is a Dictionary implemented as an immutable linked list,\nwhich is optimal for small dictionaries that are constructed over many individual insertions\nNote that it is not possible to remove a value, although it can be partially overridden and hidden\nby inserting a new value with the same key\n\n    ImmutableDict(KV::Pair)\n\nCreate a new entry in the Immutable Dictionary for the key => value pair\n\n - use `(key => value) in dict` to see if this particular combination is in the properties set\n - use `get(dict, key, default)` to retrieve the most recent value for a particular key\n\n"}],"Base.@task":[{"Tuple{Any}":"    @task\n\nWrap an expression in a [`Task`](@ref) without executing it, and return the [`Task`](@ref). This only\ncreates a task, and does not run it.\n\n# Examples\n```jldoctest\njulia> a1() = sum(i for i in 1:1000);\n\njulia> b = @task a1();\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n```\n"}],"Base.max":[{"Tuple{Any,Any}":"    max(x, y, ...)\n\nReturn the maximum of the arguments. See also the [`maximum`](@ref) function\nto take the maximum element from a collection.\n\n# Examples\n```jldoctest\njulia> max(2, 5, 1)\n5\n```\n"}],"Base.MissingException":[{"Union{}":"    MissingException(msg)\n\nException thrown when a [`missing`](@ref) value is encountered in a situation\nwhere it is not supported. The error message, in the `msg` field\nmay provide more specific details.\n"}],"Base.prod!":[{"Tuple{Any,Any}":"    prod!(r, A)\n\nMultiply elements of `A` over the singleton dimensions of `r`, and write results to `r`.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> prod!([1; 1], A)\n2-element Array{Int64,1}:\n  2\n 12\n\njulia> prod!([1 1], A)\n1×2 Array{Int64,2}:\n 3  8\n```\n"}],"Base.AbstractRange":[{"Union{}":"    AbstractRange{T}\n\nSupertype for ranges with elements of type `T`.\n[`UnitRange`](@ref) and other types are subtypes of this.\n"}],"Base.findmin!":[{"Tuple{AbstractArray,AbstractArray,AbstractArray}":"    findmin!(rval, rind, A) -> (minval, index)\n\nFind the minimum of `A` and the corresponding linear index along singleton\ndimensions of `rval` and `rind`, and store the results in `rval` and `rind`.\n`NaN` is treated as less than all other values.\n"}],"Base.@allocated":[{"Tuple{Any}":"    @allocated\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the\ntotal number of bytes allocated during evaluation of the expression.\n\nSee also [`@time`](@ref), [`@timev`](@ref), [`@timed`](@ref),\nand [`@elapsed`](@ref).\n\n```julia-repl\njulia> @allocated rand(10^6)\n8000080\n```\n"}],"Base.unmark":[{"Tuple{IO}":"    unmark(s)\n\nRemove a mark from stream `s`. Return `true` if the stream was marked, `false` otherwise.\n\nSee also [`mark`](@ref), [`reset`](@ref), [`ismarked`](@ref).\n"}],"Base.EnvDict":[{"Union{}":"    EnvDict() -> EnvDict\n\nA singleton of this type provides a hash table interface to environment variables.\n"}],"Base.oftype":[{"Tuple{Any,Any}":"    oftype(x, y)\n\nConvert `y` to the type of `x` (`convert(typeof(x), y)`).\n\n# Examples\n```jldoctest\njulia> x = 4;\n\njulia> y = 3.;\n\njulia> oftype(x, y)\n3\n\njulia> oftype(y, x)\n4.0\n```\n"}],"Base.Set":[{"Tuple{Any}":"    Set([itr])\n\nConstruct a [`Set`](@ref) of the values generated by the given iterable object, or an\nempty set. Should be used instead of [`BitSet`](@ref) for sparse integer sets, or\nfor sets of arbitrary objects.\n"}],"Base.similar":[{"Union{Tuple{T}, Tuple{Type{T},Vararg{Union{Integer, AbstractUnitRange},N} where N}} where T<:AbstractArray":"    similar(storagetype, axes)\n\nCreate an uninitialized mutable array analogous to that specified by\n`storagetype`, but with `axes` specified by the last\nargument. `storagetype` might be a type or a function.\n\n**Examples**:\n\n    similar(Array{Int}, axes(A))\n\ncreates an array that \"acts like\" an `Array{Int}` (and might indeed be\nbacked by one), but which is indexed identically to `A`. If `A` has\nconventional indexing, this will be identical to\n`Array{Int}(undef, size(A))`, but if `A` has unconventional indexing then the\nindices of the result will match `A`.\n\n    similar(BitArray, (axes(A, 2),))\n\nwould create a 1-dimensional logical array whose indices match those\nof the columns of `A`.\n"},{"Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T":"    similar(array, [element_type=eltype(array)], [dims=size(array)])\n\nCreate an uninitialized mutable array with the given element type and size, based upon the\ngiven source array. The second and third arguments are both optional, defaulting to the\ngiven array's `eltype` and `size`. The dimensions may be specified either as a single tuple\nargument or as a series of integer arguments.\n\nCustom AbstractArray subtypes may choose which specific array type is best-suited to return\nfor the given element type and dimensionality. If they do not specialize this method, the\ndefault is an `Array{element_type}(undef, dims...)`.\n\nFor example, `similar(1:10, 1, 4)` returns an uninitialized `Array{Int,2}` since ranges are\nneither mutable nor support 2 dimensions:\n\n```julia-repl\njulia> similar(1:10, 1, 4)\n1×4 Array{Int64,2}:\n 4419743872  4374413872  4419743888  0\n```\n\nConversely, `similar(trues(10,10), 2)` returns an uninitialized `BitVector` with two\nelements since `BitArray`s are both mutable and can support 1-dimensional arrays:\n\n```julia-repl\njulia> similar(trues(10,10), 2)\n2-element BitArray{1}:\n 0\n 0\n```\n\nSince `BitArray`s can only store elements of type [`Bool`](@ref), however, if you request a\ndifferent element type it will create a regular `Array` instead:\n\n```julia-repl\njulia> similar(falses(10), Float64, 2, 4)\n2×4 Array{Float64,2}:\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n```\n\n"}],"Base.isassigned":[{"Union{}":"    isassigned(array, i) -> Bool\n\nTest whether the given array has a value associated with index `i`. Return `false`\nif the index is out of bounds, or has an undefined reference.\n\n# Examples\n```jldoctest\njulia> isassigned(rand(3, 3), 5)\ntrue\n\njulia> isassigned(rand(3, 3), 3 * 3 + 1)\nfalse\n\njulia> mutable struct Foo end\n\njulia> v = similar(rand(3), Foo)\n3-element Array{Foo,1}:\n #undef\n #undef\n #undef\n\njulia> isassigned(v, 1)\nfalse\n```\n"}],"Base.insert!":[{"Union{Tuple{T}, Tuple{Array{T,1},Integer,Any}} where T":"    insert!(a::Vector, index::Integer, item)\n\nInsert an `item` into `a` at the given `index`. `index` is the index of `item` in\nthe resulting `a`.\n\n# Examples\n```jldoctest\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n```\n"}],"Base.isunaryoperator":[{"Tuple{Symbol}":"    isunaryoperator(s::Symbol)\n\nReturn `true` if the symbol can be used as a unary (prefix) operator, `false` otherwise.\n\n# Examples\n```jldoctest\njulia> Base.isunaryoperator(:-), Base.isunaryoperator(:√), Base.isunaryoperator(:f)\n(true, true, false)\n```\n"}],"Base.promote_op":[{"Tuple{Any,Vararg{Type,N} where N}":"    promote_op(f, argtypes...)\n\nGuess what an appropriate container eltype would be for storing results of\n`f(::argtypes...)`. The guess is in part based on type inference, so can change any time.\n\n!!! warning\n    Due to its fragility, use of `promote_op` should be avoided. It is preferable to base\n    the container eltype on the type of the actual elements. Only in the absence of any\n    elements (for an empty result container), it may be unavoidable to call `promote_op`.\n"}],"Base.julia_cmd":[{"Union{Tuple{}, Tuple{Any}}":"    Base.julia_cmd(juliapath=joinpath(Sys.BINDIR::String, julia_exename()))\n\nReturn a julia command similar to the one of the running process.\nPropagates any of the `--cpu-target`, `--sysimage`, `--compile`, `--sysimage-native-code`,\n`--compiled-modules`, `--inline`, `--check-bounds`, `--optimize`, `-g`,\n`--code-coverage`, and `--depwarn`\ncommand line arguments that are not at their default values.\n\nAmong others, `--math-mode`, `--warn-overwrite`, and `--trace-compile` are notably not propagated currently.\n\n!!! compat \"Julia 1.1\"\n    Only the `--cpu-target`, `--sysimage`, `--depwarn`, `--compile` and `--check-bounds` flags were propagated before Julia 1.1.\n"}],"Base.@sync":[{"Tuple{Any}":"    @sync\n\nWait until all lexically-enclosed uses of `@async`, `@spawn`, `@spawnat` and `@distributed`\nare complete. All exceptions thrown by enclosed async operations are collected and thrown as\na `CompositeException`.\n"}],"Base.CodeUnits":[{"Union{}":"    CodeUnits(s::AbstractString)\n\nWrap a string (without copying) in an immutable vector-like object that accesses the code units\nof the string's representation.\n"}],"Base.unsafe_string":[{"Tuple{Union{Ptr{Int8}, Ptr{UInt8}},Integer}":"    unsafe_string(p::Ptr{UInt8}, [length::Integer])\n\nCopy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8.\n(The pointer can be safely freed afterwards.) If `length` is specified\n(the length of the data in bytes), the string does not have to be NUL-terminated.\n\nThis function is labeled \"unsafe\" because it will crash if `p` is not\na valid memory address to data of the requested length.\n"}],"Base.reenable_sigint":[{"Tuple{Function}":"    reenable_sigint(f::Function)\n\nRe-enable Ctrl-C handler during execution of a function.\nTemporarily reverses the effect of [`disable_sigint`](@ref).\n"}],"Base.range":[{"Tuple{Any}":"    range(start[, stop]; length, stop, step=1)\n\nGiven a starting value, construct a range either by length or from `start` to `stop`,\noptionally with a given step (defaults to 1, a [`UnitRange`](@ref)).\nOne of `length` or `stop` is required.  If `length`, `stop`, and `step` are all specified, they must agree.\n\nIf `length` and `stop` are provided and `step` is not, the step size will be computed\nautomatically such that there are `length` linearly spaced elements in the range (a [`LinRange`](@ref)).\n\nIf `step` and `stop` are provided and `length` is not, the overall range length will be computed\nautomatically such that the elements are `step` spaced (a [`StepRange`](@ref)).\n\n`stop` may be specified as either a positional or keyword argument.\n\n!!! compat \"Julia 1.1\"\n    `stop` as a positional argument requires at least Julia 1.1.\n\n# Examples\n```jldoctest\njulia> range(1, length=100)\n1:100\n\njulia> range(1, stop=100)\n1:100\n\njulia> range(1, step=5, length=100)\n1:5:496\n\njulia> range(1, step=5, stop=100)\n1:5:96\n\njulia> range(1, 10, length=101)\n1.0:0.09:10.0\n\njulia> range(1, 100, step=5)\n1:5:96\n```\n"}],"Base.mapslices":[{"Tuple{Any,AbstractArray}":"    mapslices(f, A; dims)\n\nTransform the given dimensions of array `A` using function `f`. `f` is called on each slice\nof `A` of the form `A[...,:,...,:,...]`. `dims` is an integer vector specifying where the\ncolons go in this expression. The results are concatenated along the remaining dimensions.\nFor example, if `dims` is `[1,2]` and `A` is 4-dimensional, `f` is called on `A[:,:,i,j]`\nfor all `i` and `j`.\n\n# Examples\n```jldoctest\njulia> a = reshape(Vector(1:16),(2,2,2,2))\n2×2×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> mapslices(sum, a, dims = [1,2])\n1×1×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 10\n\n[:, :, 2, 1] =\n 26\n\n[:, :, 1, 2] =\n 42\n\n[:, :, 2, 2] =\n 58\n```\n"}],"Base.ncodeunits":[{"Tuple{Char}":"    ncodeunits(c::Char) -> Int\n\nReturn the number of code units required to encode a character as UTF-8.\nThis is the number of bytes which will be printed if the character is written\nto an output stream, or `ncodeunits(string(c))` but computed efficiently.\n\n!!! compat \"Julia 1.1\"\n    This method requires at least Julia 1.1. In Julia 1.0 consider\n    using `ncodeunits(string(c))`.\n"},{"Tuple{AbstractString}":"    ncodeunits(s::AbstractString) -> Int\n\nReturn the number of code units in a string. Indices that are in bounds to\naccess this string must satisfy `1 ≤ i ≤ ncodeunits(s)`. Not all such indices\nare valid – they may not be the start of a character, but they will return a\ncode unit value when calling `codeunit(s,i)`.\n\nSee also: [`codeunit`](@ref), [`checkbounds`](@ref), [`sizeof`](@ref),\n[`length`](@ref), [`lastindex`](@ref)\n"}],"Base.parentindices":[{"Tuple{AbstractArray}":"    parentindices(A)\n\nReturn the indices in the [`parent`](@ref) which correspond to the array view `A`.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4];\n\njulia> V = view(A, 1, :)\n2-element view(::Array{Int64,2}, 1, :) with eltype Int64:\n 1\n 2\n\njulia> parentindices(V)\n(1, Base.Slice(Base.OneTo(2)))\n```\n"}],"Base.istaskdone":[{"Tuple{Task}":"    istaskdone(t::Task) -> Bool\n\nDetermine whether a task has exited.\n\n# Examples\n```jldoctest\njulia> a2() = sum(i for i in 1:1000);\n\njulia> b = Task(a2);\n\njulia> istaskdone(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n```\n"}],"Base.@generated":[{"Tuple{Any}":"    @generated f\n    @generated(f)\n`@generated` is used to annotate a function which will be generated.\nIn the body of the generated function, only types of arguments can be read\n(not the values). The function returns a quoted expression evaluated when the\nfunction is called. The `@generated` macro should not be used on functions mutating\nthe global scope or depending on mutable elements.\n\nSee [Metaprogramming](@ref) for further details.\n\n## Example:\n```julia\njulia> @generated function bar(x)\n           if x <: Integer\n               return :(x ^ 2)\n           else\n               return :(x)\n           end\n       end\nbar (generic function with 1 method)\n\njulia> bar(4)\n16\n\njulia> bar(\"baz\")\n\"baz\"\n```\n"}],"Base.Culonglong":[{"Union{}":"    Culonglong\n\nEquivalent to the native `unsigned long long` c-type ([`UInt64`](@ref)).\n"}],"Base.rotr90":[{"Tuple{AbstractArray{T,2} where T,Integer}":"    rotr90(A, k)\n\nRight-rotate matrix `A` 90 degrees clockwise an integer `k` number of times.\nIf `k` is a multiple of four (including zero), this is equivalent to a `copy`.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotr90(a,1)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n\njulia> rotr90(a,2)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rotr90(a,3)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n\njulia> rotr90(a,4)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n"},{"Tuple{AbstractArray{T,2} where T}":"    rotr90(A)\n\nRotate matrix `A` right 90 degrees.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotr90(a)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n```\n"}],"Base.print_matrix_row":[{"Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Array{T,1} where T,Integer,AbstractArray{T,1} where T,AbstractString}":"`print_matrix_row(io, X, A, i, cols, sep)` produces the aligned output for\na single matrix row X[i, cols] where the desired list of columns is given.\nThe corresponding alignment A is used, and the separation between elements\nis specified as string sep.\n`print_matrix_row` will also respect compact output for elements.\n"}],"Base.haskey":[{"Tuple{Dict,Any}":"    haskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given `key`.\n\n# Examples\n```jldoctest\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n```\n"}],"Base.codepoint":[{"Union{}":"    codepoint(c::AbstractChar) -> Integer\n\nReturn the Unicode codepoint (an unsigned integer) corresponding\nto the character `c` (or throw an exception if `c` does not represent\na valid character). For `Char`, this is a `UInt32` value, but\n`AbstractChar` types that represent only a subset of Unicode may\nreturn a different-sized integer (e.g. `UInt8`).\n"}],"Base.print_matrix":[{"Union{Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}, Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractString}, Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractString,AbstractString}, Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractString,AbstractString,AbstractString}, Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractString,AbstractString,AbstractString,AbstractString}, Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractString,AbstractString,AbstractString,AbstractString,AbstractString}, Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractString,AbstractString,AbstractString,AbstractString,AbstractString,AbstractString}, Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractString,AbstractString,AbstractString,AbstractString,AbstractString,AbstractString,Integer}, Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractString,AbstractString,AbstractString,AbstractString,AbstractString,AbstractString,Integer,Integer}}":"    print_matrix(io::IO, mat, pre, sep, post, hdots, vdots, ddots, hmod, vmod)\n\nPrints a matrix with limited output size. If `io` sets `:limit` to true,\nthen only the corners of the matrix are printed, separated with vertical,\nhorizontal, and diagonal ellipses as appropriate.\nOptional arguments are string pre (printed before the matrix, e.g. an opening bracket)\nwhich will cause a corresponding same-size indent on following rows, and\nstring post (printed at the end of the last row of the matrix).\nAlso options to use different ellipsis characters hdots, vdots, ddots.\nThese are repeated every hmod or vmod elements.\n"}],"Base.shell_escape_posixly":[{"Tuple{Vararg{AbstractString,N} where N}":"    shell_escape_posixly(args::Union{Cmd,AbstractString...})\n\nThe unexported `shell_escape_posixly` function\ntakes a string or command object and escapes any special characters in such a way that\nit is safe to pass it as an argument to a posix shell.\n\n# Examples\n```jldoctest\njulia> Base.shell_escape_posixly(\"cat\", \"/foo/bar baz\", \"&&\", \"echo\", \"done\")\n\"cat '/foo/bar baz' '&&' echo done\"\n\njulia> Base.shell_escape_posixly(\"echo\", \"this\", \"&&\", \"that\")\n\"echo this '&&' that\"\n```\n"}],"Base.⊊":[{"Union{}":"    ⊊(a, b) -> Bool\n    ⊋(b, a) -> Bool\n\nDetermines if `a` is a subset of, but not equal to, `b`.\n\n# Examples\n```jldoctest\njulia> (1, 2) ⊊ (1, 2, 3)\ntrue\n\njulia> (1, 2) ⊊ (1, 2)\nfalse\n```\n"}],"Base.intersect!":[{"Tuple{AbstractSet,Vararg{Any,N} where N}":"    intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nIntersect all passed in sets and overwrite `s` with the result.\nMaintain order with arrays.\n"}],"Base.imag":[{"Tuple{Complex}":"    imag(z)\n\nReturn the imaginary part of the complex number `z`.\n\n# Examples\n```jldoctest\njulia> imag(1 + 3im)\n3\n```\n"}],"Base.isconcretetype":[{"Tuple{Any}":"    isconcretetype(T)\n\nDetermine whether type `T` is a concrete type, meaning it could have direct instances\n(values `x` such that `typeof(x) === T`).\n\n# Examples\n```jldoctest\njulia> isconcretetype(Complex)\nfalse\n\njulia> isconcretetype(Complex{Float32})\ntrue\n\njulia> isconcretetype(Vector{Complex})\ntrue\n\njulia> isconcretetype(Vector{Complex{Float32}})\ntrue\n\njulia> isconcretetype(Union{})\nfalse\n\njulia> isconcretetype(Union{Int,String})\nfalse\n```\n"}],"Base.checkbounds":[{"Tuple{Type{Bool},AbstractArray,Vararg{Any,N} where N}":"    checkbounds(Bool, A, I...)\n\nReturn `true` if the specified indices `I` are in bounds for the given\narray `A`. Subtypes of `AbstractArray` should specialize this method\nif they need to provide custom bounds checking behaviors; however, in\nmany cases one can rely on `A`'s indices and [`checkindex`](@ref).\n\nSee also [`checkindex`](@ref).\n\n# Examples\n```jldoctest\njulia> A = rand(3, 3);\n\njulia> checkbounds(Bool, A, 2)\ntrue\n\njulia> checkbounds(Bool, A, 3, 4)\nfalse\n\njulia> checkbounds(Bool, A, 1:3)\ntrue\n\njulia> checkbounds(Bool, A, 1:3, 2:4)\nfalse\n```\n"},{"Tuple{AbstractArray,Vararg{Any,N} where N}":"    checkbounds(A, I...)\n\nThrow an error if the specified indices `I` are not in bounds for the given array `A`.\n"}],"Base.∋":[{"Union{}":"    in(item, collection) -> Bool\n    ∈(item, collection) -> Bool\n    ∋(collection, item) -> Bool\n\nDetermine whether an item is in the given collection, in the sense that it is\n[`==`](@ref) to one of the values generated by iterating over the collection.\nReturns a `Bool` value, except if `item` is [`missing`](@ref) or `collection`\ncontains `missing` but not `item`, in which case `missing` is returned\n([three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic),\nmatching the behavior of [`any`](@ref) and [`==`](@ref)).\n\nSome collections follow a slightly different definition. For example,\n[`Set`](@ref)s check whether the item [`isequal`](@ref) to one of the elements.\n[`Dict`](@ref)s look for `key=>value` pairs, and the key is compared using\n[`isequal`](@ref). To test for the presence of a key in a dictionary,\nuse [`haskey`](@ref) or `k in keys(dict)`. For these collections, the result\nis always a `Bool` and never `missing`.\n\n# Examples\n```jldoctest\njulia> a = 1:3:20\n1:3:19\n\njulia> 4 in a\ntrue\n\njulia> 5 in a\nfalse\n\njulia> missing in [1, 2]\nmissing\n\njulia> 1 in [2, missing]\nmissing\n\njulia> 1 in [1, missing]\ntrue\n\njulia> missing in Set([1, 2])\nfalse\n```\n"}],"Base.BottomRF":[{"Union{}":"    BottomRF(rf) -> rf′\n\n\"Bottom\" reducing function.  This is a thin wrapper around the `op` argument\npassed to `foldl`-like functions for handling the initial invocation to call\n[`reduce_first`](@ref).\n"}],"Base.DenseVector":[{"Union{}":"    DenseVector{T}\n\nOne-dimensional [`DenseArray`](@ref) with elements of type `T`. Alias for `DenseArray{T,1}`.\n"}],"Base.binomial":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Integer":"    binomial(n::Integer, k::Integer)\n\nThe _binomial coefficient_ ``\\binom{n}{k}``, being the coefficient of the ``k``th term in\nthe polynomial expansion of ``(1+x)^n``.\n\nIf ``n`` is non-negative, then it is the number of ways to choose `k` out of `n` items:\n```math\n\\binom{n}{k} = \\frac{n!}{k! (n-k)!}\n```\nwhere ``n!`` is the [`factorial`](@ref) function.\n\nIf ``n`` is negative, then it is defined in terms of the identity\n```math\n\\binom{n}{k} = (-1)^k \\binom{k-n-1}{k}\n```\n\n# Examples\n```jldoctest\njulia> binomial(5, 3)\n10\n\njulia> factorial(5) ÷ (factorial(5-3) * factorial(3))\n10\n\njulia> binomial(-5, 3)\n-35\n```\n\n# See also\n* [`factorial`](@ref)\n\n# External links\n* [Binomial coeffient](https://en.wikipedia.org/wiki/Binomial_coefficient) on Wikipedia.\n"}],"Base.redirect_stderr":[{"Union{}":"    redirect_stderr([stream]) -> (rd, wr)\n\nLike [`redirect_stdout`](@ref), but for [`stderr`](@ref).\n\n!!! note\n    `stream` must be a `TTY`, a `Pipe`, or a socket.\n"},{"Tuple{Function,Any}":"    redirect_stderr(f::Function, stream)\n\nRun the function `f` while redirecting [`stderr`](@ref) to `stream`.\nUpon completion, [`stderr`](@ref) is restored to its prior setting.\n\n!!! note\n    `stream` must be a `TTY`, a `Pipe`, or a socket.\n"}],"Base.Complex":[{"Union{}":"    Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type `T`.\n\n`ComplexF16`, `ComplexF32` and `ComplexF64` are aliases for\n`Complex{Float16}`, `Complex{Float32}` and `Complex{Float64}` respectively.\n"}],"Base.stderr":[{"Union{}":"    stderr\n\nGlobal variable referring to the standard error stream.\n"}],"Base.count_ones":[{"Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}":"    count_ones(x::Integer) -> Integer\n\nNumber of ones in the binary representation of `x`.\n\n# Examples\n```jldoctest\njulia> count_ones(7)\n3\n```\n"}],"Base.parentmodule":[{"Tuple{Any,Any}":"    parentmodule(f::Function, types) -> Module\n\nDetermine the module containing a given definition of a generic function.\n"},{"Tuple{Module}":"    parentmodule(m::Module) -> Module\n\nGet a module's enclosing `Module`. `Main` is its own parent.\n\n# Examples\n```jldoctest\njulia> parentmodule(Main)\nMain\n\njulia> parentmodule(Base.Broadcast)\nBase\n```\n"},{"Tuple{Function}":"    parentmodule(f::Function) -> Module\n\nDetermine the module containing the (first) definition of a generic\nfunction.\n"},{"Tuple{DataType}":"    parentmodule(t::DataType) -> Module\n\nDetermine the module containing the definition of a (potentially `UnionAll`-wrapped) `DataType`.\n\n# Examples\n```jldoctest\njulia> module Foo\n           struct Int end\n       end\nFoo\n\njulia> parentmodule(Int)\nCore\n\njulia> parentmodule(Foo.Int)\nFoo\n```\n"}],"Base.isopen":[{"Union{}":"    isopen(object) -> Bool\n\nDetermine whether an object - such as a stream or timer\n-- is not yet closed. Once an object is closed, it will never produce a new event.\nHowever, since a closed stream may still have data to read in its buffer,\nuse [`eof`](@ref) to check for the ability to read data.\nUse the `FileWatching` package to be notified when a stream might be writable or readable.\n\n# Examples\n```jldoctest\njulia> io = open(\"my_file.txt\", \"w+\");\n\njulia> isopen(io)\ntrue\n\njulia> close(io)\n\njulia> isopen(io)\nfalse\n```\n"}],"Base.lastindex":[{"Tuple{AbstractArray}":"    lastindex(collection) -> Integer\n    lastindex(collection, d) -> Integer\n\nReturn the last index of `collection`. If `d` is given, return the last index of `collection` along dimension `d`.\n\nThe syntaxes `A[end]` and `A[end, end]` lower to `A[lastindex(A)]` and\n`A[lastindex(A, 1), lastindex(A, 2)]`, respectively.\n\n# Examples\n```jldoctest\njulia> lastindex([1,2,4])\n3\n\njulia> lastindex(rand(3,4,5), 2)\n4\n```\n"}],"Base.delete_method":[{"Tuple{Method}":"    delete_method(m::Method)\n\nMake method `m` uncallable and force recompilation of any methods that use(d) it.\n"}],"Base.fetch":[{"Tuple{Task}":"    fetch(t::Task)\n\nWait for a Task to finish, then return its result value.\nIf the task fails with an exception, a `TaskFailedException` (which wraps the failed task)\nis thrown.\n"},{"Tuple{Channel}":"    fetch(c::Channel)\n\nWait for and get the first available item from the channel. Does not\nremove the item. `fetch` is unsupported on an unbuffered (0-size) channel.\n"}],"Base.@show":[{"Tuple":"    @show\n\nShow an expression and result, returning the result. See also [`show`](@ref).\n"}],"Base.unique":[{"Tuple{Any}":"    unique(itr)\n\nReturn an array containing only the unique elements of collection `itr`,\nas determined by [`isequal`](@ref), in the order that the first of each\nset of equivalent elements originally appears. The element type of the\ninput is preserved.\n\n# Examples\n```jldoctest\njulia> unique([1, 2, 6, 2])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\njulia> unique(Real[1, 1.0, 2])\n2-element Array{Real,1}:\n 1\n 2\n```\n"},{"Tuple{AbstractArray}":"    unique(A::AbstractArray; dims::Int)\n\nReturn unique regions of `A` along dimension `dims`.\n\n# Examples\n```jldoctest\njulia> A = map(isodd, reshape(Vector(1:8), (2,2,2)))\n2×2×2 Array{Bool,3}:\n[:, :, 1] =\n 1  1\n 0  0\n\n[:, :, 2] =\n 1  1\n 0  0\n\njulia> unique(A)\n2-element Array{Bool,1}:\n 1\n 0\n\njulia> unique(A, dims=2)\n2×1×2 Array{Bool,3}:\n[:, :, 1] =\n 1\n 0\n\n[:, :, 2] =\n 1\n 0\n\njulia> unique(A, dims=3)\n2×2×1 Array{Bool,3}:\n[:, :, 1] =\n 1  1\n 0  0\n```\n"},{"Tuple{Any,Any}":"    unique(f, itr)\n\nReturns an array containing one value from `itr` for each unique value produced by `f`\napplied to elements of `itr`.\n\n# Examples\n```jldoctest\njulia> unique(x -> x^2, [1, -1, 3, -3, 4])\n3-element Array{Int64,1}:\n 1\n 3\n 4\n```\n"}],"Base.div":[{"Union{}":"    div(x, y)\n    ÷(x, y)\n\nThe quotient from Euclidean division. Computes `x/y`, truncated to an integer.\n\n# Examples\n```jldoctest\njulia> 9 ÷ 4\n2\n\njulia> -5 ÷ 3\n-1\n\njulia> 5.0 ÷ 2\n2.0\n```\n"},{"Tuple{Any,Any,RoundingMode}":"    div(x, y, r::RoundingMode=RoundToZero)\n\nThe quotient from Euclidean division. Computes x/y, rounded to an integer according\nto the rounding mode `r`. In other words, the quantity\n\n    round(x/y,r)\n\nwithout any intermediate rounding.\n\nSee also: [`fld`](@ref), [`cld`](@ref) which are special cases of this function\n\n# Examples:\n```jldoctest\njulia> div(4, 3, RoundDown) # Matches fld(4, 3)\n1\njulia> div(4, 3, RoundUp) # Matches cld(4, 3)\n2\njulia> div(5, 2, RoundNearest)\n2\njulia> div(5, 2, RoundNearestTiesAway)\n3\njulia> div(-5, 2, RoundNearest)\n-2\njulia> div(-5, 2, RoundNearestTiesAway)\n-3\njulia> div(-5, 2, RoundNearestTiesUp)\n-2\n```\n"}],"Base.⊈":[{"Union{}":"    ⊈(a, b) -> Bool\n    ⊉(b, a) -> Bool\n\nNegation of `⊆` and `⊇`, i.e. checks that `a` is not a subset of `b`.\n\n# Examples\n```jldoctest\njulia> (1, 2) ⊈ (2, 3)\ntrue\n\njulia> (1, 2) ⊈ (1, 2, 3)\nfalse\n```\n"}],"Base.displaysize":[{"Tuple{IO}":"    displaysize([io::IO]) -> (lines, columns)\n\nReturn the nominal size of the screen that may be used for rendering output to\nthis `IO` object.\nIf no input is provided, the environment variables `LINES` and `COLUMNS` are read.\nIf those are not set, a default size of `(24, 80)` is returned.\n\n# Examples\n```jldoctest\njulia> withenv(\"LINES\" => 30, \"COLUMNS\" => 100) do\n           displaysize()\n       end\n(30, 100)\n```\n\nTo get your TTY size,\n\n```julia\njulia> displaysize(stdout)\n(34, 147)\n```\n"}],"Base.hex2bytes!":[{"Tuple{AbstractArray{UInt8,1},Union{AbstractArray{UInt8,1}, String}}":"    hex2bytes!(d::AbstractVector{UInt8}, s::Union{String,AbstractVector{UInt8}})\n\nConvert an array `s` of bytes representing a hexadecimal string to its binary\nrepresentation, similar to [`hex2bytes`](@ref) except that the output is written in-place\nin `d`.   The length of `s` must be exactly twice the length of `d`.\n"}],"Base.bytes2hex":[{"Union{}":"    bytes2hex(a::AbstractArray{UInt8}) -> String\n    bytes2hex(io::IO, a::AbstractArray{UInt8})\n\nConvert an array `a` of bytes to its hexadecimal string representation, either\nreturning a `String` via `bytes2hex(a)` or writing the string to an `io` stream\nvia `bytes2hex(io, a)`.  The hexadecimal characters are all lowercase.\n\n# Examples\n```jldoctest\njulia> a = string(12345, base = 16)\n\"3039\"\n\njulia> b = hex2bytes(a)\n2-element Array{UInt8,1}:\n 0x30\n 0x39\n\njulia> bytes2hex(b)\n\"3039\"\n```\n"}],"Base.instances":[{"Union{}":"    instances(T::Type)\n\nReturn a collection of all instances of the given type, if applicable. Mostly used for\nenumerated types (see `@enum`).\n\n# Example\n```jldoctest\njulia> @enum Color red blue green\n\njulia> instances(Color)\n(red, blue, green)\n```\n"}],"Base.reim":[{"Tuple{Any}":"    reim(z)\n\nReturn both the real and imaginary parts of the complex number `z`.\n\n# Examples\n```jldoctest\njulia> reim(1 + 3im)\n(1, 3)\n```\n"}],"Base.BitVector":[{"Tuple{Tuple{Vararg{Bool,N} where N}}":"    BitVector(nt::Tuple{Vararg{Bool}})\n\nConstruct a `BitVector` from a tuple of `Bool`.\n# Examples\n```julia-repl\njulia> nt = (true, false, true, false)\n(true, false, true, false)\n\njulia> BitVector(nt)\n4-element BitArray{1}:\n 1\n 0\n 1\n 0\n```\n"}],"Base.pairs":[{"Tuple{Any}":"    pairs(collection)\n\nReturn an iterator over `key => value` pairs for any\ncollection that maps a set of keys to a set of values.\nThis includes arrays, where the keys are the array indices.\n"}],"Base.isabstracttype":[{"Tuple{Any}":"    isabstracttype(T)\n\nDetermine whether type `T` was declared as an abstract type\n(i.e. using the `abstract` keyword).\n\n# Examples\n```jldoctest\njulia> isabstracttype(AbstractArray)\ntrue\n\njulia> isabstracttype(Vector)\nfalse\n```\n"}],"Base.Cwstring":[{"Union{}":"    Cwstring\n\nA C-style string composed of the native wide character type\n[`Cwchar_t`](@ref)s. `Cwstring`s are NUL-terminated. For\nC-style strings composed of the native character\ntype, see [`Cstring`](@ref). For more information\nabout string interopability with C, see the\n[manual](@ref man-bits-types).\n\n"}],"Base.rstrip":[{"Tuple{Any,AbstractString}":"    rstrip([pred=isspace,] str::AbstractString) -> SubString\n    rstrip(str::AbstractString, chars) -> SubString\n\nRemove trailing characters from `str`, either those specified by `chars` or those for\nwhich the function `pred` returns `true`.\n\nThe default behaviour is to remove trailing whitespace and delimiters: see\n[`isspace`](@ref) for precise details.\n\nThe optional `chars` argument specifies which characters to remove: it can be a single\ncharacter, or a vector or set of characters.\n\n# Examples\n```jldoctest\njulia> a = rpad(\"March\", 20)\n\"March               \"\n\njulia> rstrip(a)\n\"March\"\n```\n"}],"Base.splice!":[{"Union{Tuple{Array{T,1} where T,UnitRange{#s662} where #s662<:Integer}, Tuple{Array{T,1} where T,UnitRange{#s661} where #s661<:Integer,Any}}":"    splice!(a::Vector, range, [replacement]) -> items\n\nRemove items in the specified index range, and return a collection containing\nthe removed items.\nSubsequent items are shifted left to fill the resulting gap.\nIf specified, replacement values from an ordered collection will be spliced in\nplace of the removed items.\n\nTo insert `replacement` before an index `n` without removing any items, use\n`splice!(collection, n:n-1, replacement)`.\n\n# Examples\n```jldoctest\njulia> A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A, 4:3, 2)\n0-element Array{Int64,1}\n\njulia> A\n8-element Array{Int64,1}:\n -1\n -2\n -3\n  2\n  5\n  4\n  3\n -1\n```\n"},{"Union{Tuple{Array{T,1} where T,Integer}, Tuple{Array{T,1} where T,Integer,Any}}":"    splice!(a::Vector, index::Integer, [replacement]) -> item\n\nRemove the item at the given index, and return the removed item.\nSubsequent items are shifted left to fill the resulting gap.\nIf specified, replacement values from an ordered\ncollection will be spliced in place of the removed item.\n\n# Examples\n```jldoctest\njulia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)\n2\n\njulia> A\n5-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 1\n\njulia> splice!(A, 5, -1)\n1\n\njulia> A\n5-element Array{Int64,1}:\n  6\n  5\n  4\n  3\n -1\n\njulia> splice!(A, 1, [-1, -2, -3])\n6\n\njulia> A\n7-element Array{Int64,1}:\n -1\n -2\n -3\n  5\n  4\n  3\n -1\n```\n\nTo insert `replacement` before an index `n` without removing any items, use\n`splice!(collection, n:n-1, replacement)`.\n"}],"Base.C_NULL":[{"Union{}":"    C_NULL\n\nThe C null pointer constant, sometimes used when calling external code.\n"}],"Base.rot180":[{"Tuple{AbstractArray{T,2} where T,Integer}":"    rot180(A, k)\n\nRotate matrix `A` 180 degrees an integer `k` number of times.\nIf `k` is even, this is equivalent to a `copy`.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rot180(a,1)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rot180(a,2)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n"},{"Tuple{AbstractArray{T,2} where T}":"    rot180(A)\n\nRotate matrix `A` 180 degrees.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rot180(a)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n```\n"}],"Base.ndigits0z":[{"Tuple{Integer,Integer}":"    ndigits0z(n::Integer, b::Integer=10)\n\nReturn 0 if `n == 0`, otherwise compute the number of digits in\ninteger `n` written in base `b` (i.e. equal to `ndigits(n, base=b)`\nin this case).\nThe base `b` must not be in `[-1, 0, 1]`.\n\n# Examples\n```jldoctest\njulia> Base.ndigits0z(0, 16)\n0\n\njulia> Base.ndigits(0, base=16)\n1\n\njulia> Base.ndigits0z(0)\n0\n\njulia> Base.ndigits0z(10, 2)\n4\n\njulia> Base.ndigits0z(10)\n2\n```\n\nSee also [`ndigits`](@ref).\n"}],"Base.rotl90":[{"Tuple{AbstractArray{T,2} where T,Integer}":"    rotl90(A, k)\n\nLeft-rotate matrix `A` 90 degrees counterclockwise an integer `k` number of times.\nIf `k` is a multiple of four (including zero), this is equivalent to a `copy`.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotl90(a,1)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n\njulia> rotl90(a,2)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rotl90(a,3)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n\njulia> rotl90(a,4)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n"},{"Tuple{AbstractArray{T,2} where T}":"    rotl90(A)\n\nRotate matrix `A` left 90 degrees.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotl90(a)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n```\n"}],"Base.repr":[{"Tuple{Any}":"    repr(x; context=nothing)\n\nCreate a string from any value using the [`show`](@ref) function.\nYou should not add methods to `repr`; define a `show` method instead.\n\nThe optional keyword argument `context` can be set to an `IO` or [`IOContext`](@ref)\nobject whose attributes are used for the I/O stream passed to `show`.\n\nNote that `repr(x)` is usually similar to how the value of `x` would\nbe entered in Julia.  See also [`repr(MIME(\"text/plain\"), x)`](@ref) to instead\nreturn a \"pretty-printed\" version of `x` designed more for human consumption,\nequivalent to the REPL display of `x`.\n\n# Examples\n```jldoctest\njulia> repr(1)\n\"1\"\n\njulia> repr(zeros(3))\n\"[0.0, 0.0, 0.0]\"\n\njulia> repr(big(1/3))\n\"0.333333333333333314829616256247390992939472198486328125\"\n\njulia> repr(big(1/3), context=:compact => true)\n\"0.333333\"\n\n```\n"}],"Base.datatype_pointerfree":[{"Tuple{DataType}":"    Base.datatype_pointerfree(dt::DataType) -> Bool\n\nReturn whether instances of this type can contain references to gc-managed memory.\nCan be called on any `isconcretetype`.\n"}],"Base.Cwchar_t":[{"Union{}":"    Cwchar_t\n\nEquivalent to the native `wchar_t` c-type ([`Int32`](@ref)).\n"}],"Base.digits":[{"Tuple{Integer}":"    digits([T<:Integer], n::Integer; base::T = 10, pad::Integer = 1)\n\nReturn an array with element type `T` (default `Int`) of the digits of `n` in the given\nbase, optionally padded with zeros to a specified size. More significant digits are at\nhigher indices, such that `n == sum([digits[k]*base^(k-1) for k=1:length(digits)])`.\n\n# Examples\n```jldoctest\njulia> digits(10, base = 10)\n2-element Array{Int64,1}:\n 0\n 1\n\njulia> digits(10, base = 2)\n4-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n\njulia> digits(10, base = 2, pad = 6)\n6-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n 0\n 0\n```\n"}],"Base.bytesavailable":[{"Tuple{Base.AbstractPipe}":"    bytesavailable(io)\n\nReturn the number of bytes available for reading before a read from this stream or buffer will block.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> bytesavailable(io)\n34\n```\n"}],"Base.cumsum!":[{"Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Any}} where T":"    cumsum!(B, A; dims::Integer)\n\nCumulative sum of `A` along the dimension `dims`, storing the result in `B`. See also [`cumsum`](@ref).\n"}],"Base.copy":[{"Union{}":"    copy(x)\n\nCreate a shallow copy of `x`: the outer structure is copied, but not all internal values.\nFor example, copying an array produces a new array with identically-same elements as the\noriginal.\n"}],"Base.copysign":[{"Tuple{Real,Real}":"    copysign(x, y) -> z\n\nReturn `z` which has the magnitude of `x` and the same sign as `y`.\n\n# Examples\n```jldoctest\njulia> copysign(1, -2)\n-1\n\njulia> copysign(-1, 2)\n1\n```\n"}],"Base.merge!":[{"Tuple{AbstractDict,Vararg{AbstractDict,N} where N}":"    merge!(d::AbstractDict, others::AbstractDict...)\n\nUpdate collection with pairs from the other collections.\nSee also [`merge`](@ref).\n\n# Examples\n```jldoctest\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(d1, d2);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 4\n```\n"},{"Tuple{Function,AbstractDict,Vararg{AbstractDict,N} where N}":"    merge!(combine, d::AbstractDict, others::AbstractDict...)\n\nUpdate collection with pairs from the other collections.\nValues with the same key will be combined using the\ncombiner function.\n\n# Examples\n```jldoctest\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(+, d1, d2);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 6\n\njulia> merge!(-, d1, d1);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 0\n  3 => 0\n  1 => 0\n```\n"}],"Base.widen":[{"Union{Tuple{T}, Tuple{T}} where T":"    widen(x)\n\nIf `x` is a type, return a \"larger\" type, defined so that arithmetic operations\n`+` and `-` are guaranteed not to overflow nor lose precision for any combination\nof values that type `x` can hold.\n\nFor fixed-size integer types less than 128 bits, `widen` will return a type with\ntwice the number of bits.\n\nIf `x` is a value, it is converted to `widen(typeof(x))`.\n\n# Examples\n```jldoctest\njulia> widen(Int32)\nInt64\n\njulia> widen(1.5f0)\n1.5\n```\n"}],"Base.all":[{"Tuple{Any}":"    all(itr) -> Bool\n\nTest whether all elements of a boolean collection are `true`, returning `false` as\nsoon as the first `false` value in `itr` is encountered (short-circuiting).\n\nIf the input contains [`missing`](@ref) values, return `missing` if all non-missing\nvalues are `true` (or equivalently, if the input contains no `false` value), following\n[three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic).\n\n# Examples\n```jldoctest\njulia> a = [true,false,false,true]\n4-element Array{Bool,1}:\n 1\n 0\n 0\n 1\n\njulia> all(a)\nfalse\n\njulia> all((println(i); v) for (i, v) in enumerate(a))\n1\n2\nfalse\n\njulia> all([missing, false])\nfalse\n\njulia> all([true, missing])\nmissing\n```\n"},{"Tuple{AbstractArray}":"    all(A; dims)\n\nTest whether all values along the given dimensions of an array are `true`.\n\n# Examples\n```jldoctest\njulia> A = [true false; true true]\n2×2 Array{Bool,2}:\n 1  0\n 1  1\n\njulia> all(A, dims=1)\n1×2 Array{Bool,2}:\n 1  0\n\njulia> all(A, dims=2)\n2×1 Array{Bool,2}:\n 0\n 1\n```\n"},{"Tuple{Any,Any}":"    all(p, itr) -> Bool\n\nDetermine whether predicate `p` returns `true` for all elements of `itr`, returning\n`false` as soon as the first item in `itr` for which `p` returns `false` is encountered\n(short-circuiting).\n\nIf the input contains [`missing`](@ref) values, return `missing` if all non-missing\nvalues are `true` (or equivalently, if the input contains no `false` value), following\n[three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic).\n\n# Examples\n```jldoctest\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n\njulia> all(i -> (println(i); i < 3), 1:10)\n1\n2\n3\nfalse\n\njulia> all(i -> i > 0, [1, missing])\nmissing\n\njulia> all(i -> i > 0, [-1, missing])\nfalse\n\njulia> all(i -> i > 0, [1, 2])\ntrue\n```\n"}],"Base.rationalize":[{"Union{Tuple{T}, Tuple{Type{T},AbstractFloat,Real}} where T<:Integer":"    rationalize([T<:Integer=Int,] x; tol::Real=eps(x))\n\nApproximate floating point number `x` as a [`Rational`](@ref) number with components\nof the given integer type. The result will differ from `x` by no more than `tol`.\n\n# Examples\n```jldoctest\njulia> rationalize(5.6)\n28//5\n\njulia> a = rationalize(BigInt, 10.3)\n103//10\n\njulia> typeof(numerator(a))\nBigInt\n```\n"}],"Base.ascii":[{"Tuple{AbstractString}":"    ascii(s::AbstractString)\n\nConvert a string to `String` type and check that it contains only ASCII data, otherwise\nthrowing an `ArgumentError` indicating the position of the first non-ASCII byte.\n\n# Examples\n```jldoctest\njulia> ascii(\"abcdeγfgh\")\nERROR: ArgumentError: invalid ASCII at index 6 in \"abcdeγfgh\"\nStacktrace:\n[...]\n\njulia> ascii(\"abcdefgh\")\n\"abcdefgh\"\n```\n"}],"Base.ispow2":[{"Tuple{Integer}":"    ispow2(n::Integer) -> Bool\n\nTest whether `n` is a power of two.\n\n# Examples\n```jldoctest\njulia> ispow2(4)\ntrue\n\njulia> ispow2(5)\nfalse\n```\n"}],"Base.|":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}":"    |(x, y)\n\nBitwise or. Implements [three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic),\nreturning [`missing`](@ref) if one operand is `missing` and the other is `false`.\n\n# Examples\n```jldoctest\njulia> 4 | 10\n14\n\njulia> 4 | 1\n5\n\njulia> true | missing\ntrue\n\njulia> false | missing\nmissing\n```\n"}],"Base.isbits":[{"Tuple{Any}":"    isbits(x)\n\nReturn `true` if `x` is an instance of an `isbitstype` type.\n"}],"Base.union!":[{"Tuple{AbstractSet,Vararg{Any,N} where N}":"    union!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nConstruct the union of passed in sets and overwrite `s` with the result.\nMaintain order with arrays.\n\n# Examples\n```jldoctest\njulia> a = Set([1, 3, 4, 5]);\n\njulia> union!(a, 1:2:8);\n\njulia> a\nSet{Int64} with 5 elements:\n  7\n  4\n  3\n  5\n  1\n```\n"}],"Base.AbstractSet":[{"Union{}":"    AbstractSet{T}\n\nSupertype for set-like types whose elements are of type `T`.\n[`Set`](@ref), [`BitSet`](@ref) and other types are subtypes of this.\n"}],"Base.copyfirst!":[{"Tuple{AbstractArray,AbstractArray}":"Extract first entry of slices of array A into existing array R.\n"}],"Base.take!":[{"Tuple{Base.GenericIOBuffer}":"    take!(b::IOBuffer)\n\nObtain the contents of an `IOBuffer` as an array, without copying. Afterwards, the\n`IOBuffer` is reset to its initial state.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n```\n"},{"Tuple{Channel}":"    take!(c::Channel)\n\nRemove and return a value from a [`Channel`](@ref). Blocks until data is available.\n\nFor unbuffered channels, blocks until a [`put!`](@ref) is performed by a different\ntask.\n"}],"Base.keys":[{"Union{}":"    keys(iterator)\n\nFor an iterator or collection that has keys and values (e.g. arrays and dictionaries),\nreturn an iterator over the keys.\n"},{"Tuple{AbstractDict}":"    keys(a::AbstractDict)\n\nReturn an iterator over all keys in a dictionary.\n`collect(keys(a))` returns an array of keys.\nWhen the keys are stored internally in a hash table,\nas is the case for `Dict`,\nthe order in which they are returned may vary.\nBut `keys(a)` and `values(a)` both iterate `a` and\nreturn the elements in the same order.\n\n# Examples\n```jldoctest\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> collect(keys(D))\n2-element Array{Char,1}:\n 'a'\n 'b'\n```\n"}],"Base.hasmethod":[{"Tuple{Any,Any}":"    hasmethod(f, t::Type{<:Tuple}[, kwnames]; world=typemax(UInt)) -> Bool\n\nDetermine whether the given generic function has a method matching the given\n`Tuple` of argument types with the upper bound of world age given by `world`.\n\nIf a tuple of keyword argument names `kwnames` is provided, this also checks\nwhether the method of `f` matching `t` has the given keyword argument names.\nIf the matching method accepts a variable number of keyword arguments, e.g.\nwith `kwargs...`, any names given in `kwnames` are considered valid. Otherwise\nthe provided names must be a subset of the method's keyword arguments.\n\nSee also [`applicable`](@ref).\n\n!!! compat \"Julia 1.2\"\n    Providing keyword argument names requires Julia 1.2 or later.\n\n# Examples\n```jldoctest\njulia> hasmethod(length, Tuple{Array})\ntrue\n\njulia> hasmethod(sum, Tuple{Function, Array}, (:dims,))\ntrue\n\njulia> hasmethod(sum, Tuple{Function, Array}, (:apples, :bananas))\nfalse\n\njulia> g(; xs...) = 4;\n\njulia> hasmethod(g, Tuple{}, (:a, :b, :c, :d))  # g accepts arbitrary kwargs\ntrue\n```\n"}],"Base.argmin":[{"Tuple{Any}":"    argmin(itr) -> Integer\n\nReturn the index of the minimum element in a collection. If there are multiple minimal\nelements, then the first one will be returned.\n\nThe collection must not be empty.\n\n# Examples\n```jldoctest\njulia> argmin([8,0.1,-9,pi])\n3\n\njulia> argmin([7,1,1,6])\n2\n\njulia> argmin([7,1,1,NaN])\n4\n```\n"},{"Tuple{AbstractArray}":"    argmin(A; dims) -> indices\n\nFor an array input, return the indices of the minimum elements over the given dimensions.\n`NaN` is treated as less than all other values.\n\n# Examples\n```jldoctest\njulia> A = [1.0 2; 3 4]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> argmin(A, dims=1)\n1×2 Array{CartesianIndex{2},2}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)\n\njulia> argmin(A, dims=2)\n2×1 Array{CartesianIndex{2},2}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n```\n"}],"Base.firstindex":[{"Tuple{AbstractArray}":"    firstindex(collection) -> Integer\n    firstindex(collection, d) -> Integer\n\nReturn the first index of `collection`. If `d` is given, return the first index of `collection` along dimension `d`.\n\n# Examples\n```jldoctest\njulia> firstindex([1,2,4])\n1\n\njulia> firstindex(rand(3,4,5), 2)\n1\n```\n"}],"Base.findprev":[{"Tuple{Function,Any,Any}":"    findprev(predicate::Function, A, i)\n\nFind the previous index before or including `i` of an element of `A`\nfor which `predicate` returns `true`, or `nothing` if not found.\n\nIndices are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [4, 6, 1, 2]\n4-element Array{Int64,1}:\n 4\n 6\n 1\n 2\n\njulia> findprev(isodd, A, 1) # returns nothing, but not printed in the REPL\n\njulia> findprev(isodd, A, 3)\n3\n\njulia> A = [4 6; 1 2]\n2×2 Array{Int64,2}:\n 4  6\n 1  2\n\njulia> findprev(isodd, A, CartesianIndex(1, 2))\nCartesianIndex(2, 1)\n```\n"},{"Tuple{Any,Any}":"    findprev(A, i)\n\nFind the previous index before or including `i` of a `true` element of `A`,\nor `nothing` if not found.\n\nIndices are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [false, false, true, true]\n4-element Array{Bool,1}:\n 0\n 0\n 1\n 1\n\njulia> findprev(A, 3)\n3\n\njulia> findprev(A, 1) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true true]\n2×2 Array{Bool,2}:\n 0  0\n 1  1\n\njulia> findprev(A, CartesianIndex(2, 1))\nCartesianIndex(2, 1)\n```\n"},{"Tuple{AbstractString,AbstractString,Integer}":"    findprev(pattern::AbstractString, string::AbstractString, start::Integer)\n\nFind the previous occurrence of `pattern` in `string` starting at position `start`.\n\nThe return value is a range of indices where the matching sequence is found, such that\n`s[findprev(x, s, i)] == x`:\n\n`findprev(\"substring\", string, i)` == `start:stop` such that\n`string[start:stop] == \"substring\"` and `stop <= i`, or `nothing` if unmatched.\n\n# Examples\n```jldoctest\njulia> findprev(\"z\", \"Hello to the world\", 18) === nothing\ntrue\n\njulia> findprev(\"o\", \"Hello to the world\", 18)\n15:15\n\njulia> findprev(\"Julia\", \"JuliaLang\", 6)\n1:5\n```\n"},{"Tuple{AbstractChar,AbstractString,Integer}":"    findprev(ch::AbstractChar, string::AbstractString, start::Integer)\n\nFind the previous occurrence of character `ch` in `string` starting at position `start`.\n\n!!! compat \"Julia 1.3\"\n    This method requires at least Julia 1.3.\n\n# Examples\n```jldoctest\njulia> findprev('z', \"Hello to the world\", 18) === nothing\ntrue\n\njulia> findprev('o', \"Hello to the world\", 18)\n15\n```\n"}],"Base.Cuchar":[{"Union{}":"    Cuchar\n\nEquivalent to the native `unsigned char` c-type ([`UInt8`](@ref)).\n"}],"Base.datatype_alignment":[{"Tuple{DataType}":"    Base.datatype_alignment(dt::DataType) -> Int\n\nMemory allocation minimum alignment for instances of this type.\nCan be called on any `isconcretetype`.\n"}],"Base.complex":[{"Tuple{Complex}":"    complex(r, [i])\n\nConvert real numbers or arrays to complex. `i` defaults to zero.\n\n# Examples\n```jldoctest\njulia> complex(7)\n7 + 0im\n\njulia> complex([1, 2, 3])\n3-element Array{Complex{Int64},1}:\n 1 + 0im\n 2 + 0im\n 3 + 0im\n```\n"},{"Union{Tuple{Type{T}}, Tuple{T}} where T<:Real":"    complex(T::Type)\n\nReturn an appropriate type which can represent a value of type `T` as a complex number.\nEquivalent to `typeof(complex(zero(T)))`.\n\n# Examples\n```jldoctest\njulia> complex(Complex{Int})\nComplex{Int64}\n\njulia> complex(Int)\nComplex{Int64}\n```\n"}],"Base.isinf":[{"Tuple{Real}":"    isinf(f) -> Bool\n\nTest whether a number is infinite.\n"}],"Base.datatype_fielddesc_type":[{"Tuple{DataType}":"    Base.datatype_fielddesc_type(dt::DataType) -> Int\n\nReturn the size in bytes of each field-description entry in the layout array,\nlocated at `(dt.layout + sizeof(DataTypeLayout))`.\nCan be called on any `isconcretetype`.\n\nSee also [`fieldoffset`](@ref).\n"}],"Base.isstructtype":[{"Tuple{Type}":"    isstructtype(T) -> Bool\n\nDetermine whether type `T` was declared as a struct type\n(i.e. using the `struct` or `mutable struct` keyword).\n"}],"Base.fullname":[{"Tuple{Module}":"    fullname(m::Module)\n\nGet the fully-qualified name of a module as a tuple of symbols. For example,\n\n# Examples\n```jldoctest\njulia> fullname(Base.Iterators)\n(:Base, :Iterators)\n\njulia> fullname(Main)\n(:Main,)\n```\n"}],"Base.∘":[{"Tuple{Any,Any}":"    f ∘ g\n\nCompose functions: i.e. `(f ∘ g)(args...)` means `f(g(args...))`. The `∘` symbol can be\nentered in the Julia REPL (and most editors, appropriately configured) by typing `\\circ<tab>`.\n\nFunction composition also works in prefix form: `∘(f, g)` is the same as `f ∘ g`.\nThe prefix form supports composition of multiple functions: `∘(f, g, h) = f ∘ g ∘ h`\nand splatting `∘(fs...)` for composing an iterable collection of functions.\n\n!!! compat \"Julia 1.4\"\n    Multiple function composition requires at least Julia 1.4.\n\n# Examples\n```jldoctest\njulia> map(uppercase∘first, [\"apple\", \"banana\", \"carrot\"])\n3-element Array{Char,1}:\n 'A'\n 'B'\n 'C'\n\njulia> fs = [\n           x -> 2x\n           x -> x/2\n           x -> x-1\n           x -> x+1\n       ];\n\njulia> ∘(fs...)(3)\n3.0\n```\n"}],"Base.cis":[{"Tuple{Complex}":"    cis(z)\n\nReturn ``\\exp(iz)``.\n\n# Examples\n```jldoctest\njulia> cis(π) ≈ -1\ntrue\n```\n"}],"Base.circshift!":[{"Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Any,Tuple{Vararg{Integer,N}} where N}} where N where T":"    circshift!(dest, src, shifts)\n\nCircularly shift, i.e. rotate, the data in `src`, storing the result in\n`dest`. `shifts` specifies the amount to shift in each dimension.\n\nThe `dest` array must be distinct from the `src` array (they cannot\nalias each other).\n\nSee also [`circshift`](@ref).\n"}],"Base.UnitRange":[{"Union{}":"    UnitRange{T<:Real}\n\nA range parameterized by a `start` and `stop` of type `T`, filled\nwith elements spaced by `1` from `start` until `stop` is exceeded.\nThe syntax `a:b` with `a` and `b` both `Integer`s creates a `UnitRange`.\n\n# Examples\n```jldoctest\njulia> collect(UnitRange(2.3, 5.2))\n3-element Array{Float64,1}:\n 2.3\n 3.3\n 4.3\n\njulia> typeof(1:10)\nUnitRange{Int64}\n```\n"}],"Base.>>>":[{"Tuple{BitArray{1},Int64}":"    >>>(B::BitVector, n) -> BitVector\n\nUnsigned right bitshift operator, `B >>> n`. Equivalent to `B >> n`. See [`>>`](@ref) for\ndetails and examples.\n"},{"Tuple{Integer,Integer}":"    >>>(x, n)\n\nUnsigned right bit shift operator, `x >>> n`. For `n >= 0`, the result is `x`\nshifted right by `n` bits, where `n >= 0`, filling with `0`s. For `n < 0`, this\nis equivalent to `x << -n`.\n\nFor [`Unsigned`](@ref) integer types, this is equivalent to [`>>`](@ref). For\n[`Signed`](@ref) integer types, this is equivalent to `signed(unsigned(x) >> n)`.\n\n# Examples\n```jldoctest\njulia> Int8(-14) >>> 2\n60\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(60))\n\"00111100\"\n```\n\n[`BigInt`](@ref)s are treated as if having infinite size, so no filling is required and this\nis equivalent to [`>>`](@ref).\n\nSee also [`>>`](@ref), [`<<`](@ref).\n"}],"Base.Inf32":[{"Union{}":"    Inf32\n\nPositive infinity of type [`Float32`](@ref).\n"}],"Base.objectid":[{"Tuple{Any}":"    objectid(x)\n\nGet a hash value for `x` based on object identity. `objectid(x)==objectid(y)` if `x === y`.\n"}],"Base.join":[{"Tuple{IO,Any,Any,Any}":"    join([io::IO,] strings [, delim [, last]])\n\nJoin an array of `strings` into a single string, inserting the given delimiter (if any) between\nadjacent strings. If `last` is given, it will be used instead of `delim` between the last\ntwo strings. If `io` is given, the result is written to `io` rather than returned as\nas a `String`.\n\n`strings` can be any iterable over elements `x` which are convertible to strings\nvia `print(io::IOBuffer, x)`. `strings` will be printed to `io`.\n\n# Examples\n```jldoctest\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"\n\njulia> join([1,2,3,4,5])\n\"12345\"\n```\n"}],"Base.isnan":[{"Tuple{AbstractFloat}":"    isnan(f) -> Bool\n\nTest whether a number value is a NaN, an indeterminate value which is neither an infinity\nnor a finite number (\"not a number\").\n"}],"Base.unsafe_convert":[{"Union{}":"    unsafe_convert(T, x)\n\nConvert `x` to a C argument of type `T`\nwhere the input `x` must be the return value of `cconvert(T, ...)`.\n\nIn cases where [`convert`](@ref) would need to take a Julia object\nand turn it into a `Ptr`, this function should be used to define and perform\nthat conversion.\n\nBe careful to ensure that a Julia reference to `x` exists as long as the result of this\nfunction will be used. Accordingly, the argument `x` to this function should never be an\nexpression, only a variable name or field reference. For example, `x=a.b.c` is acceptable,\nbut `x=[a,b,c]` is not.\n\nThe `unsafe` prefix on this function indicates that using the result of this function after\nthe `x` argument to this function is no longer accessible to the program may cause undefined\nbehavior, including program corruption or segfaults, at any later time.\n\nSee also [`cconvert`](@ref)\n"}],"Base.findmax":[{"Tuple{Any}":"    findmax(itr) -> (x, index)\n\nReturn the maximum element of the collection `itr` and its index. If there are multiple\nmaximal elements, then the first one will be returned.\nIf any data element is `NaN`, this element is returned.\nThe result is in line with `max`.\n\nThe collection must not be empty.\n\n# Examples\n```jldoctest\njulia> findmax([8,0.1,-9,pi])\n(8.0, 1)\n\njulia> findmax([1,7,7,6])\n(7, 2)\n\njulia> findmax([1,7,7,NaN])\n(NaN, 4)\n```\n"},{"Tuple{AbstractArray}":"    findmax(A; dims) -> (maxval, index)\n\nFor an array input, returns the value and index of the maximum over the given dimensions.\n`NaN` is treated as greater than all other values.\n\n# Examples\n```jldoctest\njulia> A = [1.0 2; 3 4]\n2×2 Array{Float64,2}:\n 1.0  2.0\n 3.0  4.0\n\njulia> findmax(A, dims=1)\n([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])\n\njulia> findmax(A, dims=2)\n([2.0; 4.0], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2)])\n```\n"}],"Base.unlock":[{"Tuple{ReentrantLock}":"    unlock(lock)\n\nReleases ownership of the `lock`.\n\nIf this is a recursive lock which has been acquired before, decrement an\ninternal counter and return immediately.\n"}],"Base.Some":[{"Union{}":"    Some{T}\n\nA wrapper type used in `Union{Some{T}, Nothing}` to distinguish between the absence\nof a value ([`nothing`](@ref)) and the presence of a `nothing` value (i.e. `Some(nothing)`).\n\nUse [`something`](@ref) to access the value wrapped by a `Some` object.\n"}],"Base.*":[{"Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}":"    *(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -> AbstractString\n\nConcatenate strings and/or characters, producing a [`String`](@ref). This is equivalent\nto calling the [`string`](@ref) function on the arguments. Concatenation of built-in\nstring types always produces a value of type `String` but other string types may choose\nto return a string of a different type as appropriate.\n\n# Examples\n```jldoctest\njulia> \"Hello \" * \"world\"\n\"Hello world\"\n\njulia> 'j' * \"ulia\"\n\"julia\"\n```\n"},{"Tuple{Union{Regex, AbstractChar, AbstractString},Vararg{Union{Regex, AbstractChar, AbstractString},N} where N}":"    *(s::Regex, t::Union{Regex,AbstractString,AbstractChar}) -> Regex\n    *(s::Union{Regex,AbstractString,AbstractChar}, t::Regex) -> Regex\n\nConcatenate regexes, strings and/or characters, producing a [`Regex`](@ref).\nString and character arguments must be matched exactly in the resulting regex,\nmeaning that the contained characters are devoid of any special meaning\n(they are quoted with \"\\Q\" and \"\\E\").\n\n!!! compat \"Julia 1.3\"\n     This method requires at least Julia 1.3.\n\n# Examples\n```jldoctest\njulia> match(r\"Hello|Good bye\" * ' ' * \"world\", \"Hello world\")\nRegexMatch(\"Hello world\")\n\njulia> r = r\"a|b\" * \"c|d\"\nr\"(?:a|b)\\Qc|d\\E\"\n\njulia> match(r, \"ac\") == nothing\ntrue\n\njulia> match(r, \"ac|d\")\nRegexMatch(\"ac|d\")\n```\n"}],"Base.mod1":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Real":"    mod1(x, y)\n\nModulus after flooring division, returning a value `r` such that `mod(r, y) == mod(x, y)`\nin the range ``(0, y]`` for positive `y` and in the range ``[y,0)`` for negative `y`.\n\nSee also: [`fld1`](@ref), [`fldmod1`](@ref).\n\n# Examples\n```jldoctest\njulia> mod1(4, 2)\n2\n\njulia> mod1(4, 3)\n1\n```\n"}],"Base.isvalid":[{"Tuple{AbstractString,Integer}":"    isvalid(s::AbstractString, i::Integer) -> Bool\n\nPredicate indicating whether the given index is the start of the encoding of a\ncharacter in `s` or not. If `isvalid(s, i)` is true then `s[i]` will return the\ncharacter whose encoding starts at that index, if it's false, then `s[i]` will\nraise an invalid index error or a bounds error depending on if `i` is in bounds.\nIn order for `isvalid(s, i)` to be an O(1) function, the encoding of `s` must be\n[self-synchronizing](https://en.wikipedia.org/wiki/Self-synchronizing_code) this\nis a basic assumption of Julia's generic string support.\n\nSee also: [`getindex`](@ref), [`iterate`](@ref), [`thisind`](@ref),\n[`nextind`](@ref), [`prevind`](@ref), [`length`](@ref)\n\n# Examples\n\n```jldoctest\njulia> str = \"αβγdef\";\n\njulia> isvalid(str, 1)\ntrue\n\njulia> str[1]\n'α': Unicode U+03B1 (category Ll: Letter, lowercase)\n\njulia> isvalid(str, 2)\nfalse\n\njulia> str[2]\nERROR: StringIndexError(\"αβγdef\", 2)\nStacktrace:\n[...]\n```\n"}],"Base.escape_string":[{"Union{Tuple{IO,AbstractString}, Tuple{IO,AbstractString,Any}}":"    escape_string(str::AbstractString[, esc])::AbstractString\n    escape_string(io, str::AbstractString[, esc::])::Nothing\n\nGeneral escaping of traditional C and Unicode escape sequences. The first form returns the\nescaped string, the second prints the result to `io`.\n\nBackslashes (`\\`) are escaped with a double-backslash (`\"\\\\\"`). Non-printable\ncharacters are escaped either with their standard C escape codes, `\"\\0\"` for NUL (if\nunambiguous), unicode code point (`\"\\u\"` prefix) or hex (`\"\\x\"` prefix).\n\nThe optional `esc` argument specifies any additional characters that should also be\nescaped by a prepending backslash (`\"` is also escaped by default in the first form).\n\n# Examples\n```jldoctest\njulia> escape_string(\"aaa\\nbbb\")\n\"aaa\\\\nbbb\"\n\njulia> escape_string(\"\\xfe\\xff\") # invalid utf-8\n\"\\\\xfe\\\\xff\"\n\njulia> escape_string(string('\\u2135','\\0')) # unambiguous\n\"ℵ\\\\0\"\n\njulia> escape_string(string('\\u2135','\\0','0')) # \\0 would be ambiguous\n\"ℵ\\\\x000\"\n```\n\n## See also\n[`unescape_string`](@ref) for the reverse operation.\n"}],"Base.im":[{"Union{}":"    im\n\nThe imaginary unit.\n\n# Examples\n```jldoctest\njulia> im * im\n-1 + 0im\n```\n"}],"Base.NaN32":[{"Union{}":"    NaN32\n\nA not-a-number value of type [`Float32`](@ref).\n"}],"Base.@threadcall":[{"Tuple{Any,Any,Any,Vararg{Any,N} where N}":"    @threadcall((cfunc, clib), rettype, (argtypes...), argvals...)\n\nThe `@threadcall` macro is called in the same way as [`ccall`](@ref) but does the work\nin a different thread. This is useful when you want to call a blocking C\nfunction without causing the main `julia` thread to become blocked. Concurrency\nis limited by size of the libuv thread pool, which defaults to 4 threads but\ncan be increased by setting the `UV_THREADPOOL_SIZE` environment variable and\nrestarting the `julia` process.\n\nNote that the called function should never call back into Julia.\n"}],"Base.ntuple":[{"Union{Tuple{F}, Tuple{F,Integer}} where F":"    ntuple(f::Function, n::Integer)\n\nCreate a tuple of length `n`, computing each element as `f(i)`,\nwhere `i` is the index of the element.\n\n# Examples\n```jldoctest\njulia> ntuple(i -> 2*i, 4)\n(2, 4, 6, 8)\n```\n"}],"Base.∌":[{"Union{}":"    ∉(item, collection) -> Bool\n    ∌(collection, item) -> Bool\n\nNegation of `∈` and `∋`, i.e. checks that `item` is not in `collection`.\n\n# Examples\n```jldoctest\njulia> 1 ∉ 2:4\ntrue\n\njulia> 1 ∉ 1:3\nfalse\n```\n"}],"Base.error":[{"Tuple{AbstractString}":"    error(message::AbstractString)\n\nRaise an `ErrorException` with the given message.\n"},{"Union{Tuple{Vararg{Any,N}}, Tuple{N}} where N":"    error(msg...)\n\nRaise an `ErrorException` with the given message.\n"}],"Base.sizeof":[{"Tuple{Any}":"    sizeof(T::DataType)\n    sizeof(obj)\n\nSize, in bytes, of the canonical binary representation of the given `DataType` `T`, if any.\nSize, in bytes, of object `obj` if it is not `DataType`.\n\n# Examples\n```jldoctest\njulia> sizeof(Float32)\n4\n\njulia> sizeof(ComplexF64)\n16\n\njulia> sizeof(1.0)\n8\n\njulia> sizeof([1.0:10.0;])\n80\n```\n\nIf `DataType` `T` does not have a specific size, an error is thrown.\n\n```jldoctest\njulia> sizeof(AbstractArray)\nERROR: Abstract type AbstractArray does not have a definite size.\nStacktrace:\n[...]\n```\n"},{"Tuple{AbstractString}":"    sizeof(str::AbstractString)\n\nSize, in bytes, of the string `str`. Equal to the number of code units in `str` multiplied by\nthe size, in bytes, of one code unit in `str`.\n\n# Examples\n```jldoctest\njulia> sizeof(\"\")\n0\n\njulia> sizeof(\"∀\")\n3\n```\n"}],"Base.isqrt":[{"Tuple{Integer}":"    isqrt(n::Integer)\n\nInteger square root: the largest integer `m` such that `m*m <= n`.\n\n```jldoctest\njulia> isqrt(5)\n2\n```\n"}],"Base.Cshort":[{"Union{}":"    Cshort\n\nEquivalent to the native `signed short` c-type ([`Int16`](@ref)).\n"}],"Base.trunc":[{"Union{}":"    trunc([T,] x)\n    trunc(x; digits::Integer= [, base = 10])\n    trunc(x; sigdigits::Integer= [, base = 10])\n\n`trunc(x)` returns the nearest integral value of the same type as `x` whose absolute value\nis less than or equal to `x`.\n\n`trunc(T, x)` converts the result to type `T`, throwing an `InexactError` if the value is\nnot representable.\n\n`digits`, `sigdigits` and `base` work as for [`round`](@ref).\n"}],"Base.minimum":[{"Tuple{Any}":"    minimum(itr)\n\nReturns the smallest element in a collection.\n\n# Examples\n```jldoctest\njulia> minimum(-20.5:10)\n-20.5\n\njulia> minimum([1,2,3])\n1\n```\n"},{"Tuple{AbstractArray}":"    minimum(A::AbstractArray; dims)\n\nCompute the minimum value of an array over the given dimensions. See also the\n[`min(a,b)`](@ref) function to take the minimum of two or more arguments,\nwhich can be applied elementwise to arrays via `min.(a,b)`.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> minimum(A, dims=1)\n1×2 Array{Int64,2}:\n 1  2\n\njulia> minimum(A, dims=2)\n2×1 Array{Int64,2}:\n 1\n 3\n```\n"},{"Tuple{Any,Any}":"    minimum(f, itr)\n\nReturns the smallest result of calling function `f` on each element of `itr`.\n\n# Examples\n```jldoctest\njulia> minimum(length, [\"Julion\", \"Julia\", \"Jule\"])\n4\n```\n"}],"Base.inv":[{"Tuple{Number}":"    inv(x)\n\nReturn the multiplicative inverse of `x`, such that `x*inv(x)` or `inv(x)*x`\nyields [`one(x)`](@ref) (the multiplicative identity) up to roundoff errors.\n\nIf `x` is a number, this is essentially the same as `one(x)/x`, but for\nsome types `inv(x)` may be slightly more efficient.\n\n# Examples\n```jldoctest\njulia> inv(2)\n0.5\n\njulia> inv(1 + 2im)\n0.2 - 0.4im\n\njulia> inv(1 + 2im) * (1 + 2im)\n1.0 + 0.0im\n\njulia> inv(2//3)\n3//2\n```\n\n!!! compat \"Julia 1.2\"\n    `inv(::Missing)` requires at least Julia 1.2.\n"}],"Base.==":[{"Tuple{Any}":"    ==(x)\n\nCreate a function that compares its argument to `x` using [`==`](@ref), i.e.\na function equivalent to `y -> y == x`.\n\nThe returned function is of type `Base.Fix2{typeof(==)}`, which can be\nused to implement specialized methods.\n"},{"Tuple{Any,Any}":"    ==(x, y)\n\nGeneric equality operator. Falls back to [`===`](@ref).\nShould be implemented for all types with a notion of equality, based on the abstract value\nthat an instance represents. For example, all numeric types are compared by numeric value,\nignoring type. Strings are compared as sequences of characters, ignoring encoding.\nFor collections, `==` is generally called recursively on all contents,\nthough other properties (like the shape for arrays) may also be taken into account.\n\nThis operator follows IEEE semantics for floating-point numbers: `0.0 == -0.0` and\n`NaN != NaN`.\n\nThe result is of type `Bool`, except when one of the operands is [`missing`](@ref),\nin which case `missing` is returned\n([three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic)).\nFor collections, `missing` is returned if at least one of the operands contains\na `missing` value and all non-missing values are equal.\nUse [`isequal`](@ref) or [`===`](@ref) to always get a `Bool` result.\n\n# Implementation\nNew numeric types should implement this function for two arguments of the new type, and\nhandle comparison to other types via promotion rules where possible.\n\n[`isequal`](@ref) falls back to `==`, so new methods of `==` will be used by the\n[`Dict`](@ref) type to compare keys. If your type will be used as a dictionary key, it\nshould therefore also implement [`hash`](@ref).\n"},{"Tuple{AbstractString,AbstractString}":"    ==(a::AbstractString, b::AbstractString) -> Bool\n\nTest whether two strings are equal character by character (technically, Unicode\ncode point by code point).\n\n# Examples\n```jldoctest\njulia> \"abc\" == \"abc\"\ntrue\n\njulia> \"abc\" == \"αβγ\"\nfalse\n```\n"}],"Base.invokelatest":[{"Tuple{Any,Vararg{Any,N} where N}":"    invokelatest(f, args...; kwargs...)\n\nCalls `f(args...; kwargs...)`, but guarantees that the most recent method of `f`\nwill be executed.   This is useful in specialized circumstances,\ne.g. long-running event loops or callback functions that may\ncall obsolete versions of a function `f`.\n(The drawback is that `invokelatest` is somewhat slower than calling\n`f` directly, and the type of the result cannot be inferred by the compiler.)\n"}],"Base.Cint":[{"Union{}":"    Cint\n\nEquivalent to the native `signed int` c-type ([`Int32`](@ref)).\n"}],"Base.fma":[{"Union{}":"    fma(x, y, z)\n\nComputes `x*y+z` without rounding the intermediate result `x*y`. On some systems this is\nsignificantly more expensive than `x*y+z`. `fma` is used to improve accuracy in certain\nalgorithms. See [`muladd`](@ref).\n"}],"Base.yieldto":[{"Tuple{Task,Any}":"    yieldto(t::Task, arg = nothing)\n\nSwitch to the given task. The first time a task is switched to, the task's function is\ncalled with no arguments. On subsequent switches, `arg` is returned from the task's last\ncall to `yieldto`. This is a low-level call that only switches tasks, not considering states\nor scheduling in any way. Its use is discouraged.\n"}],"Base.VERSION":[{"Union{}":"    VERSION\n\nA `VersionNumber` object describing which version of Julia is in use. For details see\n[Version Number Literals](@ref man-version-number-literals).\n"}],"Base.@async":[{"Tuple{Any}":"    @async\n\nWrap an expression in a [`Task`](@ref) and add it to the local machine's scheduler queue.\n\nValues can be interpolated into `@async` via `$`, which copies the value directly into the\nconstructed underlying closure. This allows you to insert the _value_ of a variable,\nisolating the aysnchronous code from changes to the variable's value in the current task.\n\n!!! compat \"Julia 1.4\"\n    Interpolating values via `$` is available as of Julia 1.4.\n"}],"Base.fld1":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Real":"    fld1(x, y)\n\nFlooring division, returning a value consistent with `mod1(x,y)`\n\nSee also: [`mod1`](@ref), [`fldmod1`](@ref).\n\n# Examples\n```jldoctest\njulia> x = 15; y = 4;\n\njulia> fld1(x, y)\n4\n\njulia> x == fld(x, y) * y + mod(x, y)\ntrue\n\njulia> x == (fld1(x, y) - 1) * y + mod1(x, y)\ntrue\n```\n"}],"Base.AbstractMatrix":[{"Union{}":"    AbstractMatrix{T}\n\nSupertype for two-dimensional arrays (or array-like types) with\nelements of type `T`. Alias for [`AbstractArray{T,2}`](@ref).\n"}],"Base.powermod":[{"Union{Tuple{T}, Tuple{Integer,Integer,T}} where T<:Integer":"    powermod(x::Integer, p::Integer, m)\n\nCompute ``x^p \\pmod m``.\n\n# Examples\n```jldoctest\njulia> powermod(2, 6, 5)\n4\n\njulia> mod(2^6, 5)\n4\n\njulia> powermod(5, 2, 20)\n5\n\njulia> powermod(5, 2, 19)\n6\n\njulia> powermod(5, 3, 19)\n11\n```\n"}],"Base.open_flags":[{"Tuple{}":"    open_flags(; keywords...) -> NamedTuple\n\nCompute the `read`, `write`, `create`, `truncate`, `append` flag value for\na given set of keyword arguments to [`open`](@ref) a [`NamedTuple`](@ref).\n"}],"Base.isfinite":[{"Tuple{AbstractFloat}":"    isfinite(f) -> Bool\n\nTest whether a number is finite.\n\n# Examples\n```jldoctest\njulia> isfinite(5)\ntrue\n\njulia> isfinite(NaN32)\nfalse\n```\n"}],"Base.SecretBuffer":[{"Union{}":"    Base.SecretBuffer()\n\nAn [`IOBuffer`](@ref)-like object where the contents will be securely wiped when garbage collected.\n\nIt is considered best practice to wipe the buffer using `Base.shred!(::SecretBuffer)` as\nsoon as the secure data are no longer required. When initializing with existing data, the\n`SecretBuffer!` method is highly recommended to securely zero the passed argument. Avoid\ninitializing with and converting to `String`s as they are unable to be securely zeroed.\n\n# Examples\n```jldoctest\njulia> s = Base.SecretBuffer()\nSecretBuffer(\"*******\")\n\njulia> write(s, 's', 'e', 'c', 'r', 'e', 't')\n6\n\njulia> seek(s, 0); Char(read(s, UInt8))\n's': ASCII/Unicode U+0073 (category Ll: Letter, lowercase)\n\njulia> Base.shred!(s)\nSecretBuffer(\"*******\")\n\njulia> eof(s)\ntrue\n```\n"},{"Tuple{AbstractString}":"    SecretBuffer(str::AbstractString)\n\nA convenience constructor to initialize a `SecretBuffer` from a non-secret string.\n\nStrings are bad at keeping secrets because they are unable to be securely\nzeroed or destroyed. Therefore, avoid using this constructor with secret data.\nInstead of starting with a string, either construct the `SecretBuffer`\nincrementally with `SecretBuffer()` and [`write`](@ref), or use a `Vector{UInt8}` with\nthe `Base.SecretBuffer!(::Vector{UInt8})` constructor.\n"}],"Base.!":[{"Tuple{Bool}":"    !(x)\n\nBoolean not. Implements [three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic),\nreturning [`missing`](@ref) if `x` is `missing`.\n\n# Examples\n```jldoctest\njulia> !true\nfalse\n\njulia> !false\ntrue\n\njulia> !missing\nmissing\n\njulia> .![true false true]\n1×3 BitArray{2}:\n 0  1  0\n```\n"},{"Tuple{Function}":"    !f::Function\n\nPredicate function negation: when the argument of `!` is a function, it returns a\nfunction which computes the boolean negation of `f`.\n\n# Examples\n```jldoctest\njulia> str = \"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\njulia> filter(isletter, str)\n\"εδxyδfxfyε\"\n\njulia> filter(!isletter, str)\n\"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < \"\n```\n"}],"Base.match":[{"Union{}":"    match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])\n\nSearch for the first match of the regular expression `r` in `s` and return a `RegexMatch`\nobject containing the match, or nothing if the match failed. The matching substring can be\nretrieved by accessing `m.match` and the captured sequences can be retrieved by accessing\n`m.captures` The optional `idx` argument specifies an index at which to start the search.\n\n# Examples\n```jldoctest\njulia> rx = r\"a(.)a\"\nr\"a(.)a\"\n\njulia> m = match(rx, \"cabac\")\nRegexMatch(\"aba\", 1=\"b\")\n\njulia> m.captures\n1-element Array{Union{Nothing, SubString{String}},1}:\n \"b\"\n\njulia> m.match\n\"aba\"\n\njulia> match(rx, \"cabac\", 3) === nothing\ntrue\n```\n"}],"Base.hash":[{"Tuple{Any}":"    hash(x[, h::UInt])\n\nCompute an integer hash code such that `isequal(x,y)` implies `hash(x)==hash(y)`. The\noptional second argument `h` is a hash code to be mixed with the result.\n\nNew types should implement the 2-argument form, typically by calling the 2-argument `hash`\nmethod recursively in order to mix hashes of the contents with each other (and with `h`).\nTypically, any type that implements `hash` should also implement its own `==` (hence\n`isequal`) to guarantee the property mentioned above. Types supporting subtraction\n(operator `-`) should also implement [`widen`](@ref), which is required to hash\nvalues inside heterogeneous arrays.\n"}],"Base.isreadable":[{"Union{}":"    isreadable(io) -> Bool\n\nReturn `true` if the specified IO object is readable (if that can be determined).\n\n# Examples\n```jldoctest\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           isreadable(io)\n       end\nfalse\n\njulia> open(\"myfile.txt\", \"r\") do io\n           isreadable(io)\n       end\ntrue\n\njulia> rm(\"myfile.txt\")\n```\n"}],"Base.ReinterpretArray":[{"Union{}":"Gives a reinterpreted view (of element type T) of the underlying array (of element type S).\nIf the size of `T` differs from the size of `S`, the array will be compressed/expanded in\nthe first dimension.\n"}],"Base.truncate":[{"Tuple{IOStream,Integer}":"    truncate(file, n)\n\nResize the file or buffer given by the first argument to exactly `n` bytes, filling\npreviously unallocated space with '\\0' if the file or buffer is grown.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\")\n35\n\njulia> truncate(io, 15)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15, maxsize=Inf, ptr=16, mark=-1)\n\njulia> String(take!(io))\n\"JuliaLang is a \"\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\");\n\njulia> truncate(io, 40);\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization.\\0\\0\\0\\0\\0\"\n```\n"}],"Base.ismalformed":[{"Tuple{AbstractChar}":"    ismalformed(c::AbstractChar) -> Bool\n\nReturn `true` if `c` represents malformed (non-Unicode) data according to the\nencoding used by `c`.  Defaults to `false` for non-`Char` types.  See also\n[`show_invalid`](@ref).\n"}],"Base.has_bottom_parameter":[{"Tuple{DataType}":"    has_bottom_parameter(t) -> Bool\n\nDetermine whether `t` is a Type for which one or more of its parameters is `Union{}`.\n"}],"Base.circcopy!":[{"Tuple{Any,Any}":"    circcopy!(dest, src)\n\nCopy `src` to `dest`, indexing each dimension modulo its length.\n`src` and `dest` must have the same size, but can be offset in\ntheir indices; any offset results in a (circular) wraparound. If the\narrays have overlapping indices, then on the domain of the overlap\n`dest` agrees with `src`.\n\n# Examples\n```julia-repl\njulia> src = reshape(Vector(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> dest = OffsetArray{Int}(undef, (0:3,2:5))\n\njulia> circcopy!(dest, src)\nOffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:\n 8  12  16  4\n 5   9  13  1\n 6  10  14  2\n 7  11  15  3\n\njulia> dest[1:3,2:4] == src[1:3,2:4]\ntrue\n```\n"}],"Base.lpad":[{"Union{Tuple{Any,Integer}, Tuple{Any,Integer,Union{AbstractChar, AbstractString}}}":"    lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String\n\nStringify `s` and pad the resulting string on the left with `p` to make it `n`\ncharacters (code points) long. If `s` is already `n` characters long, an equal\nstring is returned. Pad with spaces by default.\n\n# Examples\n```jldoctest\njulia> lpad(\"March\", 10)\n\"     March\"\n```\n"}],"Base.unsafe_write":[{"Tuple{IO,Ptr{UInt8},UInt64}":"    unsafe_write(io::IO, ref, nbytes::UInt)\n\nCopy `nbytes` from `ref` (converted to a pointer) into the `IO` object.\n\nIt is recommended that subtypes `T<:IO` override the following method signature\nto provide more efficient implementations:\n`unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)`\n"}],"Base.AbstractUnitRange":[{"Union{}":"    AbstractUnitRange{T} <: OrdinalRange{T, T}\n\nSupertype for ranges with a step size of [`oneunit(T)`](@ref) with elements of type `T`.\n[`UnitRange`](@ref) and other types are subtypes of this.\n"}],"Base.reverse":[{"Tuple{AbstractArray}":"    reverse(A; dims::Integer)\n\nReverse `A` in dimension `dims`.\n\n# Examples\n```jldoctest\njulia> b = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> reverse(b, dims=2)\n2×2 Array{Int64,2}:\n 2  1\n 4  3\n```\n"},{"Union{Tuple{AbstractArray{T,1} where T}, Tuple{AbstractArray{T,1} where T,Any}, Tuple{AbstractArray{T,1} where T,Any,Any}}":"    reverse(v [, start=1 [, stop=length(v) ]] )\n\nReturn a copy of `v` reversed from start to stop.  See also [`Iterators.reverse`](@ref)\nfor reverse-order iteration without making a copy.\n\n# Examples\n```jldoctest\njulia> A = Vector(1:5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> reverse(A)\n5-element Array{Int64,1}:\n 5\n 4\n 3\n 2\n 1\n\njulia> reverse(A, 1, 4)\n5-element Array{Int64,1}:\n 4\n 3\n 2\n 1\n 5\n\njulia> reverse(A, 3, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 5\n 4\n 3\n```\n"},{"Tuple{Union{SubString{String}, String}}":"    reverse(s::AbstractString) -> AbstractString\n\nReverses a string. Technically, this function reverses the codepoints in a string and its\nmain utility is for reversed-order string processing, especially for reversed\nregular-expression searches. See also [`reverseind`](@ref) to convert indices in `s` to\nindices in `reverse(s)` and vice-versa, and `graphemes` from module `Unicode` to\noperate on user-visible \"characters\" (graphemes) rather than codepoints.\nSee also [`Iterators.reverse`](@ref) for\nreverse-order iteration without making a copy. Custom string types must implement the\n`reverse` function themselves and should typically return a string with the same type\nand encoding. If they return a string with a different encoding, they must also override\n`reverseind` for that string type to satisfy `s[reverseind(s,i)] == reverse(s)[i]`.\n\n# Examples\n```jldoctest\njulia> reverse(\"JuliaLang\")\n\"gnaLailuJ\"\n\njulia> reverse(\"ax̂e\") # combining characters can lead to surprising results\n\"êxa\"\n\njulia> using Unicode\n\njulia> join(reverse(collect(graphemes(\"ax̂e\")))) # reverses graphemes\n\"ex̂a\"\n```\n"}],"Base.Inf":[{"Union{}":"    Inf, Inf64\n\nPositive infinity of type [`Float64`](@ref).\n"}],"Base.include_dependency":[{"Tuple{AbstractString}":"    include_dependency(path::AbstractString)\n\nIn a module, declare that the file specified by `path` (relative or absolute) is a\ndependency for precompilation; that is, the module will need to be recompiled if this file\nchanges.\n\nThis is only needed if your module depends on a file that is not used via [`include`](@ref). It has\nno effect outside of compilation.\n"}],"Base.≉":[{"Tuple":"    x ≉ y\n\nThis is equivalent to `!isapprox(x,y)` (see [`isapprox`](@ref)).\n"}],"Base.current_task":[{"Tuple{}":"    current_task()\n\nGet the currently running [`Task`](@ref).\n"}],"Base.redirect_stdout":[{"Union{}":"    redirect_stdout([stream]) -> (rd, wr)\n\nCreate a pipe to which all C and Julia level [`stdout`](@ref) output\nwill be redirected.\nReturns a tuple `(rd, wr)` representing the pipe ends.\nData written to [`stdout`](@ref) may now be read from the `rd` end of\nthe pipe. The `wr` end is given for convenience in case the old\n[`stdout`](@ref) object was cached by the user and needs to be replaced\nelsewhere.\n\nIf called with the optional `stream` argument, then returns `stream` itself.\n\n!!! note\n    `stream` must be a `TTY`, a `Pipe`, or a socket.\n"},{"Tuple{Function,Any}":"    redirect_stdout(f::Function, stream)\n\nRun the function `f` while redirecting [`stdout`](@ref) to `stream`.\nUpon completion, [`stdout`](@ref) is restored to its prior setting.\n\n!!! note\n    `stream` must be a `TTY`, a `Pipe`, or a socket.\n"}],"Base.add12":[{"Union{Tuple{T}, Tuple{T,T}} where T":"    zhi, zlo = add12(x, y)\n\nA high-precision representation of `x + y` for floating-point\nnumbers. Mathematically, `zhi + zlo = x + y`, where `zhi` contains the\nmost significant bits and `zlo` the least significant.\n\nBecause of the way floating-point numbers are printed, `lo` may not\nlook the way you might expect from the standpoint of decimal\nrepresentation, even though it is exact from the standpoint of binary\nrepresentation.\n\nExample:\n```julia\njulia> 1.0 + 1.0001e-15\n1.000000000000001\n\njulia> big(1.0) + big(1.0001e-15)\n1.000000000000001000100000000000020165767380775934141445417482375879192346701529\n\njulia> hi, lo = Base.add12(1.0, 1.0001e-15)\n(1.000000000000001, -1.1012302462515652e-16)\n\njulia> big(hi) + big(lo)\n1.000000000000001000100000000000020165767380775934141445417482375879192346701529\n```\n\n`lo` differs from 1.0e-19 because `hi` is not exactly equal to\nthe first 16 decimal digits of the answer.\n"}],"Base.extrema":[{"Tuple{Any,AbstractArray}":"    extrema(f, A::AbstractArray; dims) -> Array{Tuple}\n\nCompute the minimum and maximum of `f` applied to each element in the given dimensions\nof `A`.\n\n!!! compat \"Julia 1.2\"\n    This method requires Julia 1.2 or later.\n"},{"Tuple{Any}":"    extrema(itr) -> Tuple\n\nCompute both the minimum and maximum element in a single pass, and return them as a 2-tuple.\n\n# Examples\n```jldoctest\njulia> extrema(2:10)\n(2, 10)\n\njulia> extrema([9,pi,4.5])\n(3.141592653589793, 9.0)\n```\n"},{"Tuple{AbstractArray}":"    extrema(A::AbstractArray; dims) -> Array{Tuple}\n\nCompute the minimum and maximum elements of an array over the given dimensions.\n\n# Examples\n```jldoctest\njulia> A = reshape(Vector(1:2:16), (2,2,2))\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  5\n 3  7\n\n[:, :, 2] =\n  9  13\n 11  15\n\njulia> extrema(A, dims = (1,2))\n1×1×2 Array{Tuple{Int64,Int64},3}:\n[:, :, 1] =\n (1, 7)\n\n[:, :, 2] =\n (9, 15)\n```\n"},{"Tuple{Any,Any}":"    extrema(f, itr) -> Tuple\n\nCompute both the minimum and maximum of `f` applied to each element in `itr` and return\nthem as a 2-tuple. Only one pass is made over `itr`.\n\n!!! compat \"Julia 1.2\"\n    This method requires Julia 1.2 or later.\n\n# Examples\n```jldoctest\njulia> extrema(sin, 0:π)\n(0.0, 0.9092974268256817)\n```\n"}],"Base.unindent":[{"Tuple{AbstractString,Int64}":"    unindent(str::AbstractString, indent::Int; tabwidth=8)\n\nRemove leading indentation from string.\n\n# Examples\n```jldoctest\njulia> Base.unindent(\"   a\\n   b\", 2)\n\" a\\n b\"\n\njulia> Base.unindent(\"\\ta\\n\\tb\", 2, tabwidth=8)\n\"      a\\n      b\"\n```\n"}],"Base.maxintfloat":[{"Union{Tuple{T}, Tuple{S}, Tuple{Type{S},Type{T}}} where T<:Integer where S<:AbstractFloat":"    maxintfloat(T, S)\n\nThe largest consecutive integer representable in the given floating-point type `T` that\nalso does not exceed the maximum integer representable by the integer type `S`.  Equivalently,\nit is the minimum of `maxintfloat(T)` and [`typemax(S)`](@ref).\n"},{"Tuple{Type{Float64}}":"    maxintfloat(T=Float64)\n\nThe largest consecutive integer-valued floating-point number that is exactly represented in\nthe given floating-point type `T` (which defaults to `Float64`).\n\nThat is, `maxintfloat` returns the smallest positive integer-valued floating-point number\n`n` such that `n+1` is *not* exactly representable in the type `T`.\n\nWhen an `Integer`-type value is needed, use `Integer(maxintfloat(T))`.\n"}],"Base.pipeline":[{"Tuple{Base.AbstractCmd}":"    pipeline(command; stdin, stdout, stderr, append=false)\n\nRedirect I/O to or from the given `command`. Keyword arguments specify which of the\ncommand's streams should be redirected. `append` controls whether file output appends to the\nfile. This is a more general version of the 2-argument `pipeline` function.\n`pipeline(from, to)` is equivalent to `pipeline(from, stdout=to)` when `from` is a command,\nand to `pipeline(to, stdin=from)` when `from` is another kind of data source.\n\n**Examples**:\n\n```julia\nrun(pipeline(`dothings`, stdout=\"out.txt\", stderr=\"errs.txt\"))\nrun(pipeline(`update`, stdout=\"log.txt\", append=true))\n```\n"},{"Tuple{Any,Any,Any,Vararg{Any,N} where N}":"    pipeline(from, to, ...)\n\nCreate a pipeline from a data source to a destination. The source and destination can be\ncommands, I/O streams, strings, or results of other `pipeline` calls. At least one argument\nmust be a command. Strings refer to filenames. When called with more than two arguments,\nthey are chained together from left to right. For example, `pipeline(a,b,c)` is equivalent to\n`pipeline(pipeline(a,b),c)`. This provides a more concise way to specify multi-stage\npipelines.\n\n**Examples**:\n\n```julia\nrun(pipeline(`ls`, `grep xyz`))\nrun(pipeline(`ls`, \"out.txt\"))\nrun(pipeline(\"out.txt\", `grep xyz`))\n```\n"}],"Base.angle":[{"Tuple{Complex}":"    angle(z)\n\nCompute the phase angle in radians of a complex number `z`.\n\n# Examples\n```jldoctest\njulia> rad2deg(angle(1 + im))\n45.0\n\njulia> rad2deg(angle(1 - im))\n-45.0\n\njulia> rad2deg(angle(-1 - im))\n-135.0\n```\n"}],"Base.hex2bytes":[{"Union{}":"    hex2bytes(s::Union{AbstractString,AbstractVector{UInt8}})\n\nGiven a string or array `s` of ASCII codes for a sequence of hexadecimal digits, returns a\n`Vector{UInt8}` of bytes  corresponding to the binary representation: each successive pair\nof hexadecimal digits in `s` gives the value of one byte in the return vector.\n\nThe length of `s` must be even, and the returned array has half of the length of `s`.\nSee also [`hex2bytes!`](@ref) for an in-place version, and [`bytes2hex`](@ref) for the inverse.\n\n# Examples\n```jldoctest\njulia> s = string(12345, base = 16)\n\"3039\"\n\njulia> hex2bytes(s)\n2-element Array{UInt8,1}:\n 0x30\n 0x39\n\njulia> a = b\"01abEF\"\n6-element Base.CodeUnits{UInt8,String}:\n 0x30\n 0x31\n 0x61\n 0x62\n 0x45\n 0x46\n\njulia> hex2bytes(a)\n3-element Array{UInt8,1}:\n 0x01\n 0xab\n 0xef\n```\n"}],"Base.unescape_string":[{"Union{Tuple{IO,AbstractString}, Tuple{IO,AbstractString,Any}}":"    unescape_string(str::AbstractString, keep = ())::AbstractString\n    unescape_string(io, s::AbstractString, keep = ())::Nothing\n\nGeneral unescaping of traditional C and Unicode escape sequences. The first form returns\nthe escaped string, the second prints the result to `io`.\nThe argument `keep` specifies a collection of characters which (along with backlashes) are\nto be kept as they are.\n\nThe following escape sequences are recognised:\n - Escaped backslash (`\\\\`)\n - Escaped double-quote (`\\\"`)\n - Standard C escape sequences (`\\a`, `\\b`, `\\t`, `\\n`, `\\v`, `\\f`, `\\r`, `\\e`)\n - Unicode BMP code points (`\\u` with 1-4 trailing hex digits)\n - All Unicode code points (`\\U` with 1-8 trailing hex digits; max value = 0010ffff)\n - Hex bytes (`\\x` with 1-2 trailing hex digits)\n - Octal bytes (`\\` with 1-3 trailing octal digits)\n\n# Examples\n```jldoctest\njulia> unescape_string(\"aaa\\\\nbbb\") # C escape sequence\n\"aaa\\nbbb\"\n\njulia> unescape_string(\"\\\\u03c0\") # unicode\n\"π\"\n\njulia> unescape_string(\"\\\\101\") # octal\n\"A\"\n\njulia> unescape_string(\"aaa \\\\g \\\\n\", ['g']) # using `keep` argument\n\"aaa \\\\g \\n\"\n```\n\n## See also\n[`escape_string`](@ref).\n"}],"Base.macroexpand":[{"Tuple{Module,Any}":"    macroexpand(m::Module, x; recursive=true)\n\nTake the expression `x` and return an equivalent expression with all macros removed (expanded)\nfor executing in module `m`.\nThe `recursive` keyword controls whether deeper levels of nested macros are also expanded.\nThis is demonstrated in the example below:\n```julia-repl\njulia> module M\n           macro m1()\n               42\n           end\n           macro m2()\n               :(@m1())\n           end\n       end\nM\n\njulia> macroexpand(M, :(@m2()), recursive=true)\n42\n\njulia> macroexpand(M, :(@m2()), recursive=false)\n:(#= REPL[16]:6 =# M.@m1)\n```\n"}],"Base.lock":[{"Tuple{Any,Base.AbstractLock}":"    lock(f::Function, lock)\n\nAcquire the `lock`, execute `f` with the `lock` held, and release the `lock` when `f`\nreturns. If the lock is already locked by a different task/thread, wait for it to become\navailable.\n\nWhen this function returns, the `lock` has been released, so the caller should\nnot attempt to `unlock` it.\n"},{"Tuple{ReentrantLock}":"    lock(lock)\n\nAcquire the `lock` when it becomes available.\nIf the lock is already locked by a different task/thread,\nwait for it to become available.\n\nEach `lock` must be matched by an [`unlock`](@ref).\n"}],"Base.@static":[{"Tuple{Any}":"    @static\n\nPartially evaluate an expression at parse time.\n\nFor example, `@static Sys.iswindows() ? foo : bar` will evaluate `Sys.iswindows()` and insert\neither `foo` or `bar` into the expression.\nThis is useful in cases where a construct would be invalid on other platforms,\nsuch as a `ccall` to a non-existent function.\n`@static if Sys.isapple() foo end` and `@static foo <&&,||> bar` are also valid syntax.\n"}],"Base.rpad":[{"Union{Tuple{Any,Integer}, Tuple{Any,Integer,Union{AbstractChar, AbstractString}}}":"    rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String\n\nStringify `s` and pad the resulting string on the right with `p` to make it `n`\ncharacters (code points) long. If `s` is already `n` characters long, an equal\nstring is returned. Pad with spaces by default.\n\n# Examples\n```jldoctest\njulia> rpad(\"March\", 20)\n\"March               \"\n```\n"}],"Base.rsplit":[{"Union{}":"    rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)\n    rsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)\n\nSimilar to [`split`](@ref), but starting from the end of the string.\n\n# Examples\n```jldoctest\njulia> a = \"M.a.r.c.h\"\n\"M.a.r.c.h\"\n\njulia> rsplit(a,\".\")\n5-element Array{SubString{String},1}:\n \"M\"\n \"a\"\n \"r\"\n \"c\"\n \"h\"\n\njulia> rsplit(a,\".\";limit=1)\n1-element Array{SubString{String},1}:\n \"M.a.r.c.h\"\n\njulia> rsplit(a,\".\";limit=2)\n2-element Array{SubString{String},1}:\n \"M.a.r.c\"\n \"h\"\n```\n"}],"Base.fill!":[{"Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Any}} where T":"    fill!(A, x)\n\nFill array `A` with the value `x`. If `x` is an object reference, all elements will refer to\nthe same object. `fill!(A, Foo())` will return `A` filled with the result of evaluating\n`Foo()` once.\n\n# Examples\n```jldoctest\njulia> A = zeros(2,3)\n2×3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2.)\n2×3 Array{Float64,2}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A\n3-element Array{Array{Int64,1},1}:\n [2, 1, 1]\n [2, 1, 1]\n [2, 1, 1]\n\njulia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())\n3-element Array{Int64,1}:\n 1\n 1\n 1\n```\n"}],"Base.ENDIAN_BOM":[{"Union{}":"    ENDIAN_BOM\n\nThe 32-bit byte-order-mark indicates the native byte order of the host machine.\nLittle-endian machines will contain the value `0x04030201`. Big-endian machines will contain\nthe value `0x01020304`.\n"}],"Base.chomp":[{"Tuple{AbstractString}":"    chomp(s::AbstractString) -> SubString\n\nRemove a single trailing newline from a string.\n\n# Examples\n```jldoctest\njulia> chomp(\"Hello\\n\")\n\"Hello\"\n```\n"}],"Base.occursin":[{"Tuple{Union{AbstractChar, AbstractString},AbstractString}":"    occursin(needle::Union{AbstractString,Regex,AbstractChar}, haystack::AbstractString)\n\nDetermine whether the first argument is a substring of the second. If `needle`\nis a regular expression, checks whether `haystack` contains a match.\n\n# Examples\n```jldoctest\njulia> occursin(\"Julia\", \"JuliaLang is pretty cool!\")\ntrue\n\njulia> occursin('a', \"JuliaLang is pretty cool!\")\ntrue\n\njulia> occursin(r\"a.a\", \"aba\")\ntrue\n\njulia> occursin(r\"a.a\", \"abba\")\nfalse\n```\n"}],"Base.promote_typejoin":[{"Tuple{Any,Any}":"    promote_typejoin(T, S)\n\nCompute a type that contains both `T` and `S`, which could be\neither a parent of both types, or a `Union` if appropriate.\nFalls back to [`typejoin`](@ref).\n"}],"Base.fldmod1":[{"Tuple{Any,Any}":"    fldmod1(x, y)\n\nReturn `(fld1(x,y), mod1(x,y))`.\n\nSee also: [`fld1`](@ref), [`mod1`](@ref).\n"}],"Base.eof":[{"Tuple{Base.AbstractPipe}":"    eof(stream) -> Bool\n\nTest whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this\nfunction will block to wait for more data if necessary, and then return `false`. Therefore\nit is always safe to read one byte after seeing `eof` return `false`. `eof` will return\n`false` as long as buffered data is still available, even if the remote end of a connection\nis closed.\n"}],"Base.@label":[{"Tuple{Symbol}":"    @label name\n\nLabels a statement with the symbolic label `name`. The label marks the end-point\nof an unconditional jump with [`@goto name`](@ref).\n"}],"Base.codeunit":[{"Tuple{AbstractString}":"    codeunit(s::AbstractString) -> Type{<:Union{UInt8, UInt16, UInt32}}\n\nReturn the code unit type of the given string object. For ASCII, Latin-1, or\nUTF-8 encoded strings, this would be `UInt8`; for UCS-2 and UTF-16 it would be\n`UInt16`; for UTF-32 it would be `UInt32`. The unit code type need not be\nlimited to these three types, but it's hard to think of widely used string\nencodings that don't use one of these units. `codeunit(s)` is the same as\n`typeof(codeunit(s,1))` when `s` is a non-empty string.\n\nSee also: [`ncodeunits`](@ref)\n"},{"Tuple{AbstractString,Integer}":"    codeunit(s::AbstractString, i::Integer) -> Union{UInt8, UInt16, UInt32}\n\nReturn the code unit value in the string `s` at index `i`. Note that\n\n    codeunit(s, i) :: codeunit(s)\n\nI.e. the value returned by `codeunit(s, i)` is of the type returned by\n`codeunit(s)`.\n\nSee also: [`ncodeunits`](@ref), [`checkbounds`](@ref)\n"}],"Base.Vector":[{"Union{}":"    Vector{T} <: AbstractVector{T}\n\nOne-dimensional dense array with elements of type `T`, often used to represent\na mathematical vector. Alias for [`Array{T,1}`](@ref).\n"}],"Base.unalias":[{"Tuple{Any,AbstractArray}":"    Base.unalias(dest, A)\n\nReturn either `A` or a copy of `A` in a rough effort to prevent modifications to `dest` from\naffecting the returned object. No guarantees are provided.\n\nCustom arrays that wrap or use fields containing arrays that might alias against other\nexternal objects should provide a [`Base.dataids`](@ref) implementation.\n\nThis function must return an object of exactly the same type as `A` for performance and type\nstability. Mutable custom arrays for which [`copy(A)`](@ref) is not `typeof(A)` should\nprovide a [`Base.unaliascopy`](@ref) implementation.\n\nSee also [`Base.mightalias`](@ref).\n"}],"Base.StepRange":[{"Union{}":"    StepRange{T, S} <: OrdinalRange{T, S}\n\nRanges with elements of type `T` with spacing of type `S`. The step\nbetween each element is constant, and the range is defined in terms\nof a `start` and `stop` of type `T` and a `step` of type `S`. Neither\n`T` nor `S` should be floating point types. The syntax `a:b:c` with `b > 1`\nand `a`, `b`, and `c` all integers creates a `StepRange`.\n\n# Examples\n```jldoctest\njulia> collect(StepRange(1, Int8(2), 10))\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n\njulia> typeof(StepRange(1, Int8(2), 10))\nStepRange{Int64,Int8}\n\njulia> typeof(1:3:6)\nStepRange{Int64,Int64}\n```\n"}],"Base.VecOrMat":[{"Union{}":"    VecOrMat{T}\n\nUnion type of [`Vector{T}`](@ref) and [`Matrix{T}`](@ref).\n"}],"Base.@eval":[{"Tuple{Any}":"    @eval [mod,] ex\n\nEvaluate an expression with values interpolated into it using `eval`.\nIf two arguments are provided, the first is the module to evaluate in.\n"}],"Base.accumulate!":[{"Tuple{Any,Any,Any}":"    accumulate!(op, B, A; [dims], [init])\n\nCumulative operation `op` on `A` along the dimension `dims`, storing the result in `B`.\nProviding `dims` is optional for vectors.  If the keyword argument `init` is given, its\nvalue is used to instantiate the accumulation. See also [`accumulate`](@ref).\n\n# Examples\n```jldoctest\njulia> x = [1, 0, 2, 0, 3];\n\njulia> y = [0, 0, 0, 0, 0];\n\njulia> accumulate!(+, y, x);\n\njulia> y\n5-element Array{Int64,1}:\n 1\n 1\n 3\n 3\n 6\n\njulia> A = [1 2; 3 4];\n\njulia> B = [0 0; 0 0];\n\njulia> accumulate!(-, B, A, dims=1);\n\njulia> B\n2×2 Array{Int64,2}:\n  1   2\n -2  -2\n\njulia> accumulate!(-, B, A, dims=2);\n\njulia> B\n2×2 Array{Int64,2}:\n 1  -1\n 3  -1\n```\n"}],"Base.BitArray":[{"Union{}":"    BitArray{N} <: AbstractArray{Bool, N}\n\nSpace-efficient `N`-dimensional boolean array, using just one bit for each boolean value.\n\n`BitArray`s pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency\nover `Array{Bool, N}` and allowing some operations to work on 64 values at once.\n\nBy default, Julia returns `BitArrays` from [broadcasting](@ref Broadcasting) operations\nthat generate boolean elements (including dotted-comparisons like `.==`) as well as from\nthe functions [`trues`](@ref) and [`falses`](@ref).\n"},{"Tuple{Any}":"    BitArray(itr)\n\nConstruct a [`BitArray`](@ref) generated by the given iterable object.\nThe shape is inferred from the `itr` object.\n\n# Examples\n```jldoctest\njulia> BitArray([1 0; 0 1])\n2×2 BitArray{2}:\n 1  0\n 0  1\n\njulia> BitArray(x+y == 3 for x = 1:2, y = 1:3)\n2×3 BitArray{2}:\n 0  1  0\n 1  0  0\n\njulia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)\n6-element BitArray{1}:\n 0\n 1\n 0\n 1\n 0\n 0\n```\n"},{"Tuple{UndefInitializer,Vararg{Integer,N} where N}":"    BitArray(undef, dims::Integer...)\n    BitArray{N}(undef, dims::NTuple{N,Int})\n\nConstruct an undef [`BitArray`](@ref) with the given dimensions.\nBehaves identically to the [`Array`](@ref) constructor. See [`undef`](@ref).\n\n# Examples\n```julia-repl\njulia> BitArray(undef, 2, 2)\n2×2 BitArray{2}:\n 0  0\n 0  0\n\njulia> BitArray(undef, (3, 1))\n3×1 BitArray{2}:\n 0\n 0\n 0\n```\n"}],"Base.rethrow":[{"Tuple{}":"    rethrow()\n\nRethrow the current exception from within a `catch` block. The rethrown\nexception will continue propagation as if it had not been caught.\n\n!!! note\n    The alternative form `rethrow(e)` allows you to associate an alternative\n    exception object `e` with the current backtrace. However this misrepresents\n    the program state at the time of the error so you're encouraged to instead\n    throw a new exception using `throw(e)`. In Julia 1.1 and above, using\n    `throw(e)` will preserve the root cause exception on the stack, as\n    described in [`catch_stack`](@ref).\n"}],"Base.@__DIR__":[{"Tuple{}":"    @__DIR__ -> AbstractString\n\nExpand to a string with the absolute path to the directory of the file\ncontaining the macrocall.\nReturn the current working directory if run from a REPL or if evaluated by `julia -e <expr>`.\n"}],"Base.abs2":[{"Tuple{Real}":"    abs2(x)\n\nSquared absolute value of `x`.\n\n# Examples\n```jldoctest\njulia> abs2(-3)\n9\n```\n"}],"Base.@v_str":[{"Tuple{Any}":"    @v_str\n\nString macro used to parse a string to a [`VersionNumber`](@ref).\n\n# Examples\n```jldoctest\njulia> v\"1.2.3\"\nv\"1.2.3\"\n\njulia> v\"2.0.1-rc1\"\nv\"2.0.1-rc1\"\n```\n"}],"Base.flush":[{"Tuple{IO}":"    flush(stream)\n\nCommit all currently buffered writes to the given stream.\n"}],"Base.ismarked":[{"Tuple{IO}":"    ismarked(s)\n\nReturn `true` if stream `s` is marked.\n\nSee also [`mark`](@ref), [`unmark`](@ref), [`reset`](@ref).\n"}],"Base.isequal":[{"Tuple{Any}":"    isequal(x)\n\nCreate a function that compares its argument to `x` using [`isequal`](@ref), i.e.\na function equivalent to `y -> isequal(y, x)`.\n\nThe returned function is of type `Base.Fix2{typeof(isequal)}`, which can be\nused to implement specialized methods.\n"},{"Tuple{Any,Any}":"    isequal(x, y)\n\nSimilar to [`==`](@ref), except for the treatment of floating point numbers\nand of missing values. `isequal` treats all floating-point `NaN` values as equal\nto each other, treats `-0.0` as unequal to `0.0`, and [`missing`](@ref) as equal\nto `missing`. Always returns a `Bool` value.\n\n# Implementation\nThe default implementation of `isequal` calls `==`, so a type that does not involve\nfloating-point values generally only needs to define `==`.\n\n`isequal` is the comparison function used by hash tables (`Dict`). `isequal(x,y)` must imply\nthat `hash(x) == hash(y)`.\n\nThis typically means that types for which a custom `==` or `isequal` method exists must\nimplement a corresponding `hash` method (and vice versa). Collections typically implement\n`isequal` by calling `isequal` recursively on all contents.\n\nScalar types generally do not need to implement `isequal` separate from `==`, unless they\nrepresent floating-point numbers amenable to a more efficient implementation than that\nprovided as a generic fallback (based on `isnan`, `signbit`, and `==`).\n\n# Examples\n```jldoctest\njulia> isequal([1., NaN], [1., NaN])\ntrue\n\njulia> [1., NaN] == [1., NaN]\nfalse\n\njulia> 0.0 == -0.0\ntrue\n\njulia> isequal(0.0, -0.0)\nfalse\n```\n"}],"Base.iszero":[{"Tuple{Any}":"    iszero(x)\n\nReturn `true` if `x == zero(x)`; if `x` is an array, this checks whether\nall of the elements of `x` are zero.\n\n# Examples\n```jldoctest\njulia> iszero(0.0)\ntrue\n\njulia> iszero([1, 9, 0])\nfalse\n\njulia> iszero([false, 0, 0])\ntrue\n```\n"}],"Base.compilecache":[{"Tuple{Base.PkgId}":"    Base.compilecache(module::PkgId)\n\nCreates a precompiled cache file for a module and all of its dependencies.\nThis can be used to reduce package load times. Cache files are stored in\n`DEPOT_PATH[1]/compiled`. See [Module initialization and precompilation](@ref)\nfor important notes.\n"}],"Base.@polly":[{"Tuple{Any}":"    @polly\n\nTells the compiler to apply the polyhedral optimizer Polly to a function.\n"}],"Base.isapprox":[{"Tuple{Number,Number}":"    isapprox(x, y; rtol::Real=atol>0 ? 0 : √eps, atol::Real=0, nans::Bool=false, norm::Function)\n\nInexact equality comparison: `true` if `norm(x-y) <= max(atol, rtol*max(norm(x), norm(y)))`. The\ndefault `atol` is zero and the default `rtol` depends on the types of `x` and `y`. The keyword\nargument `nans` determines whether or not NaN values are considered equal (defaults to false).\n\nFor real or complex floating-point values, if an `atol > 0` is not specified, `rtol` defaults to\nthe square root of [`eps`](@ref) of the type of `x` or `y`, whichever is bigger (least precise).\nThis corresponds to requiring equality of about half of the significand digits. Otherwise,\ne.g. for integer arguments or if an `atol > 0` is supplied, `rtol` defaults to zero.\n\n`x` and `y` may also be arrays of numbers, in which case `norm` defaults to the usual\n`norm` function in LinearAlgebra, but\nmay be changed by passing a `norm::Function` keyword argument. (For numbers, `norm` is the\nsame thing as `abs`.) When `x` and `y` are arrays, if `norm(x-y)` is not finite (i.e. `±Inf`\nor `NaN`), the comparison falls back to checking whether all elements of `x` and `y` are\napproximately equal component-wise.\n\nThe binary operator `≈` is equivalent to `isapprox` with the default arguments, and `x ≉ y`\nis equivalent to `!isapprox(x,y)`.\n\nNote that `x ≈ 0` (i.e., comparing to zero with the default tolerances) is\nequivalent to `x == 0` since the default `atol` is `0`.  In such cases, you should either\nsupply an appropriate `atol` (or use `norm(x) ≤ atol`) or rearrange your code (e.g.\nuse `x ≈ y` rather than `x - y ≈ 0`).   It is not possible to pick a nonzero `atol`\nautomatically because it depends on the overall scaling (the \"units\") of your problem:\nfor example, in `x - y ≈ 0`, `atol=1e-9` is an absurdly small tolerance if `x` is the\n[radius of the Earth](https://en.wikipedia.org/wiki/Earth_radius) in meters,\nbut an absurdly large tolerance if `x` is the\n[radius of a Hydrogen atom](https://en.wikipedia.org/wiki/Bohr_radius) in meters.\n\n\n# Examples\n```jldoctest\njulia> 0.1 ≈ (0.1 - 1e-10)\ntrue\n\njulia> isapprox(10, 11; atol = 2)\ntrue\n\njulia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])\ntrue\n\njulia> 1e-10 ≈ 0\nfalse\n\njulia> isapprox(1e-10, 0, atol=1e-8)\ntrue\n```\n"}],"Base.isone":[{"Tuple{Any}":"    isone(x)\n\nReturn `true` if `x == one(x)`; if `x` is an array, this checks whether\n`x` is an identity matrix.\n\n# Examples\n```jldoctest\njulia> isone(1.0)\ntrue\n\njulia> isone([1 0; 0 2])\nfalse\n\njulia> isone([1 0; 0 true])\ntrue\n```\n"}],"Base.tryparse":[{"Union{Tuple{T}, Tuple{Type{T},AbstractString}} where T<:Integer":"    tryparse(type, str; base)\n\nLike [`parse`](@ref), but returns either a value of the requested type,\nor [`nothing`](@ref) if the string does not contain a valid number.\n"}],"Base.Fix1":[{"Union{}":"    Fix1(f, x)\n\nA type representing a partially-applied version of the two-argument function\n`f`, with the first argument fixed to the value \"x\". In other words,\n`Fix1(f, x)` behaves similarly to `y->f(x, y)`.\n"}],"Base.coalesce":[{"Union{}":"    coalesce(x, y...)\n\nReturn the first value in the arguments which is not equal to [`missing`](@ref),\nif any. Otherwise return `missing`.\n\nSee also [`something`](@ref).\n\n# Examples\n\n```jldoctest\njulia> coalesce(missing, 1)\n1\n\njulia> coalesce(1, missing)\n1\n\njulia> coalesce(nothing, 1)  # returns `nothing`\n\njulia> coalesce(missing, missing)\nmissing\n```\n"}],"Base.hvcat":[{"Tuple{Tuple{Vararg{Int64,N} where N},Vararg{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,N} where N}":"    hvcat(rows::Tuple{Vararg{Int}}, values...)\n\nHorizontal and vertical concatenation in one call. This function is called for block matrix\nsyntax. The first argument specifies the number of arguments to concatenate in each block\nrow.\n\n# Examples\n```jldoctest\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1, 2, 3, 4, 5, 6)\n\njulia> [a b c; d e f]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> hvcat((3,3), a,b,c,d,e,f)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> [a b;c d; e f]\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n\njulia> hvcat((2,2,2), a,b,c,d,e,f)\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n```\n\nIf the first argument is a single integer `n`, then all block rows are assumed to have `n`\nblock columns.\n"}],"Base.yield":[{"Tuple{Task,Any}":"    yield(t::Task, arg = nothing)\n\nA fast, unfair-scheduling version of `schedule(t, arg); yield()` which\nimmediately yields to `t` before calling the scheduler.\n"},{"Tuple{}":"    yield()\n\nSwitch to the scheduler to allow another scheduled task to run. A task that calls this\nfunction is still runnable, and will be restarted immediately if there are no other runnable\ntasks.\n"}],"Base.Condition":[{"Union{}":"    Condition()\n\nCreate an edge-triggered event source that tasks can wait for. Tasks that call [`wait`](@ref) on a\n`Condition` are suspended and queued. Tasks are woken up when [`notify`](@ref) is later called on\nthe `Condition`. Edge triggering means that only tasks waiting at the time [`notify`](@ref) is\ncalled can be woken up. For level-triggered notifications, you must keep extra state to keep\ntrack of whether a notification has happened. The [`Channel`](@ref) and [`Threads.Event`](@ref) types do\nthis, and can be used for level-triggered events.\n\nThis object is NOT thread-safe. See [`Threads.Condition`](@ref) for a thread-safe version.\n"}],"Base.filter":[{"Tuple{Any,AbstractDict}":"    filter(f, d::AbstractDict)\n\nReturn a copy of `d`, removing elements for which `f` is `false`.\nThe function `f` is passed `key=>value` pairs.\n\n# Examples\n```jldoctest\njulia> d = Dict(1=>\"a\", 2=>\"b\")\nDict{Int64,String} with 2 entries:\n  2 => \"b\"\n  1 => \"a\"\n\njulia> filter(p->isodd(p.first), d)\nDict{Int64,String} with 1 entry:\n  1 => \"a\"\n```\n"},{"Union{Tuple{N}, Tuple{T}, Tuple{Any,Array{T,N}}} where N where T":"    filter(f, a::AbstractArray)\n\nReturn a copy of `a`, removing elements for which `f` is `false`.\nThe function `f` is passed one argument.\n\n# Examples\n```jldoctest\njulia> a = 1:10\n1:10\n\njulia> filter(isodd, a)\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n```\n"},{"Tuple{Any,Base.SkipMissing{#s662} where #s662<:AbstractArray}":"    filter(f, itr::SkipMissing{<:AbstractArray})\n\nReturn a vector similar to the array wrapped by the given `SkipMissing` iterator\nbut with all missing elements and those for which `f` returns `false` removed.\n\n!!! compat \"Julia 1.2\"\n    This method requires Julia 1.2 or later.\n\n# Examples\n```jldoctest\njulia> x = [1 2; missing 4]\n2×2 Array{Union{Missing, Int64},2}:\n 1         2\n  missing  4\n\njulia> filter(isodd, skipmissing(x))\n1-element Array{Int64,1}:\n 1\n```\n"}],"Base.nextpow":[{"Tuple{Real,Real}":"    nextpow(a, x)\n\nThe smallest `a^n` not less than `x`, where `n` is a non-negative integer. `a` must be\ngreater than 1, and `x` must be greater than 0.\n\n# Examples\n```jldoctest\njulia> nextpow(2, 7)\n8\n\njulia> nextpow(2, 9)\n16\n\njulia> nextpow(5, 20)\n25\n\njulia> nextpow(4, 16)\n16\n```\n\nSee also [`prevpow`](@ref).\n"}],"Base.AsyncCondition":[{"Union{}":"    AsyncCondition()\n\nCreate a async condition that wakes up tasks waiting for it\n(by calling [`wait`](@ref) on the object)\nwhen notified from C by a call to `uv_async_send`.\nWaiting tasks are woken with an error when the object is closed (by [`close`](@ref).\nUse [`isopen`](@ref) to check whether it is still active.\n"},{"Tuple{Function}":"    AsyncCondition(callback::Function)\n\nCreate a async condition that calls the given `callback` function. The `callback` is passed one argument,\nthe async condition object itself.\n"}],"Base.runtests":[{"Union{Tuple{}, Tuple{Any}}":"    Base.runtests(tests=[\"all\"]; ncores=ceil(Int, Sys.CPU_THREADS / 2),\n                  exit_on_error=false, [seed])\n\nRun the Julia unit tests listed in `tests`, which can be either a string or an array of\nstrings, using `ncores` processors. If `exit_on_error` is `false`, when one test\nfails, all remaining tests in other files will still be run; they are otherwise discarded,\nwhen `exit_on_error == true`.\nIf a seed is provided via the keyword argument, it is used to seed the\nglobal RNG in the context where the tests are run; otherwise the seed is chosen randomly.\n"}],"Base.get":[{"Tuple{Function,Any,Any}":"    get(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, return\n`f()`.  Use [`get!`](@ref) to also store the default value in the dictionary.\n\nThis is intended to be called using `do` block syntax\n\n```julia\nget(dict, key) do\n    # default value calculated here\n    time()\nend\n```\n"},{"Tuple{Any,Any,Any}":"    get(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the\nkey is present.\n\n# Examples\n```jldoctest\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> get(d, \"a\", 3)\n1\n\njulia> get(d, \"c\", 3)\n3\n```\n"}],"Base.run":[{"Tuple{Base.AbstractCmd,Vararg{Any,N} where N}":"    run(command, args...; wait::Bool = true)\n\nRun a command object, constructed with backticks (see the [Running External Programs](@ref)\nsection in the manual). Throws an error if anything goes wrong, including the process\nexiting with a non-zero status (when `wait` is true).\n\nIf `wait` is false, the process runs asynchronously. You can later wait for it and check\nits exit status by calling `success` on the returned process object.\n\nWhen `wait` is false, the process' I/O streams are directed to `devnull`.\nWhen `wait` is true, I/O streams are shared with the parent process.\nUse [`pipeline`](@ref) to control I/O redirection.\n"}],"Base.IdentityUnitRange":[{"Union{}":"   IdentityUnitRange(range::AbstractUnitRange)\n\nRepresent an AbstractUnitRange `range` as an offset vector such that `range[i] == i`.\n\n`IdentityUnitRange`s are frequently used as axes for offset arrays.\n"}],"Base.isascii":[{"Tuple{Char}":"    isascii(c::Union{AbstractChar,AbstractString}) -> Bool\n\nTest whether a character belongs to the ASCII character set, or whether this is true for\nall elements of a string.\n\n# Examples\n```jldoctest\njulia> isascii('a')\ntrue\n\njulia> isascii('α')\nfalse\n\njulia> isascii(\"abc\")\ntrue\n\njulia> isascii(\"αβγ\")\nfalse\n```\n"}],"Base.write":[{"Union{}":"    write(io::IO, x)\n    write(filename::AbstractString, x)\n\nWrite the canonical binary representation of a value to the given I/O stream or file.\nReturn the number of bytes written into the stream.   See also [`print`](@ref) to\nwrite a text representation (with an encoding that may depend upon `io`).\n\nYou can write multiple values with the same `write` call. i.e. the following are equivalent:\n\n    write(io, x, y...)\n    write(io, x) + write(io, y...)\n\n# Examples\n```jldoctest\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> write(io, \"Sometimes those members\") + write(io, \" write documentation.\")\n44\n\njulia> String(take!(io))\n\"Sometimes those members write documentation.\"\n```\nUser-defined plain-data types without `write` methods can be written when wrapped in a `Ref`:\n```jldoctest\njulia> struct MyStruct; x::Float64; end\n\njulia> io = IOBuffer()\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)\n\njulia> write(io, Ref(MyStruct(42.0)))\n8\n\njulia> seekstart(io); read!(io, Ref(MyStruct(NaN)))\nBase.RefValue{MyStruct}(MyStruct(42.0))\n```\n"}],"Base.parse":[{"Tuple{Type,Any}":"    parse(type, str; base)\n\nParse a string as a number. For `Integer` types, a base can be specified\n(the default is 10). For floating-point types, the string is parsed as a decimal\nfloating-point number.  `Complex` types are parsed from decimal strings\nof the form `\"R±Iim\"` as a `Complex(R,I)` of the requested type; `\"i\"` or `\"j\"` can also be\nused instead of `\"im\"`, and `\"R\"` or `\"Iim\"` are also permitted.\nIf the string does not contain a valid number, an error is raised.\n\n!!! compat \"Julia 1.1\"\n    `parse(Bool, str)` requires at least Julia 1.1.\n\n# Examples\n```jldoctest\njulia> parse(Int, \"1234\")\n1234\n\njulia> parse(Int, \"1234\", base = 5)\n194\n\njulia> parse(Int, \"afc\", base = 16)\n2812\n\njulia> parse(Float64, \"1.2e-3\")\n0.0012\n\njulia> parse(Complex{Float64}, \"3.2e-1 + 4.5im\")\n0.32 + 4.5im\n```\n"}],"Base.!=":[{"Tuple{Any}":"    !=(x)\n\nCreate a function that compares its argument to `x` using [`!=`](@ref), i.e.\na function equivalent to `y -> y != x`.\nThe returned function is of type `Base.Fix2{typeof(!=)}`, which can be\nused to implement specialized methods.\n\n!!! compat \"Julia 1.2\"\n    This functionality requires at least Julia 1.2.\n"},{"Tuple{Any,Any}":"    !=(x, y)\n    ≠(x,y)\n\nNot-equals comparison operator. Always gives the opposite answer as [`==`](@ref).\n\n# Implementation\nNew types should generally not implement this, and rely on the fallback definition\n`!=(x,y) = !(x==y)` instead.\n\n# Examples\n```jldoctest\njulia> 3 != 2\ntrue\n\njulia> \"foo\" ≠ \"foo\"\nfalse\n```\n"}],"Base.>=":[{"Tuple{Any}":"    >=(x)\n\nCreate a function that compares its argument to `x` using [`>=`](@ref), i.e.\na function equivalent to `y -> y >= x`.\nThe returned function is of type `Base.Fix2{typeof(>=)}`, which can be\nused to implement specialized methods.\n\n!!! compat \"Julia 1.2\"\n    This functionality requires at least Julia 1.2.\n"},{"Tuple{Any,Any}":"    >=(x, y)\n    ≥(x,y)\n\nGreater-than-or-equals comparison operator. Falls back to `y <= x`.\n\n# Examples\n```jldoctest\njulia> 'a' >= 'b'\nfalse\n\njulia> 7 ≥ 7 ≥ 3\ntrue\n\njulia> \"abc\" ≥ \"abc\"\ntrue\n\njulia> 5 >= 3\ntrue\n```\n"}],"Base.foldr":[{"Tuple{Any,Any}":"    foldr(op, itr; [init])\n\nLike [`reduce`](@ref), but with guaranteed right associativity. If provided, the keyword\nargument `init` will be used exactly once. In general, it will be necessary to provide\n`init` to work with empty collections.\n\n# Examples\n```jldoctest\njulia> foldr(=>, 1:4)\n1 => (2 => (3 => 4))\n\njulia> foldr(=>, 1:4; init=0)\n1 => (2 => (3 => (4 => 0)))\n```\n"}],"Base.summarysize":[{"Tuple{Any}":"    Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int\n\nCompute the amount of memory, in bytes, used by all unique objects reachable from the argument.\n\n# Keyword Arguments\n- `exclude`: specifies the types of objects to exclude from the traversal.\n- `chargeall`: specifies the types of objects to always charge the size of all of their\n  fields, even if those fields would normally be excluded.\n"}],"Base.fldmod":[{"Tuple{Any,Any}":"    fldmod(x, y)\n\nThe floored quotient and modulus after division. A convenience wrapper for\n`divrem(x, y, RoundDown)`. Equivalent to `(fld(x,y), mod(x,y))`.\n"}],"Base.filter!":[{"Tuple{Any,AbstractDict}":"    filter!(f, d::AbstractDict)\n\nUpdate `d`, removing elements for which `f` is `false`.\nThe function `f` is passed `key=>value` pairs.\n\n# Example\n```jldoctest\njulia> d = Dict(1=>\"a\", 2=>\"b\", 3=>\"c\")\nDict{Int64,String} with 3 entries:\n  2 => \"b\"\n  3 => \"c\"\n  1 => \"a\"\n\njulia> filter!(p->isodd(p.first), d)\nDict{Int64,String} with 2 entries:\n  3 => \"c\"\n  1 => \"a\"\n```\n"},{"Tuple{Any,AbstractArray{T,1} where T}":"    filter!(f, a::AbstractVector)\n\nUpdate `a`, removing elements for which `f` is `false`.\nThe function `f` is passed one argument.\n\n# Examples\n```jldoctest\njulia> filter!(isodd, Vector(1:10))\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n```\n"}],"Base.setenv":[{"Tuple{Cmd,Any}":"    setenv(command::Cmd, env; dir=\"\")\n\nSet environment variables to use when running the given `command`. `env` is either a\ndictionary mapping strings to strings, an array of strings of the form `\"var=val\"`, or zero\nor more `\"var\"=>val` pair arguments. In order to modify (rather than replace) the existing\nenvironment, create `env` by `copy(ENV)` and then setting `env[\"var\"]=val` as desired, or\nuse `withenv`.\n\nThe `dir` keyword argument can be used to specify a working directory for the command.\n"}],"Base.hton":[{"Tuple{Any}":"    hton(x)\n\nConvert the endianness of a value from that used by the Host to Network byte order (big-endian).\n"}],"Base.split":[{"Union{}":"    split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)\n    split(str::AbstractString; limit::Integer=0, keepempty::Bool=false)\n\nSplit `str` into an array of substrings on occurrences of the delimiter(s) `dlm`.  `dlm`\ncan be any of the formats allowed by [`findnext`](@ref)'s first argument (i.e. as a\nstring, regular expression or a function), or as a single character or collection of\ncharacters.\n\nIf `dlm` is omitted, it defaults to [`isspace`](@ref).\n\nThe optional keyword arguments are:\n - `limit`: the maximum size of the result. `limit=0` implies no maximum (default)\n - `keepempty`: whether empty fields should be kept in the result. Default is `false` without\n   a `dlm` argument, `true` with a `dlm` argument.\n\nSee also [`rsplit`](@ref).\n\n# Examples\n```jldoctest\njulia> a = \"Ma.rch\"\n\"Ma.rch\"\n\njulia> split(a,\".\")\n2-element Array{SubString{String},1}:\n \"Ma\"\n \"rch\"\n```\n"}],"Base.endswith":[{"Tuple{AbstractString,Regex}":"    endswith(s::AbstractString, suffix::Regex)\n\nReturn `true` if `s` ends with the regex pattern, `suffix`.\n\n!!! note\n    `endswith` does not compile the anchoring into the regular\n    expression, but instead passes the anchoring as\n    `match_option` to PCRE. If compile time is amortized,\n    `occursin(r\"...$\", s)` is faster than `endswith(s, r\"...\")`.\n\nSee also [`occursin`](@ref) and [`startswith`](@ref).\n\n!!! compat \"Julia 1.2\"\n     This method requires at least Julia 1.2.\n\n# Examples\n```jldoctest\njulia> endswith(\"JuliaLang\", r\"Lang|Roberts\")\ntrue\n```\n"},{"Tuple{AbstractString,AbstractString}":"    endswith(s::AbstractString, suffix::AbstractString)\n\nReturn `true` if `s` ends with `suffix`. If `suffix` is a vector or set of\ncharacters, test whether the last character of `s` belongs to that set.\n\nSee also [`startswith`](@ref).\n\n# Examples\n```jldoctest\njulia> endswith(\"Sunday\", \"day\")\ntrue\n```\n"}],"Base.cmp":[{"Tuple{Any,Any}":"    cmp(x,y)\n\nReturn -1, 0, or 1 depending on whether `x` is less than, equal to, or greater than `y`,\nrespectively. Uses the total order implemented by `isless`.\n\n# Examples\n```jldoctest\njulia> cmp(1, 2)\n-1\n\njulia> cmp(2, 1)\n1\n\njulia> cmp(2+im, 3-im)\nERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})\n[...]\n```\n"},{"Tuple{Any,Any,Any}":"    cmp(<, x, y)\n\nReturn -1, 0, or 1 depending on whether `x` is less than, equal to, or greater than `y`,\nrespectively. The first argument specifies a less-than comparison function to use.\n"},{"Tuple{AbstractString,AbstractString}":"    cmp(a::AbstractString, b::AbstractString) -> Int\n\nCompare two strings. Return `0` if both strings have the same length and the character\nat each index is the same in both strings. Return `-1` if `a` is a prefix of `b`, or if\n`a` comes before `b` in alphabetical order. Return `1` if `b` is a prefix of `a`, or if\n`b` comes before `a` in alphabetical order (technically, lexicographical order by Unicode\ncode points).\n\n# Examples\n```jldoctest\njulia> cmp(\"abc\", \"abc\")\n0\n\njulia> cmp(\"ab\", \"abc\")\n-1\n\njulia> cmp(\"abc\", \"ab\")\n1\n\njulia> cmp(\"ab\", \"ac\")\n-1\n\njulia> cmp(\"ac\", \"ab\")\n1\n\njulia> cmp(\"α\", \"a\")\n1\n\njulia> cmp(\"b\", \"β\")\n-1\n```\n"}],"Base.moduleroot":[{"Tuple{Module}":"    moduleroot(m::Module) -> Module\n\nFind the root module of a given module. This is the first module in the chain of\nparent modules of `m` which is either a registered root module or which is its\nown parent module.\n"}],"Base.atexit":[{"Tuple{Function}":"    atexit(f)\n\nRegister a zero-argument function `f()` to be called at process exit. `atexit()` hooks are\ncalled in last in first out (LIFO) order and run before object finalizers.\n\nExit hooks are allowed to call `exit(n)`, in which case Julia will exit with\nexit code `n` (instead of the original exit code). If more than one exit hook\ncalls `exit(n)`, then Julia will exit with the exit code corresponding to the\nlast called exit hook that calls `exit(n)`. (Because exit hooks are called in\nLIFO order, \"last called\" is equivalent to \"first registered\".)\n"}],"Base.setdiff!":[{"Tuple{AbstractSet,Vararg{Any,N} where N}":"    setdiff!(s, itrs...)\n\nRemove from set `s` (in-place) each element of each iterable from `itrs`.\nMaintain order with arrays.\n\n# Examples\n```jldoctest\njulia> a = Set([1, 3, 4, 5]);\n\njulia> setdiff!(a, 1:2:6);\n\njulia> a\nSet{Int64} with 1 element:\n  4\n```\n"}],"Base.DimensionMismatch":[{"Union{}":"    DimensionMismatch([msg])\n\nThe objects called do not have matching dimensionality. Optional argument `msg` is a\ndescriptive error string.\n"}],"Base.chop":[{"Tuple{AbstractString}":"    chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)\n\nRemove the first `head` and the last `tail` characters from `s`.\nThe call `chop(s)` removes the last character from `s`.\nIf it is requested to remove more characters than `length(s)`\nthen an empty string is returned.\n\n# Examples\n```jldoctest\njulia> a = \"March\"\n\"March\"\n\njulia> chop(a)\n\"Marc\"\n\njulia> chop(a, head = 1, tail = 2)\n\"ar\"\n\njulia> chop(a, head = 5, tail = 5)\n\"\"\n```\n"}],"Base.copy!":[{"Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}":"    copy!(dst, src) -> dst\n\nIn-place [`copy`](@ref) of `src` into `dst`, discarding any pre-existing\nelements in `dst`.\nIf `dst` and `src` are of the same type, `dst == src` should hold after\nthe call. If `dst` and `src` are multidimensional arrays, they must have\nequal [`axes`](@ref).\nSee also [`copyto!`](@ref).\n\n!!! compat \"Julia 1.1\"\n    This method requires at least Julia 1.1. In Julia 1.0 this method\n    is available from the `Future` standard library as `Future.copy!`.\n"}],"Base.isready":[{"Tuple{Channel}":"    isready(c::Channel)\n\nDetermine whether a [`Channel`](@ref) has a value stored to it. Returns\nimmediately, does not block.\n\nFor unbuffered channels returns `true` if there are tasks waiting\non a [`put!`](@ref).\n"}],"Base.isinteractive":[{"Tuple{}":"    isinteractive() -> Bool\n\nDetermine whether Julia is running an interactive session.\n"}],"Base.skipchars":[{"Tuple{Any,IO}":"    skipchars(predicate, io::IO; linecomment=nothing)\n\nAdvance the stream `io` such that the next-read character will be the first remaining for\nwhich `predicate` returns `false`. If the keyword argument `linecomment` is specified, all\ncharacters from that character until the start of the next line are ignored.\n\n# Examples\n```jldoctest\njulia> buf = IOBuffer(\"    text\")\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=1, mark=-1)\n\njulia> skipchars(isspace, buf)\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=5, mark=-1)\n\njulia> String(readavailable(buf))\n\"text\"\n```\n"}],"Base.hastypemax":[{"Tuple{Union{Type{Int128}, Type{Int16}, Type{Int32}, Type{Int64}, Type{Int8}, Type{UInt128}, Type{UInt16}, Type{UInt32}, Type{UInt64}, Type{UInt8}}}":"    hastypemax(T::Type) -> Bool\n\nReturn `true` if and only if `typemax(T)` is defined.\n"}],"Base.print":[{"Tuple{IO,Any}":"    print([io::IO], xs...)\n\nWrite to `io` (or to the default output stream [`stdout`](@ref)\nif `io` is not given) a canonical (un-decorated) text representation.\nThe representation used by `print` includes minimal formatting and tries to\navoid Julia-specific details.\n\n`print` falls back to calling `show`, so most types should just define\n`show`. Define `print` if your type has a separate \"plain\" representation.\nFor example, `show` displays strings with quotes, and `print` displays strings\nwithout quotes.\n\n[`string`](@ref) returns the output of `print` as a string.\n\n# Examples\n```jldoctest\njulia> print(\"Hello World!\")\nHello World!\njulia> io = IOBuffer();\n\njulia> print(io, \"Hello\", ' ', :World!)\n\njulia> String(take!(io))\n\"Hello World!\"\n```\n"}],"Base.sortslices":[{"Tuple{AbstractArray}":"    sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort slices of an array `A`. The required keyword argument `dims` must\nbe either an integer or a tuple of integers. It specifies the\ndimension(s) over which the slices are sorted.\n\nE.g., if `A` is a matrix, `dims=1` will sort rows, `dims=2` will sort columns.\nNote that the default comparison function on one dimensional slices sorts\nlexicographically.\n\nFor the remaining keyword arguments, see the documentation of [`sort!`](@ref).\n\n# Examples\n```jldoctest\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows\n3×3 Array{Int64,2}:\n -1   6  4\n  7   3  5\n  9  -2  8\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)->isless(x[2],y[2]))\n3×3 Array{Int64,2}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)\n3×3 Array{Int64,2}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns\n3×3 Array{Int64,2}:\n  3   5  7\n -1  -4  6\n -2   8  9\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))\n3×3 Array{Int64,2}:\n  5   3  7\n -4  -1  6\n  8  -2  9\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)\n3×3 Array{Int64,2}:\n 7   5   3\n 6  -4  -1\n 9   8  -2\n```\n\n# Higher dimensions\n\n`sortslices` extends naturally to higher dimensions. E.g., if `A` is a\na 2x2x2 array, `sortslices(A, dims=3)` will sort slices within the 3rd dimension,\npassing the 2x2 slices `A[:, :, 1]` and `A[:, :, 2]` to the comparison function.\nNote that while there is no default order on higher-dimensional slices, you may\nuse the `by` or `lt` keyword argument to specify such an order.\n\nIf `dims` is a tuple, the order of the dimensions in `dims` is\nrelevant and specifies the linear order of the slices. E.g., if `A` is three\ndimensional and `dims` is `(1, 2)`, the orderings of the first two dimensions\nare re-arranged such such that the slices (of the remaining third dimension) are sorted.\nIf `dims` is `(2, 1)` instead, the same slices will be taken,\nbut the result order will be row-major instead.\n\n# Higher dimensional examples\n```\njulia> A = permutedims(reshape([4 3; 2 1; 'A' 'B'; 'C' 'D'], (2, 2, 2)), (1, 3, 2))\n2×2×2 Array{Any,3}:\n[:, :, 1] =\n 4  3\n 2  1\n\n[:, :, 2] =\n 'A'  'B'\n 'C'  'D'\n\njulia> sortslices(A, dims=(1,2))\n2×2×2 Array{Any,3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 'D'  'B'\n 'C'  'A'\n\njulia> sortslices(A, dims=(2,1))\n2×2×2 Array{Any,3}:\n[:, :, 1] =\n 1  2\n 3  4\n\n[:, :, 2] =\n 'D'  'C'\n 'B'  'A'\n\njulia> sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x->x[1,1])\n1×1×5 Array{Int64,3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 5] =\n 5\n```\n"}],"Base.Csize_t":[{"Union{}":"    Csize_t\n\nEquivalent to the native `size_t` c-type (`UInt`).\n"}],"Base.DenseVecOrMat":[{"Union{}":"    DenseVecOrMat{T}\n\nUnion type of [`DenseVector{T}`](@ref) and [`DenseMatrix{T}`](@ref).\n"}],"Base.@kwdef":[{"Tuple{Any}":"    @kwdef typedef\n\nThis is a helper macro that automatically defines a keyword-based constructor for the type\ndeclared in the expression `typedef`, which must be a `struct` or `mutable struct`\nexpression. The default argument is supplied by declaring fields of the form `field::T =\ndefault` or `field = default`. If no default is provided then the keyword argument becomes\na required keyword argument in the resulting type constructor.\n\nInner constructors can still be defined, but at least one should accept arguments in the\nsame form as the default inner constructor (i.e. one positional argument per field) in\norder to function correctly with the keyword outer constructor.\n\n!!! compat \"Julia 1.1\"\n    `Base.@kwdef` for parametric structs, and structs with supertypes\n    requires at least Julia 1.1.\n\n# Examples\n```jldoctest\njulia> Base.@kwdef struct Foo\n           a::Int = 1         # specified default\n           b::String          # required keyword\n       end\nFoo\n\njulia> Foo(b=\"hi\")\nFoo(1, \"hi\")\n\njulia> Foo()\nERROR: UndefKeywordError: keyword argument b not assigned\nStacktrace:\n[...]\n```\n"}],"Base.@inline":[{"Tuple{Any}":"    @inline\n\nGive a hint to the compiler that this function is worth inlining.\n\nSmall functions typically do not need the `@inline` annotation,\nas the compiler does it automatically. By using `@inline` on bigger functions,\nan extra nudge can be given to the compiler to inline it.\nThis is shown in the following example:\n\n```julia\n@inline function bigfunction(x)\n    #=\n        Function Definition\n    =#\nend\n```\n"}],"Base.mapfoldl":[{"Tuple{Any,Any,Any}":"    mapfoldl(f, op, itr; [init])\n\nLike [`mapreduce`](@ref), but with guaranteed left associativity, as in [`foldl`](@ref).\nIf provided, the keyword argument `init` will be used exactly once. In general, it will be\nnecessary to provide `init` to work with empty collections.\n"}],"Base.securezero!":[{"Union{}":"    securezero!(o)\n\n`securezero!` fills the memory associated with an object `o` with zeros.\nUnlike `fill!(o,0)` and similar code, which might be optimized away by\nthe compiler for objects about to be discarded, the `securezero!` function\nwill always be called.\n"}],"Base.intersect":[{"Tuple{AbstractSet,Any,Vararg{Any,N} where N}":"    intersect(s, itrs...)\n    ∩(s, itrs...)\n\nConstruct the intersection of sets.\nMaintain order with arrays.\n\n# Examples\n```jldoctest\njulia> intersect([1, 2, 3], [3, 4, 5])\n1-element Array{Int64,1}:\n 3\n\njulia> intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])\n2-element Array{Int64,1}:\n 4\n 6\n\njulia> intersect(Set([1, 2]), BitSet([2, 3]))\nSet{Int64} with 1 element:\n  2\n```\n"}],"Base.trylock":[{"Tuple{ReentrantLock}":"    trylock(lock) -> Success (Boolean)\n\nAcquire the lock if it is available,\nand return `true` if successful.\nIf the lock is already locked by a different task/thread,\nreturn `false`.\n\nEach successful `trylock` must be matched by an [`unlock`](@ref).\n"}],"Base.methods":[{"Tuple{Any,Any,Union{Nothing, Module, AbstractArray{Module,N} where N}}":"    methods(f, [types], [module])\n\nReturn the method table for `f`.\n\nIf `types` is specified, return an array of methods whose types match.\nIf `module` is specified, return an array of methods defined in that module.\nA list of modules can also be specified as an array.\n\n!!! compat \"Julia 1.4\"\n    At least Julia 1.4 is required for specifying a module.\n"}],"Base.@timev":[{"Tuple{Any}":"    @timev\n\nThis is a verbose version of the `@time` macro. It first prints the same information as\n`@time`, then any non-zero memory allocation counters, and then returns the value of the\nexpression.\n\nSee also [`@time`](@ref), [`@timed`](@ref), [`@elapsed`](@ref), and\n[`@allocated`](@ref).\n\n```julia-repl\njulia> @timev rand(10^6);\n  0.001006 seconds (7 allocations: 7.630 MiB)\nelapsed time (ns): 1005567\nbytes allocated:   8000256\npool allocs:       6\nmalloc() calls:    1\n```\n"}],"Base.Cuint":[{"Union{}":"    Cuint\n\nEquivalent to the native `unsigned int` c-type ([`UInt32`](@ref)).\n"}],"Base.checkbounds_indices":[{"Tuple{Type{Bool},Tuple,Tuple}":"    checkbounds_indices(Bool, IA, I)\n\nReturn `true` if the \"requested\" indices in the tuple `I` fall within\nthe bounds of the \"permitted\" indices specified by the tuple\n`IA`. This function recursively consumes elements of these tuples,\nusually in a 1-for-1 fashion,\n\n    checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n                                                          checkbounds_indices(Bool, IA, I)\n\nNote that [`checkindex`](@ref) is being used to perform the actual\nbounds-check for a single dimension of the array.\n\nThere are two important exceptions to the 1-1 rule: linear indexing and\nCartesianIndex{N}, both of which may \"consume\" more than one element\nof `IA`.\n\nSee also [`checkbounds`](@ref).\n"}],"Base.hasfield":[{"Union{Tuple{T}, Tuple{Type{T},Symbol}} where T":"    hasfield(T::Type, name::Symbol)\n\nReturn a boolean indicating whether `T` has `name` as one of its own fields.\n\n!!! compat \"Julia 1.2\"\n     This function requires at least Julia 1.2.\n"}],"Base.acquire":[{"Tuple{Base.Semaphore}":"    acquire(s::Semaphore)\n\nWait for one of the `sem_size` permits to be available,\nblocking until one can be acquired.\n"}],"Base.axes":[{"Tuple{Any}":"    axes(A)\n\nReturn the tuple of valid indices for array `A`.\n\n# Examples\n```jldoctest\njulia> A = fill(1, (5,6,7));\n\njulia> axes(A)\n(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))\n```\n"},{"Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Any}} where N where T":"    axes(A, d)\n\nReturn the valid range of indices for array `A` along dimension `d`.\n\nSee also [`size`](@ref), and the manual chapter on [arrays with custom indices](@ref man-custom-indices).\n\n# Examples\n```jldoctest\njulia> A = fill(1, (5,6,7));\n\njulia> axes(A, 2)\nBase.OneTo(6)\n```\n"}],"Base.LogicalIndex":[{"Union{}":"    LogicalIndex(mask)\n\nThe `LogicalIndex` type is a special vector that simply contains all indices I\nwhere `mask[I]` is true. This specialized type does not support indexing\ndirectly as doing so would require O(n) lookup time. `AbstractArray{Bool}` are\nwrapped with `LogicalIndex` upon calling [`to_indices`](@ref).\n"}],"Base.getkey":[{"Union{Tuple{V}, Tuple{K}, Tuple{Dict{K,V},Any,Any}} where V where K":"    getkey(collection, key, default)\n\nReturn the key matching argument `key` if one exists in `collection`, otherwise return `default`.\n\n# Examples\n```jldoctest\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> getkey(D, 'a', 1)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> getkey(D, 'd', 'a')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n```\n"}],"Base.read!":[{"Union{}":"    read!(stream::IO, array::AbstractArray)\n    read!(filename::AbstractString, array::AbstractArray)\n\nRead binary data from an I/O stream or file, filling in `array`.\n"}],"Base.mightalias":[{"Tuple{AbstractArray,AbstractArray}":"    Base.mightalias(A::AbstractArray, B::AbstractArray)\n\nPerform a conservative test to check if arrays `A` and `B` might share the same memory.\n\nBy default, this simply checks if either of the arrays reference the same memory\nregions, as identified by their [`Base.dataids`](@ref).\n"}],"Base.catch_backtrace":[{"Tuple{}":"    catch_backtrace()\n\nGet the backtrace of the current exception, for use within `catch` blocks.\n"}],"Base.evalfile":[{"Union{Tuple{AbstractString}, Tuple{AbstractString,Array{String,1}}}":"    evalfile(path::AbstractString, args::Vector{String}=String[])\n\nLoad the file using [`include`](@ref), evaluate all expressions,\nand return the value of the last one.\n"}],"Base.Channel":[{"Union{}":"    Channel{T=Any}(size::Int=0)\n\nConstructs a `Channel` with an internal buffer that can hold a maximum of `size` objects\nof type `T`.\n[`put!`](@ref) calls on a full channel block until an object is removed with [`take!`](@ref).\n\n`Channel(0)` constructs an unbuffered channel. `put!` blocks until a matching `take!` is called.\nAnd vice-versa.\n\nOther constructors:\n\n* `Channel()`: default constructor, equivalent to `Channel{Any}(0)`\n* `Channel(Inf)`: equivalent to `Channel{Any}(typemax(Int))`\n* `Channel(sz)`: equivalent to `Channel{Any}(sz)`\n\n!!! compat \"Julia 1.3\"\n  The default constructor `Channel()` and default `size=0` were added in Julia 1.3.\n"},{"Union{Tuple{Function}, Tuple{T}, Tuple{Function,Any}} where T":"    Channel{T=Any}(func::Function, size=0; taskref=nothing, spawn=false)\n\nCreate a new task from `func`, bind it to a new channel of type\n`T` and size `size`, and schedule the task, all in a single call.\n\n`func` must accept the bound channel as its only argument.\n\nIf you need a reference to the created task, pass a `Ref{Task}` object via\nthe keyword argument `taskref`.\n\nIf `spawn = true`, the Task created for `func` may be scheduled on another thread\nin parallel, equivalent to creating a task via [`Threads.@spawn`](@ref).\n\nReturn a `Channel`.\n\n# Examples\n```jldoctest\njulia> chnl = Channel() do ch\n           foreach(i -> put!(ch, i), 1:4)\n       end;\n\njulia> typeof(chnl)\nChannel{Any}\n\njulia> for i in chnl\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n```\n\nReferencing the created task:\n\n```jldoctest\njulia> taskref = Ref{Task}();\n\njulia> chnl = Channel(taskref=taskref) do ch\n           println(take!(ch))\n       end;\n\njulia> istaskdone(taskref[])\nfalse\n\njulia> put!(chnl, \"Hello\");\nHello\n\njulia> istaskdone(taskref[])\ntrue\n```\n\n!!! compat \"Julia 1.3\"\n  The `spawn=` parameter was added in Julia 1.3. This constructor was added in Julia 1.3.\n  In earlier versions of Julia, Channel used keyword arguments to set `size` and `T`, but\n  those constructors are deprecated.\n\n```jldoctest\njulia> chnl = Channel{Char}(1, spawn=true) do ch\n           for c in \"hello world\"\n               put!(ch, c)\n           end\n       end\nChannel{Char}(sz_max:1,sz_curr:1)\n\njulia> String(collect(chnl))\n\"hello world\"\n```\n"}],"Base.parent":[{"Tuple{AbstractArray}":"    parent(A)\n\nReturns the \"parent array\" of an array view type (e.g., `SubArray`), or the array itself if\nit is not a view.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> V = view(A, 1:2, :)\n2×2 view(::Array{Int64,2}, 1:2, :) with eltype Int64:\n 1  2\n 3  4\n\njulia> parent(V)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n"}],"Base.Inf16":[{"Union{}":"    Inf16\n\nPositive infinity of type [`Float16`](@ref).\n"}],"Base.catch_stack":[{"Union{Tuple{}, Tuple{Any}}":"    catch_stack(task=current_task(); [inclue_bt=true])\n\nGet the stack of exceptions currently being handled. For nested catch blocks\nthere may be more than one current exception in which case the most recently\nthrown exception is last in the stack. The stack is returned as a Vector of\n`(exception,backtrace)` pairs, or a Vector of exceptions if `include_bt` is\nfalse.\n\nExplicitly passing `task` will return the current exception stack on an\narbitrary task. This is useful for inspecting tasks which have failed due to\nuncaught exceptions.\n\n!!! compat \"Julia 1.1\"\n    This function is experimental in Julia 1.1 and will likely be renamed in a\n    future release (see https://github.com/JuliaLang/julia/pull/29901).\n"}],"Base.VersionNumber":[{"Union{}":"    VersionNumber\n\nVersion number type which follow the specifications of\n[semantic versioning](https://semver.org/), composed of major, minor\nand patch numeric values, followed by pre-release and build\nalpha-numeric annotations. See also [`@v_str`](@ref).\n\n# Examples\n```jldoctest\njulia> VersionNumber(\"1.2.3\")\nv\"1.2.3\"\n\njulia> VersionNumber(\"2.0.1-rc1\")\nv\"2.0.1-rc1\"\n```\n"}],"Base.⊋":[{"Union{}":"    ⊊(a, b) -> Bool\n    ⊋(b, a) -> Bool\n\nDetermines if `a` is a subset of, but not equal to, `b`.\n\n# Examples\n```jldoctest\njulia> (1, 2) ⊊ (1, 2, 3)\ntrue\n\njulia> (1, 2) ⊊ (1, 2)\nfalse\n```\n"}],"Base.fill":[{"Union{}":"    fill(x, dims::Tuple)\n    fill(x, dims...)\n\nCreate an array filled with the value `x`. For example, `fill(1.0, (5,5))` returns a 5×5\narray of floats, with each element initialized to `1.0`.\n\n`dims` may be specified as either a tuple or a sequence of arguments. For example,\nthe common idiom `fill(x)` creates a zero-dimensional array containing the single value `x`.\n\n# Examples\n```jldoctest\njulia> fill(1.0, (5,5))\n5×5 Array{Float64,2}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\njulia> fill(0.5, 1, 2)\n1×2 Array{Float64,2}:\n 0.5  0.5\n\njulia> fill(42)\n0-dimensional Array{Int64,0}:\n42\n```\n\nIf `x` is an object reference, all elements will refer to the same object. `fill(Foo(),\ndims)` will return an array filled with the result of evaluating `Foo()` once.\n"}],"Base.Cintmax_t":[{"Union{}":"    Cintmax_t\n\nEquivalent to the native `intmax_t` c-type ([`Int64`](@ref)).\n"}],"Base.isoverlong":[{"Tuple{AbstractChar}":"    isoverlong(c::AbstractChar) -> Bool\n\nReturn `true` if `c` represents an overlong UTF-8 sequence. Defaults\nto `false` for non-`Char` types.  See also [`decode_overlong`](@ref)\nand [`show_invalid`](@ref).\n"}],"Base.gcd":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Integer":"    gcd(x,y)\n\nGreatest common (positive) divisor (or zero if `x` and `y` are both zero).\nThe arguments may be integer and rational numbers.\n\n!!! compat \"Julia 1.4\"\n    Rational arguments require Julia 1.4 or later.\n\n# Examples\n```jldoctest\njulia> gcd(6,9)\n3\n\njulia> gcd(6,-9)\n3\n```\n"}],"Base.codeunits":[{"Tuple{AbstractString}":"    codeunits(s::AbstractString)\n\nObtain a vector-like object containing the code units of a string.\nReturns a `CodeUnits` wrapper by default, but `codeunits` may optionally be defined\nfor new string types if necessary.\n"}],"Base.flipsign":[{"Tuple{Real,Real}":"    flipsign(x, y)\n\nReturn `x` with its sign flipped if `y` is negative. For example `abs(x) = flipsign(x,x)`.\n\n# Examples\n```jldoctest\njulia> flipsign(5, 3)\n5\n\njulia> flipsign(5, -3)\n-5\n```\n"}],"Base.denominator":[{"Tuple{Integer}":"    denominator(x)\n\nDenominator of the rational representation of `x`.\n\n# Examples\n```jldoctest\njulia> denominator(2//3)\n3\n\njulia> denominator(4)\n1\n```\n"}],"Base.issubset":[{"Union{}":"    issubset(a, b) -> Bool\n    ⊆(a, b) -> Bool\n    ⊇(b, a) -> Bool\n\nDetermine whether every element of `a` is also in `b`, using [`in`](@ref).\n\n# Examples\n```jldoctest\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> [1, 2, 3] ⊆ [1, 2]\nfalse\n\njulia> [1, 2, 3] ⊇ [1, 2]\ntrue\n```\n"}],"Base.divrem":[{"Tuple{Any,Any}":"    divrem(x, y, r::RoundingMode=RoundToZero)\n\nThe quotient and remainder from Euclidean division.\nEquivalent to `(div(x,y,r), rem(x,y,r))`. Equivalently, with the the default\nvalue of `r`, this call is equivalent to `(x÷y, x%y)`.\n\n# Examples\n```jldoctest\njulia> divrem(3,7)\n(0, 3)\n\njulia> divrem(7,3)\n(2, 1)\n```\n"}],"Base.any!":[{"Tuple{Any,Any}":"    any!(r, A)\n\nTest whether any values in `A` along the singleton dimensions of `r` are `true`, and write\nresults to `r`.\n\n# Examples\n```jldoctest\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n 1  0\n 1  0\n\njulia> any!([1; 1], A)\n2-element Array{Int64,1}:\n 1\n 1\n\njulia> any!([1 1], A)\n1×2 Array{Int64,2}:\n 1  0\n```\n"}],"Base.Fix2":[{"Union{}":"    Fix2(f, x)\n\nA type representing a partially-applied version of the two-argument function\n`f`, with the second argument fixed to the value \"x\". In other words,\n`Fix2(f, x)` behaves similarly to `y->f(y, x)`.\n"}],"Base.sum!":[{"Tuple{Any,Any}":"    sum!(r, A)\n\nSum elements of `A` over the singleton dimensions of `r`, and write results to `r`.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> sum!([1; 1], A)\n2-element Array{Int64,1}:\n 3\n 7\n\njulia> sum!([1 1], A)\n1×2 Array{Int64,2}:\n 4  6\n```\n"}],"Base.bitstring":[{"Union{}":"    bitstring(n)\n\nA string giving the literal bit representation of a number.\n\n# Examples\n```jldoctest\njulia> bitstring(4)\n\"0000000000000000000000000000000000000000000000000000000000000100\"\n\njulia> bitstring(2.2)\n\"0100000000000001100110011001100110011001100110011001100110011010\"\n```\n"}],"Base.sprint":[{"Tuple{Function,Vararg{Any,N} where N}":"    sprint(f::Function, args...; context=nothing, sizehint=0)\n\nCall the given function with an I/O stream and the supplied extra arguments.\nEverything written to this I/O stream is returned as a string.\n`context` can be either an [`IOContext`](@ref) whose properties will be used,\nor a `Pair` specifying a property and its value. `sizehint` suggests the capacity\nof the buffer (in bytes).\n\nThe optional keyword argument `context` can be set to `:key=>value` pair\nor an `IO` or [`IOContext`](@ref) object whose attributes are used for the I/O\nstream passed to `f`.  The optional `sizehint` is a suggested size (in bytes)\nto allocate for the buffer used to write the string.\n\n# Examples\n```jldoctest\njulia> sprint(show, 66.66666; context=:compact => true)\n\"66.6667\"\n\njulia> sprint(showerror, BoundsError([1], 100))\n\"BoundsError: attempt to access 1-element Array{Int64,1} at index [100]\"\n```\n"}],"Base.LinRange":[{"Union{}":"    LinRange{T}\n\nA range with `len` linearly spaced elements between its `start` and `stop`.\nThe size of the spacing is controlled by `len`, which must\nbe an `Int`.\n\n# Examples\n```jldoctest\njulia> LinRange(1.5, 5.5, 9)\n9-element LinRange{Float64}:\n 1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5\n```\n"}],"Base.⊇":[{"Union{}":"    issubset(a, b) -> Bool\n    ⊆(a, b) -> Bool\n    ⊇(b, a) -> Bool\n\nDetermine whether every element of `a` is also in `b`, using [`in`](@ref).\n\n# Examples\n```jldoctest\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> [1, 2, 3] ⊆ [1, 2]\nfalse\n\njulia> [1, 2, 3] ⊇ [1, 2]\ntrue\n```\n"}],"Base.NaN64":[{"Union{}":"    NaN, NaN64\n\nA not-a-number value of type [`Float64`](@ref).\n"}],"Base.reduce_first":[{"Tuple{Any,Any}":"    Base.reduce_first(op, x)\n\nThe value to be returned when calling [`reduce`](@ref), [`foldl`](@ref`) or\n[`foldr`](@ref) with reduction `op` over an iterator which contains a single element\n`x`. This value may also used to initialise the recursion, so that `reduce(op, [x, y])`\nmay call `op(reduce_first(op, x), y)`.\n\nThe default is `x` for most types. The main purpose is to ensure type stability, so\nadditional methods should only be defined for cases where `op` gives a result with\ndifferent types than its inputs.\n"}],"Base.step":[{"Tuple{StepRange}":"    step(r)\n\nGet the step size of an [`AbstractRange`](@ref) object.\n\n# Examples\n```jldoctest\njulia> step(1:10)\n1\n\njulia> step(1:2:10)\n2\n\njulia> step(2.5:0.3:10.9)\n0.3\n\njulia> step(range(2.5, stop=10.9, length=85))\n0.1\n```\n"}],"Base.fld":[{"Tuple{Any,Any}":"    fld(x, y)\n\nLargest integer less than or equal to `x/y`. Equivalent to `div(x, y, RoundDown)`.\n\nSee also: [`div`](@ref)\n\n# Examples\n```jldoctest\njulia> fld(7.3,5.5)\n1.0\n```\n"}],"Base.popfirst!":[{"Tuple{Array{T,1} where T}":"    popfirst!(collection) -> item\n\nRemove the first `item` from `collection`.\n\n# Examples\n```jldoctest\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> popfirst!(A)\n1\n\njulia> A\n5-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n```\n"}],"Base.structdiff":[{"Union{Tuple{bn}, Tuple{an}, Tuple{NamedTuple{an,T} where T<:Tuple,Union{Type{NamedTuple{bn,T} where T<:Tuple}, NamedTuple{bn,T} where T<:Tuple}}} where bn where an":"    structdiff(a::NamedTuple{an}, b::Union{NamedTuple{bn},Type{NamedTuple{bn}}}) where {an,bn}\n\nConstruct a copy of named tuple `a`, except with fields that exist in `b` removed.\n`b` can be a named tuple, or a type of the form `NamedTuple{field_names}`.\n"}],"Base.prepend!":[{"Union{}":"    prepend!(a::Vector, items) -> collection\n\nInsert the elements of `items` to the beginning of `a`.\n\n# Examples\n```jldoctest\njulia> prepend!([3],[1,2])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n```\n"}],"Base.promote":[{"Union{}":"    promote(xs...)\n\nConvert all arguments to a common type, and return them all (as a tuple).\nIf no arguments can be converted, an error is raised.\n\n# Examples\n```jldoctest\njulia> promote(Int8(1), Float16(4.5), Float32(4.1))\n(1.0f0, 4.5f0, 4.1f0)\n```\n"}],"Base.mapreduce_first":[{"Tuple{Any,Any,Any}":"    Base.mapreduce_first(f, op, x)\n\nThe value to be returned when calling [`mapreduce`](@ref), [`mapfoldl`](@ref`) or\n[`mapfoldr`](@ref) with map `f` and reduction `op` over an iterator which contains a\nsingle element `x`. This value may also used to initialise the recursion, so that\n`mapreduce(f, op, [x, y])` may call `op(reduce_first(op, f, x), f(y))`.\n\nThe default is `reduce_first(op, f(x))`.\n"}],"Base.hasfastin":[{"Tuple{Type}":"    hasfastin(T)\n\nDetermine whether the computation `x ∈ collection` where `collection::T` can be considered\nas a \"fast\" operation (typically constant or logarithmic complexity).\nThe definition `hasfastin(x) = hasfastin(typeof(x))` is provided for convenience so that instances\ncan be passed instead of types.\nHowever the form that accepts a type argument should be defined for new types.\n"}],"Base.seek":[{"Tuple{IOStream,Integer}":"    seek(s, pos)\n\nSeek a stream to the given position.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> read(io, Char)\n'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n```\n"}],"Base.countlines":[{"Tuple{IO}":"    countlines(io::IO; eol::AbstractChar = '\\n')\n\nRead `io` until the end of the stream/file and count the number of lines. To specify a file\npass the filename as the first argument. EOL markers other than `'\\n'` are supported by\npassing them as the second argument.  The last non-empty line of `io` is counted even if it does not\nend with the EOL, matching the length returned by [`eachline`](@ref) and [`readlines`](@ref).\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\\n\");\n\njulia> countlines(io)\n1\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> countlines(io)\n1\n\njulia> countlines(io, eol = '.')\n0\n```\n"}],"Base.rem":[{"Union{}":"    rem(x, y)\n    %(x, y)\n\nRemainder from Euclidean division, returning a value of the same sign as `x`, and smaller in\nmagnitude than `y`. This value is always exact.\n\n# Examples\n```jldoctest\njulia> x = 15; y = 4;\n\njulia> x % y\n3\n\njulia> x == div(x, y) * y + rem(x, y)\ntrue\n```\n"},{"Tuple{Any,Any,RoundingMode}":"    rem(x, y, r::RoundingMode=RoundToZero)\n\nCompute the remainder of `x` after integer division by `y`, with the quotient rounded\naccording to the rounding mode `r`. In other words, the quantity\n\n    x - y*round(x/y,r)\n\nwithout any intermediate rounding.\n\n- if `r == RoundNearest`, then the result is exact, and in the interval\n  ``[-|y|/2, |y|/2]``. See also [`RoundNearest`](@ref).\n\n- if `r == RoundToZero` (default), then the result is exact, and in the interval\n  ``[0, |y|)`` if `x` is positive, or ``(-|y|, 0]`` otherwise. See also [`RoundToZero`](@ref).\n\n- if `r == RoundDown`, then the result is in the interval ``[0, y)`` if `y` is positive, or\n  ``(y, 0]`` otherwise. The result may not be exact if `x` and `y` have different signs, and\n  `abs(x) < abs(y)`. See also [`RoundDown`](@ref).\n\n- if `r == RoundUp`, then the result is in the interval `(-y,0]` if `y` is positive, or\n  `[0,-y)` otherwise. The result may not be exact if `x` and `y` have the same sign, and\n  `abs(x) < abs(y)`. See also [`RoundUp`](@ref).\n\n"},{"Tuple{Integer,Type{#s662} where #s662<:Integer}":"    rem(x::Integer, T::Type{<:Integer}) -> T\n    mod(x::Integer, T::Type{<:Integer}) -> T\n    %(x::Integer, T::Type{<:Integer}) -> T\n\nFind `y::T` such that `x` ≡ `y` (mod n), where n is the number of integers representable\nin `T`, and `y` is an integer in `[typemin(T),typemax(T)]`.\nIf `T` can represent any integer (e.g. `T == BigInt`), then this operation corresponds to\na conversion to `T`.\n\n# Examples\n```jldoctest\njulia> 129 % Int8\n-127\n```\n"}],"Base.process_running":[{"Tuple{Base.Process}":"    process_running(p::Process)\n\nDetermine whether a process is currently running.\n"}],"Base.SubString":[{"Union{}":"    SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))\n    SubString(s::AbstractString, r::UnitRange{<:Integer})\n\nLike [`getindex`](@ref), but returns a view into the parent string `s`\nwithin range `i:j` or `r` respectively instead of making a copy.\n\n# Examples\n```jldoctest\njulia> SubString(\"abc\", 1, 2)\n\"ab\"\n\njulia> SubString(\"abc\", 1:2)\n\"ab\"\n\njulia> SubString(\"abc\", 2)\n\"bc\"\n```\n"}],"Base.∉":[{"Union{}":"    ∉(item, collection) -> Bool\n    ∌(collection, item) -> Bool\n\nNegation of `∈` and `∋`, i.e. checks that `item` is not in `collection`.\n\n# Examples\n```jldoctest\njulia> 1 ∉ 2:4\ntrue\n\njulia> 1 ∉ 1:3\nfalse\n```\n"}],"Base.Event":[{"Union{}":"    Event()\n\nCreate a level-triggered event source. Tasks that call [`wait`](@ref) on an\n`Event` are suspended and queued until `notify` is called on the `Event`.\nAfter `notify` is called, the `Event` remains in a signaled state and\ntasks will no longer block when waiting for it.\n\n!!! compat \"Julia 1.1\"\n    This functionality requires at least Julia 1.1.\n"}],"Base.leading_ones":[{"Tuple{Integer}":"    leading_ones(x::Integer) -> Integer\n\nNumber of ones leading the binary representation of `x`.\n\n# Examples\n```jldoctest\njulia> leading_ones(UInt32(2 ^ 32 - 2))\n31\n```\n"}],"Base.prod":[{"Tuple{Any}":"    prod(itr)\n\nReturns the product of all elements of a collection.\n\nThe return type is `Int` for signed integers of less than system word size, and\n`UInt` for unsigned integers of less than system word size.  For all other\narguments, a common return type is found to which all arguments are promoted.\n\n# Examples\n```jldoctest\njulia> prod(1:20)\n2432902008176640000\n```\n"},{"Tuple{AbstractArray}":"    prod(A::AbstractArray; dims)\n\nMultiply elements of an array over the given dimensions.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> prod(A, dims=1)\n1×2 Array{Int64,2}:\n 3  8\n\njulia> prod(A, dims=2)\n2×1 Array{Int64,2}:\n  2\n 12\n```\n"},{"Tuple{Any,Any}":"    prod(f, itr)\n\nReturns the product of `f` applied to each element of `itr`.\n\nThe return type is `Int` for signed integers of less than system word size, and\n`UInt` for unsigned integers of less than system word size.  For all other\narguments, a common return type is found to which all arguments are promoted.\n\n# Examples\n```jldoctest\njulia> prod(abs2, [2; 3; 4])\n576\n```\n"}],"Base.float":[{"Tuple{Any}":"    float(x)\n\nConvert a number or array to a floating point data type.\n"},{"Union{Tuple{Type{T}}, Tuple{T}} where T<:Number":"    float(T::Type)\n\nReturn an appropriate type to represent a value of type `T` as a floating point value.\nEquivalent to `typeof(float(zero(T)))`.\n\n# Examples\n```jldoctest\njulia> float(Complex{Int})\nComplex{Float64}\n\njulia> float(Int)\nFloat64\n```\n"}],"Base.isdone":[{"Tuple{Any,Vararg{Any,N} where N}":"    isdone(itr, state...) -> Union{Bool, Missing}\n\nThis function provides a fast-path hint for iterator completion.\nThis is useful for mutable iterators that want to avoid having elements\nconsumed, if they are not going to be exposed to the user (e.g. to check\nfor done-ness in `isempty` or `zip`). Mutable iterators that want to\nopt into this feature should define an isdone method that returns\ntrue/false depending on whether the iterator is done or not. Stateless\niterators need not implement this function. If the result is `missing`,\ncallers may go ahead and compute `iterate(x, state...) === nothing` to\ncompute a definite answer.\n"}],"Base.CyclePadding":[{"Union{}":"    CyclePadding(padding, total_size)\n\nCylces an iterator of `Padding` structs, restarting the padding at `total_size`.\nE.g. if `padding` is all the padding in a struct and `total_size` is the total\naligned size of that array, `CyclePadding` will correspond to the padding in an\ninfinite vector of such structs.\n"}],"Base.@__LINE__":[{"Tuple{}":"    @__LINE__ -> Int\n\nExpand to the line number of the location of the macrocall.\nReturn `0` if the line number could not be determined.\n"}],"Base.⊉":[{"Union{}":"    ⊈(a, b) -> Bool\n    ⊉(b, a) -> Bool\n\nNegation of `⊆` and `⊇`, i.e. checks that `a` is not a subset of `b`.\n\n# Examples\n```jldoctest\njulia> (1, 2) ⊈ (2, 3)\ntrue\n\njulia> (1, 2) ⊈ (1, 2, 3)\nfalse\n```\n"}],"Base._show_nonempty":[{"Tuple{IO,AbstractArray{T,2} where T,String}":"`_show_nonempty(io, X::AbstractMatrix, prefix)` prints matrix X with opening and closing square brackets,\npreceded by `prefix`, supposed to encode the type of the elements.\n"}],"Base.fieldnames":[{"Tuple{DataType}":"    fieldnames(x::DataType)\n\nGet a tuple with the names of the fields of a `DataType`.\n\n# Examples\n```jldoctest\njulia> fieldnames(Rational)\n(:num, :den)\n```\n"}],"Base.to_index":[{"Tuple{Any,Any}":"    to_index(A, i)\n\nConvert index `i` to an `Int` or array of indices to be used as an index into array `A`.\n\nCustom array types may specialize `to_index(::CustomArray, i)` to provide\nspecial indexing behaviors. Note that some index types (like `Colon`) require\nmore context in order to transform them into an array of indices; those get\nconverted in the more complicated `to_indices` function. By default, this\nsimply calls the generic `to_index(i)`. This must return either an `Int` or an\n`AbstractArray` of scalar indices that are supported by `A`.\n"},{"Tuple{Integer}":"    to_index(i)\n\nConvert index `i` to an `Int` or array of `Int`s to be used as an index for all arrays.\n\nCustom index types may specialize `to_index(::CustomIndex)` to provide special\nindexing behaviors. This must return either an `Int` or an `AbstractArray` of\n`Int`s.\n"}],"Base.isconst":[{"Tuple{Module,Symbol}":"    isconst(m::Module, s::Symbol) -> Bool\n\nDetermine whether a global is declared `const` in a given `Module`.\n"}],"Base.AbstractDict":[{"Union{}":"    AbstractDict{K, V}\n\nSupertype for dictionary-like types with keys of type `K` and values of type `V`.\n[`Dict`](@ref), [`IdDict`](@ref) and other types are subtypes of this.\nAn `AbstractDict{K, V}` should be an iterator of `Pair{K, V}`.\n"}],"Base.atreplinit":[{"Tuple{Function}":"    atreplinit(f)\n\nRegister a one-argument function to be called before the REPL interface is initialized in\ninteractive sessions; this is useful to customize the interface. The argument of `f` is the\nREPL object. This function should be called from within the `.julia/config/startup.jl`\ninitialization file.\n"}],"Base.symdiff!":[{"Tuple{AbstractSet,Vararg{Any,N} where N}":"    symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nConstruct the symmetric difference of the passed in sets, and overwrite `s` with the result.\nWhen `s` is an array, the order is maintained.\nNote that in this case the multiplicity of elements matters.\n"}],"Base.SubstitutionString":[{"Union{}":"    SubstitutionString(substr)\n\nStores the given string `substr` as a `SubstitutionString`, for use in regular expression\nsubstitutions. Most commonly constructed using the [`@s_str`](@ref) macro.\n\n```jldoctest\njulia> SubstitutionString(\"Hello \\\\g<name>, it's \\\\1\")\ns\"Hello \\\\g<name>, it's \\\\1\"\n\njulia> subst = s\"Hello \\g<name>, it's \\1\"\ns\"Hello \\\\g<name>, it's \\\\1\"\n\njulia> typeof(subst)\nSubstitutionString{String}\n\n```\n\n"}],"Base.fieldname":[{"Tuple{DataType,Integer}":"    fieldname(x::DataType, i::Integer)\n\nGet the name of field `i` of a `DataType`.\n\n# Examples\n```jldoctest\njulia> fieldname(Rational, 1)\n:num\n\njulia> fieldname(Rational, 2)\n:den\n```\n"}],"Base.@nospecialize":[{"Tuple":"    @nospecialize\n\nApplied to a function argument name, hints to the compiler that the method\nshould not be specialized for different types of that argument,\nbut instead to use precisely the declared type for each argument.\nThis is only a hint for avoiding excess code generation.\nCan be applied to an argument within a formal argument list,\nor in the function body.\nWhen applied to an argument, the macro must wrap the entire argument expression.\nWhen used in a function body, the macro must occur in statement position and\nbefore any code.\n\nWhen used without arguments, it applies to all arguments of the parent scope.\nIn local scope, this means all arguments of the containing function.\nIn global (top-level) scope, this means all methods subsequently defined in the current module.\n\nSpecialization can reset back to the default by using [`@specialize`](@ref).\n\n```julia\nfunction example_function(@nospecialize x)\n    ...\nend\n\nfunction example_function(@nospecialize(x = 1), y)\n    ...\nend\n\nfunction example_function(x, y, z)\n    @nospecialize x y\n    ...\nend\n\n@nospecialize\nf(y) = [x for x in y]\n@specialize\n```\n"}],"Base.trailing_zeros":[{"Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}":"    trailing_zeros(x::Integer) -> Integer\n\nNumber of zeros trailing the binary representation of `x`.\n\n# Examples\n```jldoctest\njulia> trailing_zeros(2)\n1\n```\n"}],"Base.signed":[{"Tuple{Any}":"    signed(x)\n\nConvert a number to a signed integer. If the argument is unsigned, it is reinterpreted as\nsigned without checking for overflow.\n"}],"Base.IndexLinear":[{"Union{}":"    IndexLinear()\n\nSubtype of [`IndexStyle`](@ref) used to describe arrays which\nare optimally indexed by one linear index.\n\nA linear indexing style uses one integer index to describe the position in the array\n(even if it's a multidimensional array) and column-major\nordering is used to efficiently access the elements. This means that\nrequesting [`eachindex`](@ref) from an array that is `IndexLinear` will return\na simple one-dimensional range, even if it is multidimensional.\n\nA custom array that reports its `IndexStyle` as `IndexLinear` only needs\nto implement indexing (and indexed assignment) with a single `Int` index;\nall other indexing expressions — including multidimensional accesses — will\nbe recomputed to the linear index.  For example, if `A` were a `2×3` custom\nmatrix with linear indexing, and we referenced `A[1, 3]`, this would be\nrecomputed to the equivalent linear index and call `A[5]` since `2*1 + 3 = 5`.\n\nSee also [`IndexCartesian`](@ref).\n"}],"Base.zeros":[{"Union{}":"    zeros([T=Float64,] dims::Tuple)\n    zeros([T=Float64,] dims...)\n\nCreate an `Array`, with element type `T`, of all zeros with size specified by `dims`.\nSee also [`fill`](@ref), [`ones`](@ref).\n\n# Examples\n```jldoctest\njulia> zeros(1)\n1-element Array{Float64,1}:\n 0.0\n\njulia> zeros(Int8, 2, 3)\n2×3 Array{Int8,2}:\n 0  0  0\n 0  0  0\n```\n"}],"Base.@__MODULE__":[{"Tuple{}":"    @__MODULE__ -> Module\n\nGet the `Module` of the toplevel eval,\nwhich is the `Module` code is currently being read from.\n"}],"Base.vec":[{"Tuple{AbstractArray}":"    vec(a::AbstractArray) -> AbstractVector\n\nReshape the array `a` as a one-dimensional column vector. Return `a` if it is\nalready an `AbstractVector`. The resulting array\nshares the same underlying data as `a`, so it will only be mutable if `a` is\nmutable, in which case modifying one will also modify the other.\n\n# Examples\n```jldoctest\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> vec(a)\n6-element Array{Int64,1}:\n 1\n 4\n 2\n 5\n 3\n 6\n\njulia> vec(1:3)\n1:3\n```\n\nSee also [`reshape`](@ref).\n"}],"Base.collect":[{"Tuple{Any}":"    collect(collection)\n\nReturn an `Array` of all items in a collection or iterator. For dictionaries, returns\n`Pair{KeyType, ValType}`. If the argument is array-like or is an iterator with the\n[`HasShape`](@ref IteratorSize) trait, the result will have the same shape\nand number of dimensions as the argument.\n\n# Examples\n```jldoctest\njulia> collect(1:2:13)\n7-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n 13\n```\n"},{"Union{Tuple{T}, Tuple{Type{T},Any}} where T":"    collect(element_type, collection)\n\nReturn an `Array` with the given element type of all items in a collection or iterable.\nThe result has the same shape and number of dimensions as `collection`.\n\n# Examples\n```jldoctest\njulia> collect(Float64, 1:2:5)\n3-element Array{Float64,1}:\n 1.0\n 3.0\n 5.0\n```\n"}],"Base.conj":[{"Tuple{Complex}":"    conj(z)\n\nCompute the complex conjugate of a complex number `z`.\n\n# Examples\n```jldoctest\njulia> conj(1 + 3im)\n1 - 3im\n```\n"}],"Base.!==":[{"Tuple{Any,Any}":"    !==(x, y)\n    ≢(x,y)\n\nAlways gives the opposite answer as [`===`](@ref).\n\n# Examples\n```jldoctest\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a ≢ b\ntrue\n\njulia> a ≢ a\nfalse\n```\n"}],"Base.readline":[{"Tuple{AbstractString}":"    readline(io::IO=stdin; keep::Bool=false)\n    readline(filename::AbstractString; keep::Bool=false)\n\nRead a single line of text from the given I/O stream or file (defaults to `stdin`).\nWhen reading from a file, the text is assumed to be encoded in UTF-8. Lines in the\ninput end with `'\\n'` or `\"\\r\\n\"` or the end of an input stream. When `keep` is\nfalse (as it is by default), these trailing newline characters are removed from the\nline before it is returned. When `keep` is true, they are returned as part of the\nline.\n\n# Examples\n```jldoctest\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readline(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\"\n\njulia> readline(\"my_file.txt\", keep=true)\n\"JuliaLang is a GitHub organization.\\n\"\n\njulia> rm(\"my_file.txt\")\n```\n"}],"Base.something":[{"Union{}":"    something(x, y...)\n\nReturn the first value in the arguments which is not equal to [`nothing`](@ref),\nif any. Otherwise throw an error.\nArguments of type [`Some`](@ref) are unwrapped.\n\nSee also [`coalesce`](@ref).\n\n# Examples\n```jldoctest\njulia> something(nothing, 1)\n1\n\njulia> something(Some(1), nothing)\n1\n\njulia> something(missing, nothing)\nmissing\n\njulia> something(nothing, nothing)\nERROR: ArgumentError: No value arguments present\n```\n"}],"Base.IOBuffer":[{"Tuple{String}":"    IOBuffer(string::String)\n\nCreate a read-only `IOBuffer` on the data underlying the given string.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"Haho\");\n\njulia> String(take!(io))\n\"Haho\"\n\njulia> String(take!(io))\n\"Haho\"\n```\n"},{"Tuple{AbstractArray{UInt8,1}}":"    IOBuffer([data::AbstractVector{UInt8}]; keywords...) -> IOBuffer\n\nCreate an in-memory I/O stream, which may optionally operate on a pre-existing array.\n\nIt may take optional keyword arguments:\n- `read`, `write`, `append`: restricts operations to the buffer; see `open` for details.\n- `truncate`: truncates the buffer size to zero length.\n- `maxsize`: specifies a size beyond which the buffer may not be grown.\n- `sizehint`: suggests a capacity of the buffer (`data` must implement `sizehint!(data, size)`).\n\nWhen `data` is not given, the buffer will be both readable and writable by default.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> io = IOBuffer(b\"JuliaLang is a GitHub organization.\")\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35, maxsize=Inf, ptr=1, mark=-1)\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization.\"\n\njulia> write(io, \"This isn't writable.\")\nERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable\n\njulia> io = IOBuffer(UInt8[], read=true, write=true, maxsize=34)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=34, ptr=1, mark=-1)\n\njulia> write(io, \"JuliaLang is a GitHub organization.\")\n34\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization\"\n\njulia> length(read(IOBuffer(b\"data\", read=true, truncate=false)))\n4\n\njulia> length(read(IOBuffer(b\"data\", read=true, truncate=true)))\n0\n```\n"}],"Base.AlwaysLockedST":[{"Union{}":"    AlwaysLockedST\n\nThis struct does not implement a real lock, but instead\npretends to be always locked on the original thread it was allocated on,\nand simply ignores all other interactions.\nIt also does not synchronize tasks; for that use a real lock such as [`RecursiveLock`](@ref).\nThis can be used in the place of a real lock to, instead, simply and cheaply assert\nthat the operation is only occurring on a single cooperatively-scheduled thread.\nIt is thus functionally equivalent to allocating a real, recursive, task-unaware lock\nimmediately calling `lock` on it, and then never calling a matching `unlock`,\nexcept that calling `lock` from another thread will throw a concurrency violation exception.\n"}],"Base.replace_with_centered_mark":[{"Tuple{AbstractString}":"Unexported convenience function used in body of `replace_in_print_matrix`\nmethods. By default returns a string of the same width as original with a\ncentered cdot, used in printing of structural zeros of structured matrices.\nAccept keyword args `c` for alternate single character marker.\n"}],"Base.reinterpret":[{"Union{Tuple{T}, Tuple{Type{T},Any}} where T":"    reinterpret(type, A)\n\nChange the type-interpretation of a block of memory.\nFor arrays, this constructs a view of the array with the same binary data as the given\narray, but with the specified element type.\nFor example,\n`reinterpret(Float32, UInt32(7))` interprets the 4 bytes corresponding to `UInt32(7)` as a\n[`Float32`](@ref).\n\n# Examples\n```jldoctest\njulia> reinterpret(Float32, UInt32(7))\n1.0f-44\n\njulia> reinterpret(Float32, UInt32[1 2 3 4 5])\n1×5 reinterpret(Float32, ::Array{UInt32,2}):\n 1.0f-45  3.0f-45  4.0f-45  6.0f-45  7.0f-45\n```\n"}],"Base.signbit":[{"Tuple{Real}":"    signbit(x)\n\nReturns `true` if the value of the sign of `x` is negative, otherwise `false`.\n\n# Examples\n```jldoctest\njulia> signbit(-4)\ntrue\n\njulia> signbit(5)\nfalse\n\njulia> signbit(5.5)\nfalse\n\njulia> signbit(-4.1)\ntrue\n```\n"}],"Base.invmod":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Integer":"    invmod(x,m)\n\nTake the inverse of `x` modulo `m`: `y` such that ``x y = 1 \\pmod m``,\nwith ``div(x,y) = 0``. This is undefined for ``m = 0``, or if\n``gcd(x,m) \\neq 1``.\n\n# Examples\n```jldoctest\njulia> invmod(2,5)\n3\n\njulia> invmod(2,3)\n2\n\njulia> invmod(5,6)\n5\n```\n"}],"Base.PipeBuffer":[{"Union{Tuple{}, Tuple{Array{UInt8,1}}}":"    PipeBuffer(data::Vector{UInt8}=UInt8[]; maxsize::Integer = typemax(Int))\n\nAn [`IOBuffer`](@ref) that allows reading and performs writes by appending.\nSeeking and truncating are not supported.\nSee [`IOBuffer`](@ref) for the available constructors.\nIf `data` is given, creates a `PipeBuffer` to operate on a data vector,\noptionally specifying a size beyond which the underlying `Array` may not be grown.\n"}],"Base.map":[{"Tuple{Any,Any}":"    map(f, c...) -> collection\n\nTransform collection `c` by applying `f` to each element. For multiple collection arguments,\napply `f` elementwise.\n\nSee also: [`mapslices`](@ref)\n\n# Examples\n```jldoctest\njulia> map(x -> x * 2, [1, 2, 3])\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> map(+, [1, 2, 3], [10, 20, 30])\n3-element Array{Int64,1}:\n 11\n 22\n 33\n```\n"}],"Base.all!":[{"Tuple{Any,Any}":"    all!(r, A)\n\nTest whether all values in `A` along the singleton dimensions of `r` are `true`, and write results to `r`.\n\n# Examples\n```jldoctest\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n 1  0\n 1  0\n\njulia> all!([1; 1], A)\n2-element Array{Int64,1}:\n 0\n 0\n\njulia> all!([1 1], A)\n1×2 Array{Int64,2}:\n 1  0\n```\n"}],"Base.gc_live_bytes":[{"Tuple{}":"    Base.gc_live_bytes()\n\nReturn the total size (in bytes) of objects currently in memory.\nThis is computed as the total size of live objects after\nthe last garbage collection, plus the number of bytes allocated\nsince then.\n"}],"Base.ndims":[{"Union{Tuple{AbstractArray{T,N}}, Tuple{N}, Tuple{T}} where N where T":"    ndims(A::AbstractArray) -> Integer\n\nReturn the number of dimensions of `A`.\n\n# Examples\n```jldoctest\njulia> A = fill(1, (3,4,5));\n\njulia> ndims(A)\n3\n```\n"}],"Base.precision":[{"Union{}":"    precision(num::AbstractFloat)\n\nGet the precision of a floating point number, as defined by the effective number of bits in\nthe mantissa.\n"}],"Base.pointer_from_objref":[{"Tuple{Any}":"    pointer_from_objref(x)\n\nGet the memory address of a Julia object as a `Ptr`. The existence of the resulting `Ptr`\nwill not protect the object from garbage collection, so you must ensure that the object\nremains referenced for the whole time that the `Ptr` will be used.\n\nThis function may not be called on immutable objects, since they do not have\nstable memory addresses.\n\nSee also: [`unsafe_pointer_to_objref`](@ref).\n"}],"Base.@goto":[{"Tuple{Symbol}":"    @goto name\n\n`@goto name` unconditionally jumps to the statement at the location [`@label name`](@ref).\n\n`@label` and `@goto` cannot create jumps to different top-level statements. Attempts cause an\nerror. To still use `@goto`, enclose the `@label` and `@goto` in a block.\n"}],"Base.front":[{"Tuple{Tuple}":"    front(x::Tuple)::Tuple\n\nReturn a `Tuple` consisting of all but the last component of `x`.\n\n# Examples\n```jldoctest\njulia> Base.front((1,2,3))\n(1, 2)\n\njulia> Base.front(())\nERROR: ArgumentError: Cannot call front on an empty tuple.\n```\n"}],"Base.maximum!":[{"Tuple{Any,Any}":"    maximum!(r, A)\n\nCompute the maximum value of `A` over the singleton dimensions of `r`, and write results to `r`.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> maximum!([1; 1], A)\n2-element Array{Int64,1}:\n 2\n 4\n\njulia> maximum!([1 1], A)\n1×2 Array{Int64,2}:\n 3  4\n```\n"}],"Base.copymutable":[{"Tuple{AbstractArray}":"    copymutable(a)\n\nMake a mutable copy of an array or iterable `a`.  For `a::Array`,\nthis is equivalent to `copy(a)`, but for other array types it may\ndiffer depending on the type of `similar(a)`.  For generic iterables\nthis is equivalent to `collect(a)`.\n\n# Examples\n```jldoctest\njulia> tup = (1, 2, 3)\n(1, 2, 3)\n\njulia> Base.copymutable(tup)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n```\n"}],"Base.@locals":[{"Tuple{}":"    @locals()\n\nConstruct a dictionary of the names (as symbols) and values of all local\nvariables defined as of the call site.\n\n!!! compat \"Julia 1.1\"\n    This macro requires at least Julia 1.1.\n\n# Examples\n```jldoctest\njulia> let x = 1, y = 2\n           Base.@locals\n       end\nDict{Symbol,Any} with 2 entries:\n  :y => 2\n  :x => 1\n\njulia> function f(x)\n           local y\n           show(Base.@locals); println()\n           for i = 1:1\n               show(Base.@locals); println()\n           end\n           y = 2\n           show(Base.@locals); println()\n           nothing\n       end;\n\njulia> f(42)\nDict{Symbol,Any}(:x => 42)\nDict{Symbol,Any}(:i => 1,:x => 42)\nDict{Symbol,Any}(:y => 2,:x => 42)\n```\n"}],"Base.\\":[{"Tuple{Any,Any}":"    \\(x, y)\n\nLeft division operator: multiplication of `y` by the inverse of `x` on the left. Gives\nfloating-point results for integer arguments.\n\n# Examples\n```jldoctest\njulia> 3 \\ 6\n2.0\n\njulia> inv(3) * 6\n2.0\n\njulia> A = [4 3; 2 1]; x = [5, 6];\n\njulia> A \\ x\n2-element Array{Float64,1}:\n  6.5\n -7.0\n\njulia> inv(A) * x\n2-element Array{Float64,1}:\n  6.5\n -7.0\n```\n"}],"Base.AbstractVecOrMat":[{"Union{}":"    AbstractVecOrMat{T}\n\nUnion type of [`AbstractVector{T}`](@ref) and [`AbstractMatrix{T}`](@ref).\n"}],"Base.fieldindex":[{"Union{Tuple{DataType,Symbol}, Tuple{DataType,Symbol,Bool}}":"    Base.fieldindex(T, name::Symbol, err:Bool=true)\n\nGet the index of a named field, throwing an error if the field does not exist (when err==true)\nor returning 0 (when err==false).\n\n# Examples\n```jldoctest\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> Base.fieldindex(Foo, :z)\nERROR: type Foo has no field z\nStacktrace:\n[...]\n\njulia> Base.fieldindex(Foo, :z, false)\n0\n```\n"}],"Base.bswap":[{"Tuple{Union{Int8, UInt8}}":"    bswap(n)\n\nReverse the byte order of `n`.\n\n(See also [`ntoh`](@ref) and [`hton`](@ref) to convert between the current native byte order and big-endian order.)\n\n# Examples\n```jldoctest\njulia> a = bswap(0x10203040)\n0x40302010\n\njulia> bswap(a)\n0x10203040\n\njulia> string(1, base = 2)\n\"1\"\n\njulia> string(bswap(1), base = 2)\n\"100000000000000000000000000000000000000000000000000000000\"\n```\n"}],"Base.Cdouble":[{"Union{}":"    Cdouble\n\nEquivalent to the native `double` c-type ([`Float64`](@ref)).\n"}],"Base.@deprecate":[{"Union{Tuple{Any,Any}, Tuple{Any,Any,Any}}":"    @deprecate old new [ex=true]\n\nThe first argument `old` is the signature of the deprecated method, the second one\n`new` is the call which replaces it. `@deprecate` exports `old` unless the optional\nthird argument is `false`.\n\n# Examples\n```jldoctest\njulia> @deprecate old(x) new(x)\nold (generic function with 1 method)\n\njulia> @deprecate old(x) new(x) false\nold (generic function with 1 method)\n```\n"}],"Base.DenseMatrix":[{"Union{}":"    DenseMatrix{T}\n\nTwo-dimensional [`DenseArray`](@ref) with elements of type `T`. Alias for `DenseArray{T,2}`.\n"}],"Base.propertynames":[{"Tuple{Any}":"    propertynames(x, private=false)\n\nGet a tuple or a vector of the properties (`x.property`) of an object `x`.\nThis is typically the same as [`fieldnames(typeof(x))`](@ref), but types\nthat overload [`getproperty`](@ref) should generally overload `propertynames`\nas well to get the properties of an instance of the type.\n\n`propertynames(x)` may return only \"public\" property names that are part\nof the documented interface of `x`.   If you want it to also return \"private\"\nfieldnames intended for internal use, pass `true` for the optional second argument.\nREPL tab completion on `x.` shows only the `private=false` properties.\n"}],"Base.dropdims":[{"Tuple{Any}":"    dropdims(A; dims)\n\nRemove the dimensions specified by `dims` from array `A`.\nElements of `dims` must be unique and within the range `1:ndims(A)`.\n`size(A,i)` must equal 1 for all `i` in `dims`.\n\n# Examples\n```jldoctest\njulia> a = reshape(Vector(1:4),(2,2,1,1))\n2×2×1×1 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\njulia> dropdims(a; dims=3)\n2×2×1 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 2  4\n```\n"}],"Base.@pure":[{"Tuple{Any}":"    @pure ex\n    @pure(ex)\n\n`@pure` gives the compiler a hint for the definition of a pure function,\nhelping for type inference.\n\nA pure function can only depend on immutable information.\nThis also means a `@pure` function cannot use any global mutable state, including\ngeneric functions. Calls to generic functions depend on method tables which are\nmutable global state.\nUse with caution, incorrect `@pure` annotation of a function may introduce\nhard to identify bugs. Double check for calls to generic functions.\nThis macro is intended for internal compiler use and may be subject to changes.\n"}],"Base.fd":[{"Tuple{IOStream}":"    fd(stream)\n\nReturn the file descriptor backing the stream or file. Note that this function only applies\nto synchronous `File`'s and `IOStream`'s not to any of the asynchronous streams.\n"}],"Base.unsafe_wrap":[{"Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T":"    unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)\n\nWrap a Julia `Array` object around the data at the address given by `pointer`,\nwithout making a copy.  The pointer element type `T` determines the array\nelement type. `dims` is either an integer (for a 1d array) or a tuple of the array dimensions.\n`own` optionally specifies whether Julia should take ownership of the memory,\ncalling `free` on the pointer when the array is no longer referenced.\n\nThis function is labeled \"unsafe\" because it will crash if `pointer` is not\na valid memory address to data of the requested length.\n"}],"Base.splat":[{"Tuple{Any}":"    splat(f)\n\nDefined as\n```julia\n    splat(f) = args->f(args...)\n```\ni.e. given a function returns a new function that takes one argument and splats\nits argument into the original function. This is useful as an adaptor to pass\na multi-argument function in a context that expects a single argument, but\npasses a tuple as that single argument.\n\n# Example usage:\n```jldoctest\njulia> map(Base.splat(+), zip(1:3,4:6))\n3-element Array{Int64,1}:\n 5\n 7\n 9\n```\n"}],"Base.readavailable":[{"Union{}":"    readavailable(stream)\n\nRead all available data on the stream, blocking the task only if no data is available. The\nresult is a `Vector{UInt8,1}`.\n"}],"Base.missing":[{"Union{}":"    missing\n\nThe singleton instance of type [`Missing`](@ref) representing a missing value.\n"}],"Base.issubnormal":[{"Union{Tuple{T}, Tuple{T}} where T<:Union{Float16, Float32, Float64}":"    issubnormal(f) -> Bool\n\nTest whether a floating point number is subnormal.\n"}],"Base.@view":[{"Tuple{Any}":"    @view A[inds...]\n\nCreates a `SubArray` from an indexing expression. This can only be applied directly to a\nreference expression (e.g. `@view A[1,2:end]`), and should *not* be used as the target of\nan assignment (e.g. `@view(A[1,2:end]) = ...`).  See also [`@views`](@ref)\nto switch an entire block of code to use views for slicing.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = @view A[:, 1]\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\n 0\n 0\n\njulia> A\n2×2 Array{Int64,2}:\n 0  2\n 0  4\n```\n"}],"Base.seekend":[{"Tuple{IOStream}":"    seekend(s)\n\nSeek a stream to its end.\n"}],"Base.prevind":[{"Tuple{AbstractString,Integer,Integer}":"    prevind(str::AbstractString, i::Integer, n::Integer=1) -> Int\n\n* Case `n == 1`\n\n  If `i` is in bounds in `s` return the index of the start of the character whose\n  encoding starts before index `i`. In other words, if `i` is the start of a\n  character, return the start of the previous character; if `i` is not the start\n  of a character, rewind until the start of a character and return that index.\n  If `i` is equal to `1` return `0`.\n  If `i` is equal to `ncodeunits(str)+1` return `lastindex(str)`.\n  Otherwise throw `BoundsError`.\n\n* Case `n > 1`\n\n  Behaves like applying `n` times `prevind` for `n==1`. The only difference\n  is that if `n` is so large that applying `prevind` would reach `0` then each remaining\n  iteration decreases the returned value by `1`.\n  This means that in this case `prevind` can return a negative value.\n\n* Case `n == 0`\n\n  Return `i` only if `i` is a valid index in `str` or is equal to `ncodeunits(str)+1`.\n  Otherwise `StringIndexError` or `BoundsError` is thrown.\n\n# Examples\n```jldoctest\njulia> prevind(\"α\", 3)\n1\n\njulia> prevind(\"α\", 1)\n0\n\njulia> prevind(\"α\", 0)\nERROR: BoundsError: attempt to access String\n  at index [0]\n[...]\n\njulia> prevind(\"α\", 2, 2)\n0\n\njulia> prevind(\"α\", 2, 3)\n-1\n```\n"}],"Base.windowserror":[{"Tuple{Any,Bool}":"    windowserror(sysfunc[, code::UInt32=Libc.GetLastError()])\n    windowserror(sysfunc, iftrue::Bool)\n\nLike [`systemerror`](@ref), but for Windows API functions that use [`GetLastError`](@ref Base.Libc.GetLastError) to\nreturn an error code instead of setting [`errno`](@ref Base.Libc.errno).\n"}],"Base.finalizer":[{"Tuple{Any,Any}":"    finalizer(f, x)\n\nRegister a function `f(x)` to be called when there are no program-accessible references to\n`x`, and return `x`. The type of `x` must be a `mutable struct`, otherwise the behavior of\nthis function is unpredictable.\n\n`f` must not cause a task switch, which excludes most I/O operations such as `println`.\n`@schedule println(\"message\")` or `ccall(:jl_, Cvoid, (Any,), \"message\")` may be helpful for\ndebugging purposes.\n"}],"Base.DEPOT_PATH":[{"Union{}":"    DEPOT_PATH\n\nA stack of \"depot\" locations where the package manager, as well as Julia's code\nloading mechanisms, look for package registries, installed packages, named\nenvironments, repo clones, cached compiled package images, and configuration\nfiles. By default it includes:\n\n1. `~/.julia` where `~` is the user home as appropriate on the system;\n2. an architecture-specific shared system directory, e.g. `/usr/local/share/julia`;\n3. an architecture-independent shared system directory, e.g. `/usr/share/julia`.\n\nSo `DEPOT_PATH` might be:\n```julia\n[joinpath(homedir(), \".julia\"), \"/usr/local/share/julia\", \"/usr/share/julia\"]\n```\nThe first entry is the \"user depot\" and should be writable by and owned by the\ncurrent user. The user depot is where: registries are cloned, new package versions\nare installed, named environments are created and updated, package repos are cloned,\nnewly compiled package image files are saved, log files are written, development\npackages are checked out by default, and global configuration data is saved. Later\nentries in the depot path are treated as read-only and are appropriate for\nregistries, packages, etc. installed and managed by system administrators.\n\n`DEPOT_PATH` is populated based on the [`JULIA_DEPOT_PATH`](@ref JULIA_DEPOT_PATH)\nenvironment variable if set.\n\nSee also:\n[`JULIA_DEPOT_PATH`](@ref JULIA_DEPOT_PATH), and\n[Code Loading](@ref Code-Loading).\n"}],"Base.findall":[{"Tuple{Any}":"    findall(A)\n\nReturn a vector `I` of the `true` indices or keys of `A`.\nIf there are no such elements of `A`, return an empty array.\nTo search for other kinds of values, pass a predicate as the first argument.\n\nIndices or keys are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [true, false, false, true]\n4-element Array{Bool,1}:\n 1\n 0\n 0\n 1\n\njulia> findall(A)\n2-element Array{Int64,1}:\n 1\n 4\n\njulia> A = [true false; false true]\n2×2 Array{Bool,2}:\n 1  0\n 0  1\n\njulia> findall(A)\n2-element Array{CartesianIndex{2},1}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 2)\n\njulia> findall(falses(3))\n0-element Array{Int64,1}\n```\n"},{"Tuple{Union{Regex, AbstractString},AbstractString}":"    findall(\n        pattern::Union{AbstractString,Regex},\n        string::AbstractString;\n        overlap::Bool = false,\n    )\n\nReturn a `Vector{UnitRange{Int}}` of all the matches for `pattern` in `string`.\nEach element of the returned vector is a range of indices where the\nmatching sequence is found, like the return value of [`findnext`](@ref).\n\nIf `overlap=true`, the matching sequences are allowed to overlap indices in the\noriginal string, otherwise they must be from disjoint character ranges.\n"},{"Tuple{Function,Any}":"    findall(f::Function, A)\n\nReturn a vector `I` of the indices or keys of `A` where `f(A[I])` returns `true`.\nIf there are no such elements of `A`, return an empty array.\n\nIndices or keys are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> x = [1, 3, 4]\n3-element Array{Int64,1}:\n 1\n 3\n 4\n\njulia> findall(isodd, x)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> A = [1 2 0; 3 4 0]\n2×3 Array{Int64,2}:\n 1  2  0\n 3  4  0\njulia> findall(isodd, A)\n2-element Array{CartesianIndex{2},1}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n\njulia> findall(!iszero, A)\n4-element Array{CartesianIndex{2},1}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\njulia> d = Dict(:A => 10, :B => -1, :C => 0)\nDict{Symbol,Int64} with 3 entries:\n  :A => 10\n  :B => -1\n  :C => 0\n\njulia> findall(x -> x >= 0, d)\n2-element Array{Symbol,1}:\n :A\n :C\n\n```\n"}],"Base.TaskFailedException":[{"Union{}":"    TaskFailedException\n\nThis exception is thrown by a `wait(t)` call when task `t` fails.\n`TaskFailedException` wraps the failed task `t`.\n"}],"Base.AsyncGenerator":[{"Union{}":"    AsyncGenerator(f, c...; ntasks=0, batch_size=nothing) -> iterator\n\nApply `f` to each element of `c` using at most `ntasks` asynchronous tasks.\n\nKeyword args `ntasks` and `batch_size` have the same behavior as in\n[`asyncmap`](@ref). If `batch_size` is specified, `f` must\nbe a function which operates on an array of argument tuples.\n\n!!! note\n    `collect(AsyncGenerator(f, c...; ntasks=1))` is equivalent to\n    `map(f, c...)`.\n"}],"Base.cumprod":[{"Tuple{AbstractArray}":"    cumprod(A; dims::Integer)\n\nCumulative product along the dimension `dim`. See also\n[`cumprod!`](@ref) to use a preallocated output array, both for performance and\nto control the precision of the output (e.g. to avoid overflow).\n\n# Examples\n```jldoctest\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> cumprod(a, dims=1)\n2×3 Array{Int64,2}:\n 1   2   3\n 4  10  18\n\njulia> cumprod(a, dims=2)\n2×3 Array{Int64,2}:\n 1   2    6\n 4  20  120\n```\n"},{"Tuple{AbstractArray{T,1} where T}":"    cumprod(x::AbstractVector)\n\nCumulative product of a vector. See also\n[`cumprod!`](@ref) to use a preallocated output array, both for performance and\nto control the precision of the output (e.g. to avoid overflow).\n\n# Examples\n```jldoctest\njulia> cumprod(fill(1//2, 3))\n3-element Array{Rational{Int64},1}:\n 1//2\n 1//4\n 1//8\n\njulia> cumprod([fill(1//3, 2, 2) for i in 1:3])\n3-element Array{Array{Rational{Int64},2},1}:\n [1//3 1//3; 1//3 1//3]\n [2//9 2//9; 2//9 2//9]\n [4//27 4//27; 4//27 4//27]\n```\n"}],"Base.@raw_str":[{"Tuple{Any}":"    @raw_str -> String\n\nCreate a raw string without interpolation and unescaping.\nThe exception is that quotation marks still must be escaped. Backslashes\nescape both quotation marks and other backslashes, but only when a sequence\nof backslashes precedes a quote character. Thus, 2n backslashes followed by\na quote encodes n backslashes and the end of the literal while 2n+1 backslashes\nfollowed by a quote encodes n backslashes followed by a quote character.\n\n# Examples\n```jldoctest\njulia> println(raw\"\\ $x\")\n\\ $x\n\njulia> println(raw\"\\\"\")\n\"\n\njulia> println(raw\"\\\\\\\"\")\n\\\"\n\njulia> println(raw\"\\\\x \\\\\\\"\")\n\\\\x \\\"\n```\n"}],"Base.gcdx":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Integer":"    gcdx(x,y)\n\nComputes the greatest common (positive) divisor of `x` and `y` and their Bézout\ncoefficients, i.e. the integer coefficients `u` and `v` that satisfy\n``ux+vy = d = gcd(x,y)``. ``gcdx(x,y)`` returns ``(d,u,v)``.\n\nThe arguments may be integer and rational numbers.\n\n!!! compat \"Julia 1.4\"\n    Rational arguments require Julia 1.4 or later.\n\n# Examples\n```jldoctest\njulia> gcdx(12, 42)\n(6, -3, 1)\n\njulia> gcdx(240, 46)\n(2, -9, 47)\n```\n\n!!! note\n    Bézout coefficients are *not* uniquely defined. `gcdx` returns the minimal\n    Bézout coefficients that are computed by the extended Euclidean algorithm.\n    (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.)\n    For signed integers, these coefficients `u` and `v` are minimal in\n    the sense that ``|u| < |y/d|`` and ``|v| < |x/d|``. Furthermore,\n    the signs of `u` and `v` are chosen so that `d` is positive.\n    For unsigned integers, the coefficients `u` and `v` might be near\n    their `typemax`, and the identity then holds only via the unsigned\n    integers' modulo arithmetic.\n"}],"Base.SystemError":[{"Union{}":"    SystemError(prefix::AbstractString, [errno::Int32])\n\nA system call failed with an error code (in the `errno` global variable).\n"}],"Base.findfirst":[{"Tuple{Any}":"    findfirst(A)\n\nReturn the index or key of the first `true` value in `A`.\nReturn `nothing` if no such value is found.\nTo search for other kinds of values, pass a predicate as the first argument.\n\nIndices or keys are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [false, false, true, false]\n4-element Array{Bool,1}:\n 0\n 0\n 1\n 0\n\njulia> findfirst(A)\n3\n\njulia> findfirst(falses(3)) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true false]\n2×2 Array{Bool,2}:\n 0  0\n 1  0\n\njulia> findfirst(A)\nCartesianIndex(2, 1)\n```\n"},{"Tuple{Function,Any}":"    findfirst(predicate::Function, A)\n\nReturn the index or key of the first element of `A` for which `predicate` returns `true`.\nReturn `nothing` if there is no such element.\n\nIndices or keys are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [1, 4, 2, 2]\n4-element Array{Int64,1}:\n 1\n 4\n 2\n 2\n\njulia> findfirst(iseven, A)\n2\n\njulia> findfirst(x -> x>10, A) # returns nothing, but not printed in the REPL\n\njulia> findfirst(isequal(4), A)\n2\n\njulia> A = [1 4; 2 2]\n2×2 Array{Int64,2}:\n 1  4\n 2  2\n\njulia> findfirst(iseven, A)\nCartesianIndex(2, 1)\n```\n"},{"Tuple{AbstractString,AbstractString}":"    findfirst(pattern::AbstractString, string::AbstractString)\n    findfirst(pattern::Regex, string::String)\n\nFind the first occurrence of `pattern` in `string`. Equivalent to\n[`findnext(pattern, string, firstindex(s))`](@ref).\n\n# Examples\n```jldoctest\njulia> findfirst(\"z\", \"Hello to the world\") # returns nothing, but not printed in the REPL\n\njulia> findfirst(\"Julia\", \"JuliaLang\")\n1:5\n```\n"},{"Tuple{AbstractChar,AbstractString}":"    findfirst(ch::AbstractChar, string::AbstractString)\n\nFind the first occurrence of character `ch` in `string`.\n\n!!! compat \"Julia 1.3\"\n    This method requires at least Julia 1.3.\n\n# Examples\n```jldoctest\njulia> findfirst('a', \"happy\")\n2\n\njulia> findfirst('z', \"happy\") === nothing\ntrue\n```\n"}],"Base.typemax":[{"Union{}":"    typemax(T)\n\nThe highest value representable by the given (real) numeric `DataType`.\n\n# Examples\n```jldoctest\njulia> typemax(Int8)\n127\n\njulia> typemax(UInt32)\n0xffffffff\n```\n"}],"Base.EOFError":[{"Union{}":"    EOFError()\n\nNo more data was available to read from a file or stream.\n"}],"Base.convert":[{"Union{}":"    convert(T, x)\n\nConvert `x` to a value of type `T`.\n\nIf `T` is an [`Integer`](@ref) type, an [`InexactError`](@ref) will be raised if `x`\nis not representable by `T`, for example if `x` is not integer-valued, or is outside the\nrange supported by `T`.\n\n# Examples\n```jldoctest\njulia> convert(Int, 3.0)\n3\n\njulia> convert(Int, 3.5)\nERROR: InexactError: Int64(3.5)\nStacktrace:\n[...]\n```\n\nIf `T` is a [`AbstractFloat`](@ref) or [`Rational`](@ref) type,\nthen it will return the closest value to `x` representable by `T`.\n\n```jldoctest\njulia> x = 1/3\n0.3333333333333333\n\njulia> convert(Float32, x)\n0.33333334f0\n\njulia> convert(Rational{Int32}, x)\n1//3\n\njulia> convert(Rational{Int64}, x)\n6004799503160661//18014398509481984\n```\n\nIf `T` is a collection type and `x` a collection, the result of\n`convert(T, x)` may alias all or part of `x`.\n```jldoctest\njulia> x = Int[1, 2, 3];\n\njulia> y = convert(Vector{Int}, x);\n\njulia> y === x\ntrue\n```\n"}],"Base.invpermute!":[{"Tuple{Any,AbstractArray{T,1} where T}":"    invpermute!(v, p)\n\nLike [`permute!`](@ref), but the inverse of the given permutation is applied.\n\n# Examples\n```jldoctest\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> invpermute!(A, perm);\n\njulia> A\n4-element Array{Int64,1}:\n 4\n 1\n 3\n 1\n```\n"}],"Base.factorial":[{"Tuple{Integer}":"    factorial(n::Integer)\n\nFactorial of `n`. If `n` is an [`Integer`](@ref), the factorial is computed as an\ninteger (promoted to at least 64 bits). Note that this may overflow if `n` is not small,\nbut you can use `factorial(big(n))` to compute the result exactly in arbitrary precision.\n\n# Examples\n```jldoctest\njulia> factorial(6)\n720\n\njulia> factorial(21)\nERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead\nStacktrace:\n[...]\n\njulia> factorial(big(21))\n51090942171709440000\n```\n\n# See also\n* [`binomial`](@ref)\n\n# External links\n* [Factorial](https://en.wikipedia.org/wiki/Factorial) on Wikipedia.\n"}],"Base.Cchar":[{"Union{}":"    Cchar\n\nEquivalent to the native `char` c-type.\n"}],"Base.open":[{"Union{Tuple{Base.AbstractCmd}, Tuple{Base.AbstractCmd,Union{RawFD, Base.FileRedirect, IO}}}":"    open(command, stdio=devnull; write::Bool = false, read::Bool = !write)\n\nStart running `command` asynchronously, and return a `process::IO` object.  If `read` is\ntrue, then reads from the process come from the process's standard output and `stdio` optionally\nspecifies the process's standard input stream.  If `write` is true, then writes go to\nthe process's standard input and `stdio` optionally specifies the process's standard output\nstream.\nThe process's standard error stream is connected to the current global `stderr`.\n"},{"Tuple{Function,Vararg{Any,N} where N}":"    open(f::Function, args...; kwargs....)\n\nApply the function `f` to the result of `open(args...; kwargs...)` and close the resulting file\ndescriptor upon completion.\n\n# Examples\n```jldoctest\njulia> open(\"myfile.txt\", \"w\") do io\n           write(io, \"Hello world!\")\n       end;\n\njulia> open(f->read(f, String), \"myfile.txt\")\n\"Hello world!\"\n\njulia> rm(\"myfile.txt\")\n```\n"},{"Union{Tuple{Base.AbstractCmd,AbstractString}, Tuple{Base.AbstractCmd,AbstractString,Union{RawFD, Base.FileRedirect, IO}}}":"    open(command, mode::AbstractString, stdio=devnull)\n\nRun `command` asynchronously. Like `open(command, stdio; read, write)` except specifying\nthe read and write flags via a mode string instead of keyword arguments.\nPossible mode strings are:\n\n| Mode | Description | Keywords                         |\n|:-----|:------------|:---------------------------------|\n| `r`  | read        | none                             |\n| `w`  | write       | `write = true`                   |\n| `r+` | read, write | `read = true, write = true`      |\n| `w+` | read, write | `read = true, write = true`      |\n"},{"Tuple{Function,Base.AbstractCmd,Vararg{Any,N} where N}":"    open(f::Function, command, args...; kwargs...)\n\nSimilar to `open(command, args...; kwargs...)`, but calls `f(stream)` on the resulting process\nstream, then closes the input stream and waits for the process to complete.\nReturns the value returned by `f`.\n"},{"Tuple{AbstractString}":"    open(filename::AbstractString; keywords...) -> IOStream\n\nOpen a file in a mode specified by five boolean keyword arguments:\n\n| Keyword    | Description             | Default                                 |\n|:-----------|:-----------------------|:----------------------------------------|\n| `read`     | open for reading       | `!write`                                |\n| `write`    | open for writing       | `truncate \\| append`                   |\n| `create`   | create if non-existent | `!read & write \\| truncate \\| append` |\n| `truncate` | truncate to zero size  | `!read & write`                         |\n| `append`   | seek to end            | `false`                                 |\n\nThe default when no keywords are passed is to open files for reading only.\nReturns a stream for accessing the opened file.\n"},{"Tuple{AbstractString,AbstractString}":"    open(filename::AbstractString, [mode::AbstractString]) -> IOStream\n\nAlternate syntax for open, where a string-based mode specifier is used instead of the five\nbooleans. The values of `mode` correspond to those from `fopen(3)` or Perl `open`, and are\nequivalent to setting the following boolean groups:\n\n| Mode | Description                   | Keywords                            |\n|:-----|:------------------------------|:------------------------------------|\n| `r`  | read                          | none                                |\n| `w`  | write, create, truncate       | `write = true`                      |\n| `a`  | write, create, append         | `append = true`                     |\n| `r+` | read, write                   | `read = true, write = true`         |\n| `w+` | read, write, create, truncate | `truncate = true, read = true`      |\n| `a+` | read, write, create, append   | `append = true, read = true`        |\n\n# Examples\n```jldoctest\njulia> io = open(\"myfile.txt\", \"w\");\n\njulia> write(io, \"Hello world!\");\n\njulia> close(io);\n\njulia> io = open(\"myfile.txt\", \"r\");\n\njulia> read(io, String)\n\"Hello world!\"\n\njulia> write(io, \"This file is read only\")\nERROR: ArgumentError: write failed, IOStream is not writeable\n[...]\n\njulia> close(io)\n\njulia> io = open(\"myfile.txt\", \"a\");\n\njulia> write(io, \"This stream is not read only\")\n28\n\njulia> close(io)\n\njulia> rm(\"myfile.txt\")\n```\n"},{"Tuple{RawFD}":"    open(fd::OS_HANDLE) -> IO\n\nTake a raw file descriptor wrap it in a Julia-aware IO type,\nand take ownership of the fd handle.\nCall `open(Libc.dup(fd))` to avoid the ownership capture\nof the original handle.\n\n!!! warn\n    Do not call this on a handle that's already owned by some\n    other part of the system.\n"}],"Base.print_matrix_vdots":[{"Union{Tuple{IO,AbstractString,Array{T,1} where T,AbstractString,Integer,Integer}, Tuple{IO,AbstractString,Array{T,1} where T,AbstractString,Integer,Integer,Bool}}":"`print_matrix_vdots` is used to show a series of vertical ellipsis instead\nof a bunch of rows for long matrices. Not only is the string vdots shown\nbut it also repeated every M elements if desired.\n"}],"Base.unaliascopy":[{"Tuple{Array}":"    Base.unaliascopy(A)\n\nMake a preventative copy of `A` in an operation where `A` [`Base.mightalias`](@ref) against\nanother array in order to preserve consistent semantics as that other array is mutated.\n\nThis must return an object of the same type as `A` to preserve optimal performance in the\nmuch more common case where aliasing does not occur. By default,\n`unaliascopy(A::AbstractArray)` will attempt to use [`copy(A)`](@ref), but in cases where\n`copy(A)` is not a `typeof(A)`, then the array should provide a custom implementation of\n`Base.unaliascopy(A)`.\n"}],"Base.trues":[{"Tuple{Vararg{Union{Integer, AbstractUnitRange},N} where N}":"    trues(dims)\n\nCreate a `BitArray` with all values set to `true`.\n\n# Examples\n```jldoctest\njulia> trues(2,3)\n2×3 BitArray{2}:\n 1  1  1\n 1  1  1\n```\n"}],"Base.eltype":[{"Tuple{Type}":"    eltype(type)\n\nDetermine the type of the elements generated by iterating a collection of the given `type`.\nFor dictionary types, this will be a `Pair{KeyType,ValType}`. The definition\n`eltype(x) = eltype(typeof(x))` is provided for convenience so that instances can be passed\ninstead of types. However the form that accepts a type argument should be defined for new\ntypes.\n\n# Examples\n```jldoctest\njulia> eltype(fill(1f0, (2,2)))\nFloat32\n\njulia> eltype(fill(0x1, (2,2)))\nUInt8\n```\n"}],"Base.@cfunction":[{"Tuple{Any,Any,Any}":"    @cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr{Cvoid}\n    @cfunction($callable, ReturnType, (ArgumentTypes...,)) -> CFunction\n\nGenerate a C-callable function pointer from the Julia function `callable`\nfor the given type signature.\nTo pass the return value to a `ccall`, use the argument type `Ptr{Cvoid}` in the signature.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression\n(although it can include a splat expression). And that these arguments will be evaluated in global scope\nduring compile-time (not deferred until runtime).\nAdding a '\\$' in front of the function argument changes this to instead create a runtime closure\nover the local variable `callable` (this is not supported on all architectures).\n\nSee [manual section on ccall and cfunction usage](@ref Calling-C-and-Fortran-Code).\n\n# Examples\n```julia-repl\njulia> function foo(x::Int, y::Int)\n           return x + y\n       end\n\njulia> @cfunction(foo, Int, (Int, Int))\nPtr{Cvoid} @0x000000001b82fcd0\n```\n"}],"Base.push!":[{"Union{}":"    push!(collection, items...) -> collection\n\nInsert one or more `items` in `collection`. If `collection` is an ordered container,\nthe items are inserted at the end (in the given order).\n\n# Examples\n```jldoctest\njulia> push!([1, 2, 3], 4, 5, 6)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n```\n\nIf `collection` is ordered, use [`append!`](@ref) to add all the elements of another\ncollection to it. The result of the preceding example is equivalent to `append!([1, 2, 3], [4,\n5, 6])`. For `AbstractSet` objects, [`union!`](@ref) can be used instead.\n"}],"Base.count_zeros":[{"Tuple{Integer}":"    count_zeros(x::Integer) -> Integer\n\nNumber of zeros in the binary representation of `x`.\n\n# Examples\n```jldoctest\njulia> count_zeros(Int32(2 ^ 16 - 1))\n16\n```\n"}],"Base.prevpow":[{"Tuple{Real,Real}":"    prevpow(a, x)\n\nThe largest `a^n` not greater than `x`, where `n` is a non-negative integer.\n`a` must be greater than 1, and `x` must not be less than 1.\n\n# Examples\n```jldoctest\njulia> prevpow(2, 7)\n4\n\njulia> prevpow(2, 9)\n8\n\njulia> prevpow(5, 20)\n5\n\njulia> prevpow(4, 16)\n16\n```\nSee also [`nextpow`](@ref).\n"}],"Base.read":[{"Tuple{AbstractString,Vararg{Any,N} where N}":"    read(filename::AbstractString, args...)\n\nOpen a file and read its contents. `args` is passed to `read`: this is equivalent to\n`open(io->read(io, args...), filename)`.\n\n    read(filename::AbstractString, String)\n\nRead the entire contents of a file as a string.\n"},{"Tuple{Any,Any}":"    read(io::IO, T)\n\nRead a single value of type `T` from `io`, in canonical binary representation.\n\n    read(io::IO, String)\n\nRead the entirety of `io`, as a `String`.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization\"\n```\n"},{"Union{Tuple{IO}, Tuple{IO,Integer}}":"    read(s::IO, nb=typemax(Int))\n\nRead at most `nb` bytes from `s`, returning a `Vector{UInt8}` of the bytes read.\n"},{"Tuple{Base.AbstractCmd,Type{String}}":"    read(command::Cmd, String)\n\nRun `command` and return the resulting output as a `String`.\n"},{"Tuple{IOStream,Integer}":"    read(s::IOStream, nb::Integer; all=true)\n\nRead at most `nb` bytes from `s`, returning a `Vector{UInt8}` of the bytes read.\n\nIf `all` is `true` (the default), this function will block repeatedly trying to read all\nrequested bytes, until an error or end-of-file occurs. If `all` is `false`, at most one\n`read` call is performed, and the amount of data returned is device-dependent. Note that not\nall stream types support the `all` option.\n"},{"Tuple{Base.AbstractCmd}":"    read(command::Cmd)\n\nRun `command` and return the resulting output as an array of bytes.\n"}],"Base.vect":[{"Tuple":"    vect(X...)\n\nCreate a [`Vector`](@ref) with element type computed from the `promote_typeof` of the argument,\ncontaining the argument list.\n\n# Examples\n```jldoctest\njulia> a = Base.vect(UInt8(1), 2.5, 1//2)\n3-element Array{Float64,1}:\n 1.0\n 2.5\n 0.5\n```\n"}],"Base.SubArray":[{"Union{}":"    SubArray{T,N,P,I,L} <: AbstractArray{T,N}\n\n`N`-dimensional view into a parent array (of type `P`) with an element type `T`, restricted by a tuple of indices (of type `I`). `L` is true for types that support fast linear indexing, and `false` otherwise.\n\nConstruct `SubArray`s using the [`view`](@ref) function.\n"}],"Base.skip":[{"Tuple{IOStream,Integer}":"    skip(s, offset)\n\nSeek a stream relative to the current position.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> skip(io, 10);\n\njulia> read(io, Char)\n'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\n```\n"}],"Base.Val":[{"Union{}":"    Val(c)\n\nReturn `Val{c}()`, which contains no run-time data. Types like this can be used to\npass the information between functions through the value `c`, which must be an `isbits`\nvalue. The intent of this construct is to be able to dispatch on constants directly (at\ncompile time) without having to test the value of the constant at run time.\n\n# Examples\n```jldoctest\njulia> f(::Val{true}) = \"Good\"\nf (generic function with 1 method)\n\njulia> f(::Val{false}) = \"Bad\"\nf (generic function with 2 methods)\n\njulia> f(Val(true))\n\"Good\"\n```\n"}],"Base.to_indices":[{"Tuple{Any,Tuple}":"    to_indices(A, I::Tuple)\n\nConvert the tuple `I` to a tuple of indices for use in indexing into array `A`.\n\nThe returned tuple must only contain either `Int`s or `AbstractArray`s of\nscalar indices that are supported by array `A`. It will error upon encountering\na novel index type that it does not know how to process.\n\nFor simple index types, it defers to the unexported `Base.to_index(A, i)` to\nprocess each index `i`. While this internal function is not intended to be\ncalled directly, `Base.to_index` may be extended by custom array or index types\nto provide custom indexing behaviors.\n\nMore complicated index types may require more context about the dimension into\nwhich they index. To support those cases, `to_indices(A, I)` calls\n`to_indices(A, axes(A), I)`, which then recursively walks through both the\ngiven tuple of indices and the dimensional indices of `A` in tandem. As such,\nnot all index types are guaranteed to propagate to `Base.to_index`.\n"}],"Base.wait":[{"Tuple{Base.GenericCondition}":"    wait([x])\n\nBlock the current task until some event occurs, depending on the type of the argument:\n\n* [`Channel`](@ref): Wait for a value to be appended to the channel.\n* [`Condition`](@ref): Wait for [`notify`](@ref) on a condition.\n* `Process`: Wait for a process or process chain to exit. The `exitcode` field of a process\n  can be used to determine success or failure.\n* [`Task`](@ref): Wait for a `Task` to finish. If the task fails with an exception, a\n  `TaskFailedException` (which wraps the failed task) is thrown.\n* [`RawFD`](@ref): Wait for changes on a file descriptor (see the `FileWatching` package).\n\nIf no argument is passed, the task blocks for an undefined period. A task can only be\nrestarted by an explicit call to [`schedule`](@ref) or [`yieldto`](@ref).\n\nOften `wait` is called within a `while` loop to ensure a waited-for condition is met before\nproceeding.\n"}],"Base.decode_overlong":[{"Union{}":"    decode_overlong(c::AbstractChar) -> Integer\n\nWhen [`isoverlong(c)`](@ref) is `true`, `decode_overlong(c)` returns\nthe Unicode codepoint value of `c`. `AbstractChar` implementations\nthat support overlong encodings should implement `Base.decode_overlong`.\n"}],"Base.ntoh":[{"Tuple{Any}":"    ntoh(x)\n\nConvert the endianness of a value from Network byte order (big-endian) to that used by the Host.\n"}],"Base.Inf64":[{"Union{}":"    Inf, Inf64\n\nPositive infinity of type [`Float64`](@ref).\n"}],"Base.|>":[{"Tuple{Any,Any}":"    |>(x, f)\n\nApplies a function to the preceding argument. This allows for easy function chaining.\n\n# Examples\n```jldoctest\njulia> [1:5;] |> x->x.^2 |> sum |> inv\n0.01818181818181818\n```\n"}],"Base.include_string":[{"Tuple{Module,String,String}":"    include_string(m::Module, code::AbstractString, filename::AbstractString=\"string\")\n\nLike [`include`](@ref), except reads code from the given string rather than from a file.\n"}],"Base.NaN":[{"Union{}":"    NaN, NaN64\n\nA not-a-number value of type [`Float64`](@ref).\n"}],"Base.~":[{"Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}":"    ~(x)\n\nBitwise not.\n\n# Examples\n```jldoctest\njulia> ~4\n-5\n\njulia> ~10\n-11\n\njulia> ~true\nfalse\n```\n"}],"Base.show":[{"Tuple{Any}":"    show(x)\n\nWrite an informative text representation of a value to the current output stream. New types\nshould overload `show(io::IO, x)` where the first argument is a stream. The representation used\nby `show` generally includes Julia-specific formatting and type information.\n\n[`repr`](@ref) returns the output of `show` as a string.\n\nSee also [`print`](@ref), which writes un-decorated representations.\n\n# Examples\n```jldoctest\njulia> show(\"Hello World!\")\n\"Hello World!\"\njulia> print(\"Hello World!\")\nHello World!\n```\n"}],"Base.prompt":[{"Tuple{IO,IO,AbstractString}":"    prompt(message; default=\"\") -> Union{String, Nothing}\n\nDisplays the `message` then waits for user input. Input is terminated when a newline (\\n)\nis encountered or EOF (^D) character is entered on a blank line. If a `default` is provided\nthen the user can enter just a newline character to select the `default`.\n\nSee also `Base.getpass` and `Base.winprompt` for secure entry of passwords.\n"}],"Base.add_sum":[{"Tuple{Any,Any}":"    Base.add_sum(x, y)\n\nThe reduction operator used in `sum`. The main difference from [`+`](@ref) is that small\nintegers are promoted to `Int`/`UInt`.\n"}],"Base.print_range":[{"Union{Tuple{IO,AbstractRange}, Tuple{IO,AbstractRange,AbstractString}, Tuple{IO,AbstractRange,AbstractString,AbstractString}, Tuple{IO,AbstractRange,AbstractString,AbstractString,AbstractString}, Tuple{IO,AbstractRange,AbstractString,AbstractString,AbstractString,AbstractString}}":"`print_range(io, r)` prints out a nice looking range r in terms of its elements\nas if it were `collect(r)`, dependent on the size of the\nterminal, and taking into account whether compact numbers should be shown.\nIt figures out the width in characters of each element, and if they\nend up too wide, it shows the first and last elements separated by a\nhorizontal ellipsis. Typical output will look like `1.0,2.0,3.0,…,4.0,5.0,6.0`.\n\n`print_range(io, r, pre, sep, post, hdots)` uses optional\nparameters `pre` and `post` characters for each printed row,\n`sep` separator string between printed elements,\n`hdots` string for the horizontal ellipsis.\n"}],"Base.cld":[{"Tuple{Any,Any}":"    cld(x, y)\n\nSmallest integer larger than or equal to `x/y`. Equivalent to `div(x, y, RoundUp)`.\n\nSee also: [`div`](@ref)\n\n# Examples\n```jldoctest\njulia> cld(5.5,2.2)\n3.0\n```\n"}],"Base.mul12":[{"Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFloat":"    zhi, zlo = mul12(x, y)\n\nA high-precision representation of `x * y` for floating-point\nnumbers. Mathematically, `zhi + zlo = x * y`, where `zhi` contains the\nmost significant bits and `zlo` the least significant.\n\nExample:\n```julia\njulia> x = Float32(π)\n3.1415927f0\n\njulia> x * x\n9.869605f0\n\njulia> Float64(x) * Float64(x)\n9.869604950382893\n\njulia> hi, lo = Base.mul12(x, x)\n(9.869605f0, -1.140092f-7)\n\njulia> Float64(hi) + Float64(lo)\n9.869604950382893\n```\n"}],"Base.code_lowered":[{"Tuple{Any,Any}":"    code_lowered(f, types; generated=true, debuginfo=:default)\n\nReturn an array of the lowered forms (IR) for the methods matching the given generic function\nand type signature.\n\nIf `generated` is `false`, the returned `CodeInfo` instances will correspond to fallback\nimplementations. An error is thrown if no fallback implementation exists.\nIf `generated` is `true`, these `CodeInfo` instances will correspond to the method bodies\nyielded by expanding the generators.\n\nThe keyword debuginfo controls the amount of code metadata present in the output.\n\nNote that an error will be thrown if `types` are not leaf types when `generated` is\n`true` and any of the corresponding methods are an `@generated` method.\n"}],"Base.digits!":[{"Union{Tuple{T}, Tuple{AbstractArray{T,1},Integer}} where T<:Integer":"    digits!(array, n::Integer; base::Integer = 10)\n\nFills an array of the digits of `n` in the given base. More significant digits are at higher\nindices. If the array length is insufficient, the least significant digits are filled up to\nthe array length. If the array length is excessive, the excess portion is filled with zeros.\n\n# Examples\n```jldoctest\njulia> digits!([2,2,2,2], 10, base = 2)\n4-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n\njulia> digits!([2,2,2,2,2,2], 10, base = 2)\n6-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n 0\n 0\n```\n"}],"Base.AbstractChannel":[{"Union{}":"    AbstractChannel{T}\n\nRepresentation of a channel passing objects of type `T`.\n"}],"Base.Colon":[{"Union{}":"    Colon()\n\nColons (:) are used to signify indexing entire objects or dimensions at once.\n\nVery few operations are defined on Colons directly; instead they are converted\nby [`to_indices`](@ref) to an internal vector type (`Base.Slice`) to represent the\ncollection of indices they span before being used.\n\nThe singleton instance of `Colon` is also a function used to construct ranges;\nsee [`:`](@ref).\n"}],"Base.vcat":[{"Tuple":"    vcat(A...)\n\nConcatenate along dimension 1.\n\n# Examples\n```jldoctest\njulia> a = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\n\njulia> b = [6 7 8 9 10; 11 12 13 14 15]\n2×5 Array{Int64,2}:\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> vcat(a,b)\n3×5 Array{Int64,2}:\n  1   2   3   4   5\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> c = ([1 2 3], [4 5 6])\n([1 2 3], [4 5 6])\n\njulia> vcat(c...)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n```\n"}],"Base.Cssize_t":[{"Union{}":"    Cssize_t\n\nEquivalent to the native `ssize_t` c-type.\n"}],"Base.alignment":[{"Tuple{IO,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Integer,Integer,Integer}":"`alignment(X, rows, cols, cols_if_complete, cols_otherwise, sep)` returns the\nalignment for specified parts of array `X`, returning the (left,right) info.\nIt will look in X's `rows`, `cols` (both lists of indices)\nand figure out what's needed to be fully aligned, for example looking all\nthe way down a column and finding out the maximum size of each element.\nParameter `sep::Integer` is number of spaces to put between elements.\n`cols_if_complete` and `cols_otherwise` indicate screen width to use.\nAlignment is reported as a vector of (left,right) tuples, one for each\ncolumn going across the screen.\n"},{"Tuple{IO,Integer}":"`alignment(42)` yields (2,0)"},{"Tuple{IO,Any}":"`alignment(X)` returns a tuple (left,right) showing how many characters are\nneeded on either side of an alignment feature such as a decimal point.\n"},{"Tuple{IO,Real}":"`alignment(4.23)` yields (1,3) for `4` and `.23`"},{"Tuple{IO,Complex}":"`alignment(1 + 10im)` yields (3,5) for `1 +` and `_10im` (plus sign on left, space on right)"}],"Base.ndigits":[{"Tuple{Integer}":"    ndigits(n::Integer; base::Integer=10, pad::Integer=1)\n\nCompute the number of digits in integer `n` written in base `base`\n(`base` must not be in `[-1, 0, 1]`), optionally padded with zeros\nto a specified size (the result will never be less than `pad`).\n\n# Examples\n```jldoctest\njulia> ndigits(12345)\n5\n\njulia> ndigits(1022, base=16)\n3\n\njulia> string(1022, base=16)\n\"3fe\"\n\njulia> ndigits(123, pad=5)\n5\n```\n"}],"Base.CompositeException":[{"Union{}":"    CompositeException\n\nWrap a `Vector` of exceptions thrown by a [`Task`](@ref) (e.g. generated from a remote worker over a channel\nor an asynchronously executing local I/O write or a remote worker under `pmap`) with information about the series of exceptions.\nFor example, if a group of workers are executing several tasks, and multiple workers fail, the resulting `CompositeException` will\ncontain a \"bundle\" of information from each worker indicating where and why the exception(s) occurred.\n"}],"Base.readbytes!":[{"Union{Tuple{IO,AbstractArray{UInt8,N} where N}, Tuple{IO,AbstractArray{UInt8,N} where N,Any}}":"    readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))\n\nRead at most `nb` bytes from `stream` into `b`, returning the number of bytes read.\nThe size of `b` will be increased if needed (i.e. if `nb` is greater than `length(b)`\nand enough bytes could be read), but it will never be decreased.\n"},{"Union{Tuple{IOStream,Array{UInt8,N} where N}, Tuple{IOStream,Array{UInt8,N} where N,Any}}":"    readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)\n\nRead at most `nb` bytes from `stream` into `b`, returning the number of bytes read.\nThe size of `b` will be increased if needed (i.e. if `nb` is greater than `length(b)`\nand enough bytes could be read), but it will never be decreased.\n\nIf `all` is `true` (the default), this function will block repeatedly trying to read all\nrequested bytes, until an error or end-of-file occurs. If `all` is `false`, at most one\n`read` call is performed, and the amount of data returned is device-dependent. Note that not\nall stream types support the `all` option.\n"}],"Base.functionloc":[{"Tuple{Method}":"    functionloc(m::Method)\n\nReturns a tuple `(filename,line)` giving the location of a `Method` definition.\n"},{"Tuple{Any,Any}":"    functionloc(f::Function, types)\n\nReturns a tuple `(filename,line)` giving the location of a generic `Function` definition.\n"}],"Base.shell_escape_winsomely":[{"Tuple{Vararg{AbstractString,N} where N}":"     shell_escaped_winsomely(args::Union{Cmd,AbstractString...})::String\n\nConvert the collection of strings `args` into single string suitable for passing as the argument\nstring for a Windows command line. Windows passes the entire command line as a single string to\nthe application (unlike POSIX systems, where the list of arguments are passed separately).\nMany Windows API applications (including julia.exe), use the conventions of the [Microsoft C\nruntime](https://docs.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments) to\nsplit that command line into a list of strings. This function implements the inverse of such a\nC runtime command-line parser. It joins command-line arguments to be passed to a Windows console\napplication into a command line, escaping or quoting meta characters such as space,\ndouble quotes and backslash where needed. This may be useful in concert with the `windows_verbatim`\nflag to [`Cmd`](@ref) when constructing process pipelines.\n\n# Example\n```jldoctest\njulia> println(shell_escaped_winsomely(\"A B\\\", \"C\"))\n\"A B\\\" C\n"}],"Base.conj!":[{"Tuple{AbstractArray{#s662,N} where N where #s662<:Number}":"    conj!(A)\n\nTransform an array to its complex conjugate in-place.\n\nSee also [`conj`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [1+im 2-im; 2+2im 3+im]\n2×2 Array{Complex{Int64},2}:\n 1+1im  2-1im\n 2+2im  3+1im\n\njulia> conj!(A);\n\njulia> A\n2×2 Array{Complex{Int64},2}:\n 1-1im  2+1im\n 2-2im  3-1im\n```\n"}],"Base.trailing_ones":[{"Tuple{Integer}":"    trailing_ones(x::Integer) -> Integer\n\nNumber of ones trailing the binary representation of `x`.\n\n# Examples\n```jldoctest\njulia> trailing_ones(3)\n2\n```\n"}],"Base.>>":[{"Tuple{Integer,Integer}":"    >>(x, n)\n\nRight bit shift operator, `x >> n`. For `n >= 0`, the result is `x` shifted\nright by `n` bits, where `n >= 0`, filling with `0`s if `x >= 0`, `1`s if `x <\n0`, preserving the sign of `x`. This is equivalent to `fld(x, 2^n)`. For `n <\n0`, this is equivalent to `x << -n`.\n\n# Examples\n```jldoctest\njulia> Int8(13) >> 2\n3\n\njulia> bitstring(Int8(13))\n\"00001101\"\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> Int8(-14) >> 2\n-4\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(-4))\n\"11111100\"\n```\nSee also [`>>>`](@ref), [`<<`](@ref).\n"},{"Tuple{BitArray{1},Union{Int64, UInt64}}":"    >>(B::BitVector, n) -> BitVector\n\nRight bit shift operator, `B >> n`. For `n >= 0`, the result is `B`\nwith elements shifted `n` positions forward, filling with `false`\nvalues. If `n < 0`, elements are shifted backwards. Equivalent to\n`B << -n`.\n\n# Examples\n```jldoctest\njulia> B = BitVector([true, false, true, false, false])\n5-element BitArray{1}:\n 1\n 0\n 1\n 0\n 0\n\njulia> B >> 1\n5-element BitArray{1}:\n 0\n 1\n 0\n 1\n 0\n\njulia> B >> -1\n5-element BitArray{1}:\n 0\n 1\n 0\n 0\n 0\n```\n"}],"Base.LinearIndices":[{"Union{}":"    LinearIndices(A::AbstractArray)\n\nReturn a `LinearIndices` array with the same shape and [`axes`](@ref) as `A`,\nholding the linear index of each entry in `A`. Indexing this array with\ncartesian indices allows mapping them to linear indices.\n\nFor arrays with conventional indexing (indices start at 1), or any multidimensional\narray, linear indices range from 1 to `length(A)`. However, for `AbstractVector`s\nlinear indices are `axes(A, 1)`, and therefore do not start at 1 for vectors with\nunconventional indexing.\n\nCalling this function is the \"safe\" way to write algorithms that\nexploit linear indexing.\n\n# Examples\n```jldoctest\njulia> A = fill(1, (5,6,7));\n\njulia> b = LinearIndices(A);\n\njulia> extrema(b)\n(1, 210)\n```\n\n    LinearIndices(inds::CartesianIndices) -> R\n    LinearIndices(sz::Dims) -> R\n    LinearIndices((istart:istop, jstart:jstop, ...)) -> R\n\nReturn a `LinearIndices` array with the specified shape or [`axes`](@ref).\n\n# Example\n\nThe main purpose of this constructor is intuitive conversion\nfrom cartesian to linear indexing:\n\n```jldoctest\njulia> linear = LinearIndices((1:3, 1:2))\n3×2 LinearIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:\n 1  4\n 2  5\n 3  6\n\njulia> linear[1,2]\n4\n```\n"}],"Base.ARGS":[{"Union{}":"    ARGS\n\nAn array of the command line arguments passed to Julia, as strings.\n"}],"Base.istaskfailed":[{"Tuple{Task}":"    istaskfailed(t::Task) -> Bool\n\nDetermine whether a task has exited because an exception was thrown.\n\n# Examples\n```jldoctest\njulia> a4() = error(\"task failed\");\n\njulia> b = Task(a4);\n\njulia> istaskfailed(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskfailed(b)\ntrue\n```\n"}],"Base.Cmd":[{"Union{}":"    Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)\n\nConstruct a new `Cmd` object, representing an external program and arguments, from `cmd`,\nwhile changing the settings of the optional keyword arguments:\n\n* `ignorestatus::Bool`: If `true` (defaults to `false`), then the `Cmd` will not throw an\n  error if the return code is nonzero.\n* `detach::Bool`: If `true` (defaults to `false`), then the `Cmd` will be run in a new\n  process group, allowing it to outlive the `julia` process and not have Ctrl-C passed to\n  it.\n* `windows_verbatim::Bool`: If `true` (defaults to `false`), then on Windows the `Cmd` will\n  send a command-line string to the process with no quoting or escaping of arguments, even\n  arguments containing spaces. (On Windows, arguments are sent to a program as a single\n  \"command-line\" string, and programs are responsible for parsing it into arguments. By\n  default, empty arguments and arguments with spaces or tabs are quoted with double quotes\n  `\"` in the command line, and `\\` or `\"` are preceded by backslashes.\n  `windows_verbatim=true` is useful for launching programs that parse their command line in\n  nonstandard ways.) Has no effect on non-Windows systems.\n* `windows_hide::Bool`: If `true` (defaults to `false`), then on Windows no new console\n  window is displayed when the `Cmd` is executed. This has no effect if a console is\n  already open or on non-Windows systems.\n* `env`: Set environment variables to use when running the `Cmd`. `env` is either a\n  dictionary mapping strings to strings, an array of strings of the form `\"var=val\"`, an\n  array or tuple of `\"var\"=>val` pairs, or `nothing`. In order to modify (rather than\n  replace) the existing environment, create `env` by `copy(ENV)` and then set\n  `env[\"var\"]=val` as desired.\n* `dir::AbstractString`: Specify a working directory for the command (instead\n  of the current directory).\n\nFor any keywords that are not specified, the current settings from `cmd` are used. Normally,\nto create a `Cmd` object in the first place, one uses backticks, e.g.\n\n    Cmd(`echo \"Hello world\"`, ignorestatus=true, detach=false)\n"}],"Base.success":[{"Tuple{Base.AbstractCmd}":"    success(command)\n\nRun a command object, constructed with backticks (see the [Running External Programs](@ref)\nsection in the manual), and tell whether it was successful (exited with a code of 0).\nAn exception is raised if the process cannot be started.\n"}],"Base.IdDict":[{"Union{}":"    IdDict([itr])\n\n`IdDict{K,V}()` constructs a hash table using object-id as hash and\n`===` as equality with keys of type `K` and values of type `V`.\n\nSee [`Dict`](@ref) for further help.\n"}],"Base.unsafe_pointer_to_objref":[{"Tuple{Ptr}":"    unsafe_pointer_to_objref(p::Ptr)\n\nConvert a `Ptr` to an object reference. Assumes the pointer refers to a valid heap-allocated\nJulia object. If this is not the case, undefined behavior results, hence this function is\nconsidered \"unsafe\" and should be used with care.\n\nSee also: [`pointer_from_objref`](@ref).\n"}],"Base.operator_associativity":[{"Tuple{Symbol}":"    operator_associativity(s::Symbol)\n\nReturn a symbol representing the associativity of operator `s`. Left- and right-associative\noperators return `:left` and `:right`, respectively. Return `:none` if `s` is non-associative\nor an invalid operator.\n\n# Examples\n```jldoctest\njulia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)\n(:left, :none, :right)\n\njulia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)\n(:left, :none, :right)\n```\n"}],"Base.position":[{"Tuple{IOStream}":"    position(s)\n\nGet the current position of a stream.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> position(io)\n5\n\njulia> skip(io, 10);\n\njulia> position(io)\n15\n\njulia> seekend(io);\n\njulia> position(io)\n35\n```\n"}],"Base.unique!":[{"Tuple{Any,AbstractArray{T,1} where T}":"    unique!(f, A::AbstractVector)\n\nSelects one value from `A` for each unique value produced by `f` applied to\nelements of `A` , then return the modified A.\n\n!!! compat \"Julia 1.1\"\n    This method is available as of Julia 1.1.\n\n# Examples\n```jldoctest\njulia> unique!(x -> x^2, [1, -1, 3, -3, 4])\n3-element Array{Int64,1}:\n 1\n 3\n 4\n\njulia> unique!(n -> n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])\n3-element Array{Int64,1}:\n 5\n 1\n 9\n\njulia> unique!(iseven, [2, 3, 5, 7, 9])\n2-element Array{Int64,1}:\n 2\n 3\n```\n"},{"Tuple{Union{AbstractArray{#s662,1} where #s662<:Real, AbstractArray{#s661,1} where #s661<:AbstractString, AbstractArray{#s660,1} where #s660<:Symbol}}":"    unique!(A::AbstractVector)\n\nRemove duplicate items as determined by [`isequal`](@ref), then return the modified `A`.\n`unique!` will return the elements of `A` in the order that they occur. If you do not care\nabout the order of the returned data, then calling `(sort!(A); unique!(A))` will be much\nmore efficient as long as the elements of `A` can be sorted.\n\n# Examples\n```jldoctest\njulia> unique!([1, 1, 1])\n1-element Array{Int64,1}:\n 1\n\njulia> A = [7, 3, 2, 3, 7, 5];\n\njulia> unique!(A)\n4-element Array{Int64,1}:\n 7\n 3\n 2\n 5\n\njulia> B = [7, 6, 42, 6, 7, 42];\n\njulia> sort!(B);  # unique! is able to process sorted data much more efficiently.\n\njulia> unique!(B)\n3-element Array{Int64,1}:\n  6\n  7\n 42\n```\n"}],"Base.eachslice":[{"Tuple{AbstractArray}":"    eachslice(A::AbstractArray; dims)\n\nCreate a generator that iterates over dimensions `dims` of `A`, returning views that select all\nthe data from the other dimensions in `A`.\n\nOnly a single dimension in `dims` is currently supported. Equivalent to `(view(A,:,:,...,i,:,:\n...)) for i in axes(A, dims))`, where `i` is in position `dims`.\n\nSee also [`eachrow`](@ref), [`eachcol`](@ref), and [`selectdim`](@ref).\n\n!!! compat \"Julia 1.1\"\n     This function requires at least Julia 1.1.\n"}],"Base.@specialize":[{"Tuple":"    @specialize\n\nReset the specialization hint for an argument back to the default.\nFor details, see [`@nospecialize`](@ref).\n"}],"Base.@time":[{"Tuple{Any}":"    @time\n\nA macro to execute an expression, printing the time it took to execute, the number of\nallocations, and the total number of bytes its execution caused to be allocated, before\nreturning the value of the expression.\n\nSee also [`@timev`](@ref), [`@timed`](@ref), [`@elapsed`](@ref), and\n[`@allocated`](@ref).\n\n!!! note\n    For more serious benchmarking, consider the `@btime` macro from the BenchmarkTools.jl\n    package which among other things evaluates the function multiple times in order to\n    reduce noise.\n\n```julia-repl\njulia> @time rand(10^6);\n  0.001525 seconds (7 allocations: 7.630 MiB)\n\njulia> @time begin\n           sleep(0.3)\n           1+1\n       end\n  0.301395 seconds (8 allocations: 336 bytes)\n2\n```\n"}],"Base.AbstractIrrational":[{"Union{}":"    AbstractIrrational <: Real\n\nNumber type representing an exact irrational value.\n"}],"Base.&":[{"Union{Tuple{T}, Tuple{T,T}} where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}":"    &(x, y)\n\nBitwise and. Implements [three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic),\nreturning [`missing`](@ref) if one operand is `missing` and the other is `true`.\n\n# Examples\n```jldoctest\njulia> 4 & 10\n0\n\njulia> 4 & 12\n4\n\njulia> true & missing\nmissing\n\njulia> false & missing\nfalse\n```\n"}],"Base.eachmatch":[{"Tuple{Regex,AbstractString}":"    eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)\n\nSearch for all matches of a the regular expression `r` in `s` and return a iterator over the\nmatches. If overlap is `true`, the matching sequences are allowed to overlap indices in the\noriginal string, otherwise they must be from distinct character ranges.\n\n# Examples\n```jldoctest\njulia> rx = r\"a.a\"\nr\"a.a\"\n\njulia> m = eachmatch(rx, \"a1a2a3a\")\nBase.RegexMatchIterator(r\"a.a\", \"a1a2a3a\", false)\n\njulia> collect(m)\n2-element Array{RegexMatch,1}:\n RegexMatch(\"a1a\")\n RegexMatch(\"a3a\")\n\njulia> collect(eachmatch(rx, \"a1a2a3a\", overlap = true))\n3-element Array{RegexMatch,1}:\n RegexMatch(\"a1a\")\n RegexMatch(\"a2a\")\n RegexMatch(\"a3a\")\n```\n"}],"Base.time_ns":[{"Tuple{}":"    time_ns()\n\nGet the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.\n"}],"Base.nextprod":[{"Tuple{Array{Int64,1},Any}":"    nextprod([k_1, k_2,...], n)\n\nNext integer greater than or equal to `n` that can be written as ``\\prod k_i^{p_i}`` for integers\n``p_1``, ``p_2``, etc.\n\n# Examples\n```jldoctest\njulia> nextprod([2, 3], 105)\n108\n\njulia> 2^2 * 3^3\n108\n```\n"}],"Base.mul_prod":[{"Tuple{Any,Any}":"    Base.mul_prod(x, y)\n\nThe reduction operator used in `prod`. The main difference from [`*`](@ref) is that small\nintegers are promoted to `Int`/`UInt`.\n"}],"Base.oneunit":[{"Union{Tuple{T}, Tuple{T}} where T":"    oneunit(x::T)\n    oneunit(T::Type)\n\nReturns `T(one(x))`, where `T` is either the type of the argument or\n(if a type is passed) the argument.  This differs from [`one`](@ref) for\ndimensionful quantities: `one` is dimensionless (a multiplicative identity)\nwhile `oneunit` is dimensionful (of the same type as `x`, or of type `T`).\n\n# Examples\n```jldoctest\njulia> oneunit(3.7)\n1.0\n\njulia> import Dates; oneunit(Dates.Day)\n1 day\n```\n"}],"Base.NaN16":[{"Union{}":"    NaN16\n\nA not-a-number value of type [`Float16`](@ref).\n"}],"Base.OrdinalRange":[{"Union{}":"    OrdinalRange{T, S} <: AbstractRange{T}\n\nSupertype for ordinal ranges with elements of type `T` with\nspacing(s) of type `S`. The steps should be always-exact\nmultiples of [`oneunit`](@ref), and `T` should be a \"discrete\"\ntype, which cannot have values smaller than `oneunit`. For example,\n`Integer` or `Date` types would qualify, whereas `Float64` would not (since this\ntype can represent values smaller than `oneunit(Float64)`.\n[`UnitRange`](@ref), [`StepRange`](@ref), and other types are subtypes of this.\n"}],"Base.pushfirst!":[{"Union{Tuple{T}, Tuple{Array{T,1},Any}} where T":"    pushfirst!(collection, items...) -> collection\n\nInsert one or more `items` at the beginning of `collection`.\n\n# Examples\n```jldoctest\njulia> pushfirst!([1, 2, 3, 4], 5, 6)\n6-element Array{Int64,1}:\n 5\n 6\n 1\n 2\n 3\n 4\n```\n"}],"Base.Culong":[{"Union{}":"    Culong\n\nEquivalent to the native `unsigned long` c-type.\n"}],"Base.printstyled":[{"Tuple{IO,Vararg{Any,N} where N}":"    printstyled([io], xs...; bold::Bool=false, color::Union{Symbol,Int}=:normal)\n\nPrint `xs` in a color specified as a symbol or integer, optionally in bold.\n\n`color` may take any of the values `:normal`,\n`:default`,\n`:bold`,\n`:black`,\n`:blink`,\n`:blue`,\n`:cyan`,\n`:green`,\n`:hidden`,\n`:light_black`,\n`:light_blue`,\n`:light_cyan`,\n`:light_green`,\n`:light_magenta`,\n`:light_red`,\n`:light_yellow`,\n`:magenta`,\n`:nothing`,\n`:red`,\n`:reverse`,\n`:underline`,\n`:white`, or \n`:yellow`\nor an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors.\nIf the keyword `bold` is given as `true`, the result will be printed in bold.\n"}],"Base.Generator":[{"Union{}":"    Generator(f, iter)\n\nGiven a function `f` and an iterator `iter`, construct an iterator that yields\nthe values of `f` applied to the elements of `iter`.\nThe syntax `f(x) for x in iter [if cond(x)::Bool]` is syntax for constructing an instance of this\ntype. The `[if cond(x)::Bool]` expression is optional and acts as a \"guard\", effectively\nfiltering out values where the condition is false.\n\n```jldoctest\njulia> g = (abs2(x) for x in 1:5 if x != 3);\n\njulia> for x in g\n           println(x)\n       end\n1\n4\n16\n25\n\njulia> collect(g)\n4-element Array{Int64,1}:\n  1\n  4\n 16\n 25\n```\n"}],"Base.transcode":[{"Union{}":"    transcode(T, src)\n\nConvert string data between Unicode encodings. `src` is either a\n`String` or a `Vector{UIntXX}` of UTF-XX code units, where\n`XX` is 8, 16, or 32. `T` indicates the encoding of the return value:\n`String` to return a (UTF-8 encoded) `String` or `UIntXX`\nto return a `Vector{UIntXX}` of UTF-`XX` data. (The alias [`Cwchar_t`](@ref)\ncan also be used as the integer type, for converting `wchar_t*` strings\nused by external C libraries.)\n\nThe `transcode` function succeeds as long as the input data can be\nreasonably represented in the target encoding; it always succeeds for\nconversions between UTF-XX encodings, even for invalid Unicode data.\n\nOnly conversion to/from UTF-8 is currently supported.\n"}],"Base.names":[{"Tuple{Module}":"    names(x::Module; all::Bool = false, imported::Bool = false)\n\nGet an array of the names exported by a `Module`, excluding deprecated names.\nIf `all` is true, then the list also includes non-exported names defined in the module,\ndeprecated names, and compiler-generated names.\nIf `imported` is true, then names explicitly imported from other modules\nare also included.\n\nAs a special case, all names defined in `Main` are considered \"exported\",\nsince it is not idiomatic to explicitly export names from `Main`.\n"}],"Base.keytype":[{"Tuple{AbstractArray}":"    keytype(T::Type{<:AbstractArray})\n    keytype(A::AbstractArray)\n\nReturn the key type of an array. This is equal to the\n`eltype` of the result of `keys(...)`, and is provided\nmainly for compatibility with the dictionary interface.\n\n# Examples\n```jldoctest\njulia> keytype([1, 2, 3]) == Int\ntrue\n\njulia> keytype([1 2; 3 4])\nCartesianIndex{2}\n```\n\n!!! compat \"Julia 1.2\"\n     For arrays, this function requires at least Julia 1.2.\n"},{"Union{Tuple{Type{#s662} where #s662<:AbstractDict{K,V}}, Tuple{V}, Tuple{K}} where V where K":"    keytype(type)\n\nGet the key type of an dictionary type. Behaves similarly to [`eltype`](@ref).\n\n# Examples\n```jldoctest\njulia> keytype(Dict(Int32(1) => \"foo\"))\nInt32\n```\n"}],"Base.count":[{"Tuple{Union{Regex, AbstractString},AbstractString}":"    count(\n        pattern::Union{AbstractString,Regex},\n        string::AbstractString;\n        overlap::Bool = false,\n    )\n\nReturn the number of matches for `pattern` in `string`. This is equivalent to\ncalling `length(findall(pattern, string))` but more efficient.\n\nIf `overlap=true`, the matching sequences are allowed to overlap indices in the\noriginal string, otherwise they must be from disjoint character ranges.\n"},{"Tuple{Any,Any}":"    count(p, itr) -> Integer\n    count(itr) -> Integer\n\nCount the number of elements in `itr` for which predicate `p` returns `true`.\nIf `p` is omitted, counts the number of `true` elements in `itr` (which\nshould be a collection of boolean values).\n\n# Examples\n```jldoctest\njulia> count(i->(4<=i<=6), [2,3,4,5,6])\n3\n\njulia> count([true, false, true, true])\n3\n```\n"}],"Base.istaskstarted":[{"Tuple{Task}":"    istaskstarted(t::Task) -> Bool\n\nDetermine whether a task has started executing.\n\n# Examples\n```jldoctest\njulia> a3() = sum(i for i in 1:1000);\n\njulia> b = Task(a3);\n\njulia> istaskstarted(b)\nfalse\n```\n"}],"Base.IteratorEltype":[{"Tuple{Any}":"    IteratorEltype(itertype::Type) -> IteratorEltype\n\nGiven the type of an iterator, return one of the following values:\n\n* `EltypeUnknown()` if the type of elements yielded by the iterator is not known in advance.\n* `HasEltype()` if the element type is known, and [`eltype`](@ref) would return a meaningful value.\n\n`HasEltype()` is the default, since iterators are assumed to implement [`eltype`](@ref).\n\nThis trait is generally used to select between algorithms that pre-allocate a specific\ntype of result, and algorithms that pick a result type based on the types of yielded\nvalues.\n\n```jldoctest\njulia> Base.IteratorEltype(1:5)\nBase.HasEltype()\n```\n"}],"Base.repeat":[{"Tuple{AbstractString,Integer}":"    repeat(s::AbstractString, r::Integer)\n\nRepeat a string `r` times. This can be written as `s^r`.\n\nSee also: [`^`](@ref)\n\n# Examples\n```jldoctest\njulia> repeat(\"ha\", 3)\n\"hahaha\"\n```\n"},{"Tuple{AbstractArray}":"    repeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))\n\nConstruct an array by repeating the entries of `A`. The i-th element of `inner` specifies\nthe number of times that the individual entries of the i-th dimension of `A` should be\nrepeated. The i-th element of `outer` specifies the number of times that a slice along the\ni-th dimension of `A` should be repeated. If `inner` or `outer` are omitted, no repetition\nis performed.\n\n# Examples\n```jldoctest\njulia> repeat(1:2, inner=2)\n4-element Array{Int64,1}:\n 1\n 1\n 2\n 2\n\njulia> repeat(1:2, outer=2)\n4-element Array{Int64,1}:\n 1\n 2\n 1\n 2\n\njulia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))\n4×6 Array{Int64,2}:\n 1  2  1  2  1  2\n 1  2  1  2  1  2\n 3  4  3  4  3  4\n 3  4  3  4  3  4\n```\n"},{"Tuple{AbstractChar,Integer}":"    repeat(c::AbstractChar, r::Integer) -> String\n\nRepeat a character `r` times. This can equivalently be accomplished by calling [`c^r`](@ref ^).\n\n# Examples\n```jldoctest\njulia> repeat('A', 3)\n\"AAA\"\n```\n"},{"Tuple{AbstractArray,Vararg{Integer,N} where N}":"    repeat(A::AbstractArray, counts::Integer...)\n\nConstruct an array by repeating array `A` a given number of times in each dimension, specified by `counts`.\n\n# Examples\n```jldoctest\njulia> repeat([1, 2, 3], 2)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 1\n 2\n 3\n\njulia> repeat([1, 2, 3], 2, 3)\n6×3 Array{Int64,2}:\n 1  1  1\n 2  2  2\n 3  3  3\n 1  1  1\n 2  2  2\n 3  3  3\n```\n"}],"Base.@b_str":[{"Tuple{Any}":"    @b_str\n\nCreate an immutable byte (`UInt8`) vector using string syntax.\n\n# Examples\n```jldoctest\njulia> v = b\"12\\x01\\x02\"\n4-element Base.CodeUnits{UInt8,String}:\n 0x31\n 0x32\n 0x01\n 0x02\n\njulia> v[2]\n0x32\n```\n"}],"Base.@elapsed":[{"Tuple{Any}":"    @elapsed\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the\nnumber of seconds it took to execute as a floating-point number.\n\nSee also [`@time`](@ref), [`@timev`](@ref), [`@timed`](@ref),\nand [`@allocated`](@ref).\n\n```julia-repl\njulia> @elapsed sleep(0.3)\n0.301391426\n```\n"}],"Base.summary":[{"Tuple{IO,Any}":"    summary(io::IO, x)\n    str = summary(x)\n\nPrint to a stream `io`, or return a string `str`, giving a brief description of\na value. By default returns `string(typeof(x))`, e.g. [`Int64`](@ref).\n\nFor arrays, returns a string of size and type info,\ne.g. `10-element Array{Int64,1}`.\n\n# Examples\n```jldoctest\njulia> summary(1)\n\"Int64\"\n\njulia> summary(zeros(2))\n\"2-element Array{Float64,1}\"\n```\n"}],"Base.isoperator":[{"Tuple{Union{AbstractString, Symbol}}":"    isoperator(s::Symbol)\n\nReturn `true` if the symbol can be used as an operator, `false` otherwise.\n\n# Examples\n```jldoctest\njulia> Base.isoperator(:+), Base.isoperator(:f)\n(true, false)\n```\n"}],"Base.ExponentialBackOff":[{"Tuple{}":"    ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)\n\nA [`Float64`](@ref) iterator of length `n` whose elements exponentially increase at a\nrate in the interval `factor` * (1 ± `jitter`).  The first element is\n`first_delay` and all elements are clamped to `max_delay`.\n"}],"Base.finalize":[{"Tuple{Any}":"    finalize(x)\n\nImmediately run finalizers registered for object `x`.\n"}],"Base.dataids":[{"Tuple{AbstractArray}":"    Base.dataids(A::AbstractArray)\n\nReturn a tuple of `UInt`s that represent the mutable data segments of an array.\n\nCustom arrays that would like to opt-in to aliasing detection of their component\nparts can specialize this method to return the concatenation of the `dataids` of\ntheir component parts.  A typical definition for an array that wraps a parent is\n`Base.dataids(C::CustomArray) = dataids(C.parent)`.\n"}],"Base.has_offset_axes":[{"Tuple{Any}":"    has_offset_axes(A)\n    has_offset_axes(A, B, ...)\n\nReturn `true` if the indices of `A` start with something other than 1 along any axis.\nIf multiple arguments are passed, equivalent to `has_offset_axes(A) | has_offset_axes(B) | ...`.\n"}],"Base.may_invoke_generator":[{"Tuple{Core.MethodInstance}":"    may_invoke_generator(method, atypes, sparams)\n\nComputes whether or not we may invoke the generator for the given `method` on\nthe given atypes and sparams. For correctness, all generated function are\nrequired to return monotonic answers. However, since we don't expect users to\nbe able to successfully implement this criterion, we only call generated\nfunctions on concrete types. The one exception to this is that we allow calling\ngenerators with abstract types if the generator does not use said abstract type\n(and thus cannot incorrectly use it to break monotonicity). This function\ncomputes whether we are in either of these cases.\n\nUnlike normal functions, the compilation heuristics still can't generate good dispatch\nin some cases, but this may still allow inference not to fall over in some limited cases.\n"}],"Base.close":[{"Union{}":"    close(stream)\n\nClose an I/O stream. Performs a [`flush`](@ref) first.\n"},{"Union{Tuple{Channel}, Tuple{Channel,Exception}}":"    close(c::Channel[, excp::Exception])\n\nClose a channel. An exception (optionally given by `excp`), is thrown by:\n\n* [`put!`](@ref) on a closed channel.\n* [`take!`](@ref) and [`fetch`](@ref) on an empty, closed channel.\n"}],"Base.bind":[{"Tuple{Channel,Task}":"    bind(chnl::Channel, task::Task)\n\nAssociate the lifetime of `chnl` with a task.\n`Channel` `chnl` is automatically closed when the task terminates.\nAny uncaught exception in the task is propagated to all waiters on `chnl`.\n\nThe `chnl` object can be explicitly closed independent of task termination.\nTerminating tasks have no effect on already closed `Channel` objects.\n\nWhen a channel is bound to multiple tasks, the first task to terminate will\nclose the channel. When multiple channels are bound to the same task,\ntermination of the task will close all of the bound channels.\n\n# Examples\n```jldoctest\njulia> c = Channel(0);\n\njulia> task = @async foreach(i->put!(c, i), 1:4);\n\njulia> bind(c,task);\n\njulia> for i in c\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\njulia> isopen(c)\nfalse\n```\n\n```jldoctest\njulia> c = Channel(0);\n\njulia> task = @async (put!(c,1);error(\"foo\"));\n\njulia> bind(c,task);\n\njulia> take!(c)\n1\n\njulia> put!(c,1);\nERROR: foo\nStacktrace:\n[...]\n```\n"}],"Base.startswith":[{"Tuple{AbstractString,Regex}":"    startswith(s::AbstractString, prefix::Regex)\n\nReturn `true` if `s` starts with the regex pattern, `prefix`.\n\n!!! note\n    `startswith` does not compile the anchoring into the regular\n    expression, but instead passes the anchoring as\n    `match_option` to PCRE. If compile time is amortized,\n    `occursin(r\"^...\", s)` is faster than `startswith(s, r\"...\")`.\n\nSee also [`occursin`](@ref) and [`endswith`](@ref).\n\n!!! compat \"Julia 1.2\"\n     This method requires at least Julia 1.2.\n\n# Examples\n```jldoctest\njulia> startswith(\"JuliaLang\", r\"Julia|Romeo\")\ntrue\n```\n"},{"Tuple{AbstractString,AbstractString}":"    startswith(s::AbstractString, prefix::AbstractString)\n\nReturn `true` if `s` starts with `prefix`. If `prefix` is a vector or set\nof characters, test whether the first character of `s` belongs to that set.\n\nSee also [`endswith`](@ref).\n\n# Examples\n```jldoctest\njulia> startswith(\"JuliaLang\", \"Julia\")\ntrue\n```\n"}],"Base.tail":[{"Tuple{Tuple}":"    tail(x::Tuple)::Tuple\n\nReturn a `Tuple` consisting of all but the first component of `x`.\n\n# Examples\n```jldoctest\njulia> Base.tail((1,2,3))\n(2, 3)\n\njulia> Base.tail(())\nERROR: ArgumentError: Cannot call tail on an empty tuple.\n```\n"}],"Base.floor":[{"Union{}":"    floor([T,] x)\n    floor(x; digits::Integer= [, base = 10])\n    floor(x; sigdigits::Integer= [, base = 10])\n\n`floor(x)` returns the nearest integral value of the same type as `x` that is less than or\nequal to `x`.\n\n`floor(T, x)` converts the result to type `T`, throwing an `InexactError` if the value is\nnot representable.\n\n`digits`, `sigdigits` and `base` work as for [`round`](@ref).\n"}],"Base.numerator":[{"Tuple{Integer}":"    numerator(x)\n\nNumerator of the rational representation of `x`.\n\n# Examples\n```jldoctest\njulia> numerator(2//3)\n2\n\njulia> numerator(4)\n4\n```\n"}],"Base.accumulate":[{"Tuple{Any,Any}":"    accumulate(op, A; dims::Integer, [init])\n\nCumulative operation `op` along the dimension `dims` of `A` (providing `dims` is optional\nfor vectors). An initial value `init` may optionally be provided by a keyword argument. See\nalso [`accumulate!`](@ref) to use a preallocated output array, both for performance and\nto control the precision of the output (e.g. to avoid overflow). For common operations\nthere are specialized variants of `accumulate`, see: [`cumsum`](@ref), [`cumprod`](@ref)\n\n# Examples\n```jldoctest\njulia> accumulate(+, [1,2,3])\n3-element Array{Int64,1}:\n 1\n 3\n 6\n\njulia> accumulate(*, [1,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\njulia> accumulate(+, [1,2,3]; init=100)\n3-element Array{Int64,1}:\n 101\n 103\n 106\n\njulia> accumulate(min, [1,2,-1]; init=0)\n3-element Array{Int64,1}:\n  0\n  0\n -1\n\njulia> accumulate(+, fill(1, 3, 3), dims=1)\n3×3 Array{Int64,2}:\n 1  1  1\n 2  2  2\n 3  3  3\n\njulia> accumulate(+, fill(1, 3, 3), dims=2)\n3×3 Array{Int64,2}:\n 1  2  3\n 1  2  3\n 1  2  3\n```\n"}],"Base.islocked":[{"Tuple{ReentrantLock}":"    islocked(lock) -> Status (Boolean)\n\nCheck whether the `lock` is held by any task/thread.\nThis should not be used for synchronization (see instead [`trylock`](@ref)).\n"}],"Base.isprimitivetype":[{"Tuple{Type}":"    isprimitivetype(T) -> Bool\n\nDetermine whether type `T` was declared as a primitive type\n(i.e. using the `primitive` keyword).\n"}],"Base.mapreduce_empty":[{"Tuple{Any,Any,Any}":"    Base.mapreduce_empty(f, op, T)\n\nThe value to be returned when calling [`mapreduce`](@ref), [`mapfoldl`](@ref`) or\n[`mapfoldr`](@ref) with map `f` and reduction `op` over an empty array with element type\nof `T`.\n\nIf not defined, this will throw an `ArgumentError`.\n"}],"Base.div12":[{"Union{Tuple{T}, Tuple{T,T}} where T<:AbstractFloat":"    zhi, zlo = div12(x, y)\n\nA high-precision representation of `x / y` for floating-point\nnumbers. Mathematically, `zhi + zlo ≈ x / y`, where `zhi` contains the\nmost significant bits and `zlo` the least significant.\n\nExample:\n```julia\njulia> x, y = Float32(π), 3.1f0\n(3.1415927f0, 3.1f0)\n\njulia> x / y\n1.013417f0\n\njulia> Float64(x) / Float64(y)\n1.0134170444063078\n\njulia> hi, lo = Base.div12(x, y)\n(1.013417f0, 3.8867366f-8)\n\njulia> Float64(hi) + Float64(lo)\n1.0134170444063066\n"}],"Base.operator_precedence":[{"Tuple{Symbol}":"    operator_precedence(s::Symbol)\n\nReturn an integer representing the precedence of operator `s`, relative to\nother operators. Higher-numbered operators take precedence over lower-numbered\noperators. Return `0` if `s` is not a valid operator.\n\n# Examples\n```jldoctest\njulia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\n(11, 12, 17)\n\njulia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\n(0, 1, 1)\n```\n"}],"Base.isinteger":[{"Tuple{Integer}":"    isinteger(x) -> Bool\n\nTest whether `x` is numerically equal to some integer.\n\n# Examples\n```jldoctest\njulia> isinteger(4.0)\ntrue\n```\n"}],"Base.AbstractVector":[{"Union{}":"    AbstractVector{T}\n\nSupertype for one-dimensional arrays (or array-like types) with\nelements of type `T`. Alias for [`AbstractArray{T,1}`](@ref).\n"}],"Base.big":[{"Union{Tuple{Type{T}}, Tuple{T}} where T<:Number":"    big(T::Type)\n\nCompute the type that represents the numeric type `T` with arbitrary precision.\nEquivalent to `typeof(big(zero(T)))`.\n\n# Examples\n```jldoctest\njulia> big(Rational)\nRational{BigInt}\n\njulia> big(Float64)\nBigFloat\n\njulia> big(Complex{Int})\nComplex{BigInt}\n```\n"}],"Base.fdio":[{"Union{Tuple{AbstractString,Integer}, Tuple{AbstractString,Integer,Bool}}":"    fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream\n\nCreate an [`IOStream`](@ref) object from an integer file descriptor. If `own` is `true`, closing\nthis object will close the underlying descriptor. By default, an `IOStream` is closed when\nit is garbage collected. `name` allows you to associate the descriptor with a named file.\n"}],"Base.IndexStyle":[{"Tuple{AbstractArray}":"    IndexStyle(A)\n    IndexStyle(typeof(A))\n\n`IndexStyle` specifies the \"native indexing style\" for array `A`. When\nyou define a new [`AbstractArray`](@ref) type, you can choose to implement\neither linear indexing (with [`IndexLinear`](@ref)) or cartesian indexing.\nIf you decide to only implement linear indexing, then you must set this trait for your array\ntype:\n\n    Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n\nThe default is [`IndexCartesian()`](@ref).\n\nJulia's internal indexing machinery will automatically (and invisibly)\nrecompute all indexing operations into the preferred style. This allows users\nto access elements of your array using any indexing style, even when explicit\nmethods have not been provided.\n\nIf you define both styles of indexing for your `AbstractArray`, this\ntrait can be used to select the most performant indexing style. Some\nmethods check this trait on their inputs, and dispatch to different\nalgorithms depending on the most efficient access pattern. In\nparticular, [`eachindex`](@ref) creates an iterator whose type depends\non the setting of this trait.\n"}],"Base.union":[{"Union{}":"    union(s, itrs...)\n    ∪(s, itrs...)\n\nConstruct the union of sets. Maintain order with arrays.\n\n# Examples\n```jldoctest\njulia> union([1, 2], [3, 4])\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> union([1, 2], [2, 4])\n3-element Array{Int64,1}:\n 1\n 2\n 4\n\njulia> union([4, 2], 1:2)\n3-element Array{Int64,1}:\n 4\n 2\n 1\n\njulia> union(Set([1, 2]), 2:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n```\n"}],"Base.replace":[{"Tuple{AbstractString,Pair}":"    replace(s::AbstractString, pat=>r; [count::Integer])\n\nSearch for the given pattern `pat` in `s`, and replace each occurrence with `r`.\nIf `count` is provided, replace at most `count` occurrences.\n`pat` may be a single character, a vector or a set of characters, a string,\nor a regular expression.\nIf `r` is a function, each occurrence is replaced with `r(s)`\nwhere `s` is the matched substring (when `pat` is a `Regex` or `AbstractString`) or\ncharacter (when `pat` is an `AbstractChar` or a collection of `AbstractChar`).\nIf `pat` is a regular expression and `r` is a [`SubstitutionString`](@ref), then capture group\nreferences in `r` are replaced with the corresponding matched text.\nTo remove instances of `pat` from `string`, set `r` to the empty `String` (`\"\"`).\n\n# Examples\n```jldoctest\njulia> replace(\"Python is a programming language.\", \"Python\" => \"Julia\")\n\"Julia is a programming language.\"\n\njulia> replace(\"The quick foxes run quickly.\", \"quick\" => \"slow\", count=1)\n\"The slow foxes run quickly.\"\n\njulia> replace(\"The quick foxes run quickly.\", \"quick\" => \"\", count=1)\n\"The  foxes run quickly.\"\n\njulia> replace(\"The quick foxes run quickly.\", r\"fox(es)?\" => s\"bus\\1\")\n\"The quick buses run quickly.\"\n```\n"},{"Tuple{Union{Function, Type},Any}":"    replace(new::Function, A; [count::Integer])\n\nReturn a copy of `A` where each value `x` in `A` is replaced by `new(x)`\nIf `count` is specified, then replace at most `count` values in total\n(replacements being defined as `new(x) !== x`).\n\n# Examples\n```jldoctest\njulia> replace(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\n4-element Array{Int64,1}:\n 2\n 2\n 6\n 4\n\njulia> replace(Dict(1=>2, 3=>4)) do kv\n           first(kv) < 3 ? first(kv)=>3 : kv\n       end\nDict{Int64,Int64} with 2 entries:\n  3 => 4\n  1 => 3\n```\n"},{"Tuple{Any,Vararg{Pair,N} where N}":"    replace(A, old_new::Pair...; [count::Integer])\n\nReturn a copy of collection `A` where, for each pair `old=>new` in `old_new`,\nall occurrences of `old` are replaced by `new`.\nEquality is determined using [`isequal`](@ref).\nIf `count` is specified, then replace at most `count` occurrences in total.\n\nThe element type of the result is chosen using promotion (see [`promote_type`](@ref))\nbased on the element type of `A` and on the types of the `new` values in pairs.\nIf `count` is omitted and the element type of `A` is a `Union`, the element type\nof the result will not include singleton types which are replaced with values of\na different type: for example, `Union{T,Missing}` will become `T` if `missing` is\nreplaced.\n\nSee also [`replace!`](@ref).\n\n# Examples\n```jldoctest\njulia> replace([1, 2, 1, 3], 1=>0, 2=>4, count=2)\n4-element Array{Int64,1}:\n 0\n 4\n 1\n 3\n\njulia> replace([1, missing], missing=>0)\n2-element Array{Int64,1}:\n 1\n 0\n```\n"}],"Base.maximum":[{"Tuple{Any}":"    maximum(itr)\n\nReturns the largest element in a collection.\n\n# Examples\n```jldoctest\njulia> maximum(-20.5:10)\n9.5\n\njulia> maximum([1,2,3])\n3\n```\n"},{"Tuple{AbstractArray}":"    maximum(A::AbstractArray; dims)\n\nCompute the maximum value of an array over the given dimensions. See also the\n[`max(a,b)`](@ref) function to take the maximum of two or more arguments,\nwhich can be applied elementwise to arrays via `max.(a,b)`.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> maximum(A, dims=1)\n1×2 Array{Int64,2}:\n 3  4\n\njulia> maximum(A, dims=2)\n2×1 Array{Int64,2}:\n 2\n 4\n```\n"},{"Tuple{Any,Any}":"    maximum(f, itr)\n\nReturns the largest result of calling function `f` on each element of `itr`.\n\n# Examples\n```jldoctest\njulia> maximum(length, [\"Julion\", \"Julia\", \"Jule\"])\n6\n```\n"}],"Base.notnothing":[{"Tuple{Any}":"    notnothing(x)\n\nThrow an error if `x === nothing`, and return `x` if not.\n"}],"Base.backtrace":[{"Tuple{}":"    backtrace()\n\nGet a backtrace object for the current program point.\n"}],"Base.empty":[{"Tuple{AbstractDict}":"    empty(a::AbstractDict, [index_type=keytype(a)], [value_type=valtype(a)])\n\nCreate an empty `AbstractDict` container which can accept indices of type `index_type` and\nvalues of type `value_type`. The second and third arguments are optional and default to the\ninput's `keytype` and `valtype`, respectively. (If only one of the two types is specified,\nit is assumed to be the `value_type`, and the `index_type` we default to `keytype(a)`).\n\nCustom `AbstractDict` subtypes may choose which specific dictionary type is best suited to\nreturn for the given index and value types, by specializing on the three-argument signature.\nThe default is to return an empty `Dict`.\n"},{"Tuple{Tuple}":"    empty(x::Tuple)\n\nReturns an empty tuple, `()`.\n"},{"Union{Tuple{AbstractArray{T,1}}, Tuple{U}, Tuple{T}, Tuple{AbstractArray{T,1},Type{U}}} where U where T":"    empty(v::AbstractVector, [eltype])\n\nCreate an empty vector similar to `v`, optionally changing the `eltype`.\n\n# Examples\n\n```jldoctest\njulia> empty([1.0, 2.0, 3.0])\n0-element Array{Float64,1}\n\njulia> empty([1.0, 2.0, 3.0], String)\n0-element Array{String,1}\n```\n"}],"Base.unsigned":[{"Tuple{Any}":"    unsigned(x) -> Unsigned\n\nConvert a number to an unsigned integer. If the argument is signed, it is reinterpreted as\nunsigned without checking for negative values.\n\n# Examples\n```jldoctest\njulia> unsigned(-2)\n0xfffffffffffffffe\n\njulia> unsigned(2)\n0x0000000000000002\n\njulia> signed(unsigned(-2))\n-2\n```\n"}],"Base.floatmin":[{"Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat":"    floatmin(T)\n\nThe smallest in absolute value non-subnormal value representable by the given\nfloating-point DataType `T`.\n"}],"Base.string":[{"Tuple":"    string(xs...)\n\nCreate a string from any values, except `nothing`, using the [`print`](@ref) function.\n\n`string` should usually not be defined directly. Instead, define a method\n`print(io::IO, x::MyType)`. If `string(x)` for a certain type needs to be\nhighly efficient, then it may make sense to add a method to `string` and\ndefine `print(io::IO, x::MyType) = print(io, string(x))` to ensure the\nfunctions are consistent.\n\n# Examples\n```jldoctest\njulia> string(\"a\", 1, true)\n\"a1true\"\n```\n"},{"Tuple{Integer}":"    string(n::Integer; base::Integer = 10, pad::Integer = 1)\n\nConvert an integer `n` to a string in the given `base`,\noptionally specifying a number of digits to pad to.\n\n```jldoctest\njulia> string(5, base = 13, pad = 4)\n\"0005\"\n\njulia> string(13, base = 5, pad = 4)\n\"0023\"\n```\n"}],"Base.StringIndexError":[{"Union{}":"    StringIndexError(str, i)\n\nAn error occurred when trying to access `str` at index `i` that is not valid.\n"}],"Base.@r_str":[{"Tuple{Any,Vararg{Any,N} where N}":"    @r_str -> Regex\n\nConstruct a regex, such as `r\"^[a-z]*$\"`, without interpolation and unescaping (except for\nquotation mark `\"` which still has to be escaped). The regex also accepts one or more flags,\nlisted after the ending quote, to change its behaviour:\n\n- `i` enables case-insensitive matching\n- `m` treats the `^` and `$` tokens as matching the start and end of individual lines, as\n  opposed to the whole string.\n- `s` allows the `.` modifier to match newlines.\n- `x` enables \"comment mode\": whitespace is enabled except when escaped with `\\`, and `#`\n  is treated as starting a comment.\n- `a` disables `UCP` mode (enables ASCII mode). By default `\\B`, `\\b`, `\\D`, `\\d`, `\\S`,\n  `\\s`, `\\W`, `\\w`, etc. match based on Unicode character properties. With this option,\n  these sequences only match ASCII characters.\n\nSee `Regex` if interpolation is needed.\n\n# Examples\n```jldoctest\njulia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")\n```\nThis regex has the first three flags enabled.\n"}],"Base.round":[{"Tuple{Type,Any}":"    round([T,] x, [r::RoundingMode])\n    round(x, [r::RoundingMode]; digits::Integer=0, base = 10)\n    round(x, [r::RoundingMode]; sigdigits::Integer, base = 10)\n\nRounds the number `x`.\n\nWithout keyword arguments, `x` is rounded to an integer value, returning a value of type\n`T`, or of the same type of `x` if no `T` is provided. An [`InexactError`](@ref) will be\nthrown if the value is not representable by `T`, similar to [`convert`](@ref).\n\nIf the `digits` keyword argument is provided, it rounds to the specified number of digits\nafter the decimal place (or before if negative), in base `base`.\n\nIf the `sigdigits` keyword argument is provided, it rounds to the specified number of\nsignificant digits, in base `base`.\n\nThe [`RoundingMode`](@ref) `r` controls the direction of the rounding; the default is\n[`RoundNearest`](@ref), which rounds to the nearest integer, with ties (fractional values\nof 0.5) being rounded to the nearest even integer. Note that `round` may give incorrect\nresults if the global rounding mode is changed (see [`rounding`](@ref)).\n\n# Examples\n```jldoctest\njulia> round(1.7)\n2.0\n\njulia> round(Int, 1.7)\n2\n\njulia> round(1.5)\n2.0\n\njulia> round(2.5)\n2.0\n\njulia> round(pi; digits=2)\n3.14\n\njulia> round(pi; digits=3, base=2)\n3.125\n\njulia> round(123.456; sigdigits=2)\n120.0\n\njulia> round(357.913; sigdigits=4, base=2)\n352.0\n```\n\n!!! note\n    Rounding to specified digits in bases other than 2 can be inexact when\n    operating on binary floating point numbers. For example, the [`Float64`](@ref)\n    value represented by `1.15` is actually *less* than 1.15, yet will be\n    rounded to 1.2.\n\n    # Examples\n    ```jldoctest; setup = :(using Printf)\n    julia> x = 1.15\n    1.15\n\n    julia> @sprintf \"%.20f\" x\n    \"1.14999999999999991118\"\n\n    julia> x < 115//100\n    true\n\n    julia> round(x, digits=1)\n    1.2\n    ```\n\n# Extensions\n\nTo extend `round` to new numeric types, it is typically sufficient to define `Base.round(x::NewType, r::RoundingMode)`.\n"},{"Union{Tuple{Complex}, Tuple{Complex,RoundingMode}, Tuple{Complex,RoundingMode,RoundingMode}}":"    round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])\n    round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)\n    round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)\n\nReturn the nearest integral value of the same type as the complex-valued `z` to `z`,\nbreaking ties using the specified [`RoundingMode`](@ref)s. The first\n[`RoundingMode`](@ref) is used for rounding the real components while the\nsecond is used for rounding the imaginary components.\n\n# Example\n```jldoctest\njulia> round(3.14 + 4.5im)\n3.0 + 4.0im\n```\n"}],"Base.showarg":[{"Union{Tuple{T}, Tuple{IO,Type{T},Any}} where T":"    showarg(io::IO, x, toplevel)\n\nShow `x` as if it were an argument to a function. This function is\nused by [`summary`](@ref) to display type information in terms of sequences of\nfunction calls on objects. `toplevel` is `true` if this is\nthe direct call from `summary` and `false` for nested (recursive) calls.\n\nThe fallback definition is to print `x` as \"::\\$(typeof(x))\",\nrepresenting argument `x` in terms of its type. (The double-colon is\nomitted if `toplevel=true`.) However, you can\nspecialize this function for specific types to customize printing.\n\n# Example\n\nA SubArray created as `view(a, :, 3, 2:5)`, where `a` is a\n3-dimensional Float64 array, has type\n\n    SubArray{Float64,2,Array{Float64,3},Tuple{Colon,Int64,UnitRange{Int64}},false}\n\nThe default `show` printing would display this full type.\nHowever, the summary for SubArrays actually prints as\n\n    2×4 view(::Array{Float64,3}, :, 3, 2:5) with eltype Float64\n\nbecause of a definition similar to\n\n    function Base.showarg(io::IO, v::SubArray, toplevel)\n        print(io, \"view(\")\n        showarg(io, parent(v), false)\n        print(io, \", \", join(v.indices, \", \"))\n        print(io, ')')\n        toplevel && print(io, \" with eltype \", eltype(v))\n    end\n\nNote that we're calling `showarg` recursively for the parent array\ntype, indicating that any recursed calls are not at the top level.\nPrinting the parent as `::Array{Float64,3}` is the fallback (non-toplevel)\nbehavior, because no specialized method for `Array` has been defined.\n"}],"Base.<=":[{"Tuple{Any}":"    <=(x)\n\nCreate a function that compares its argument to `x` using [`<=`](@ref), i.e.\na function equivalent to `y -> y <= x`.\nThe returned function is of type `Base.Fix2{typeof(<=)}`, which can be\nused to implement specialized methods.\n\n!!! compat \"Julia 1.2\"\n    This functionality requires at least Julia 1.2.\n"},{"Tuple{Any,Any}":"    <=(x, y)\n    ≤(x,y)\n\nLess-than-or-equals comparison operator. Falls back to `(x < y) | (x == y)`.\n\n# Examples\n```jldoctest\njulia> 'a' <= 'b'\ntrue\n\njulia> 7 ≤ 7 ≤ 9\ntrue\n\njulia> \"abc\" ≤ \"abc\"\ntrue\n\njulia> 5 <= 3\nfalse\n```\n"}],"Base.sleep":[{"Tuple{Real}":"    sleep(seconds)\n\nBlock the current task for a specified number of seconds. The minimum sleep time is 1\nmillisecond or input of `0.001`.\n"}],"Base.sum":[{"Tuple{Any}":"    sum(itr)\n\nReturns the sum of all elements in a collection.\n\nThe return type is `Int` for signed integers of less than system word size, and\n`UInt` for unsigned integers of less than system word size.  For all other\narguments, a common return type is found to which all arguments are promoted.\n\n# Examples\n```jldoctest\njulia> sum(1:20)\n210\n```\n"},{"Tuple{AbstractArray}":"    sum(A::AbstractArray; dims)\n\nSum elements of an array over the given dimensions.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> sum(A, dims=1)\n1×2 Array{Int64,2}:\n 4  6\n\njulia> sum(A, dims=2)\n2×1 Array{Int64,2}:\n 3\n 7\n```\n"},{"Tuple{Any,Any}":"    sum(f, itr)\n\nSum the results of calling function `f` on each element of `itr`.\n\nThe return type is `Int` for signed integers of less than system word size, and\n`UInt` for unsigned integers of less than system word size.  For all other\narguments, a common return type is found to which all arguments are promoted.\n\n# Examples\n```jldoctest\njulia> sum(abs2, [2; 3; 4])\n29\n```\n\nNote the important difference between `sum(A)` and `reduce(+, A)` for arrays\nwith small integer eltype:\n\n```jldoctest\njulia> sum(Int8[100, 28])\n128\n\njulia> reduce(+, Int8[100, 28])\n-128\n```\n\nIn the former case, the integers are widened to system word size and therefore\nthe result is 128. In the latter case, no such widening happens and integer\noverflow results in -128.\n"}],"Base.leading_zeros":[{"Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}":"    leading_zeros(x::Integer) -> Integer\n\nNumber of zeros leading the binary representation of `x`.\n\n# Examples\n```jldoctest\njulia> leading_zeros(Int32(1))\n31\n```\n"}],"Base.selectdim":[{"Tuple{AbstractArray,Integer,Any}":"    selectdim(A, d::Integer, i)\n\nReturn a view of all the data of `A` where the index for dimension `d` equals `i`.\n\nEquivalent to `view(A,:,:,...,i,:,:,...)` where `i` is in position `d`.\n\n# Examples\n```jldoctest\njulia> A = [1 2 3 4; 5 6 7 8]\n2×4 Array{Int64,2}:\n 1  2  3  4\n 5  6  7  8\n\njulia> selectdim(A, 2, 3)\n2-element view(::Array{Int64,2}, :, 3) with eltype Int64:\n 3\n 7\n```\n"}],"Base.@propagate_inbounds":[{"Tuple{Any}":"    @propagate_inbounds\n\nTells the compiler to inline a function while retaining the caller's inbounds context.\n"}],"Base.withenv":[{"Union{Tuple{T}, Tuple{Function,Vararg{Pair{T,B} where B,N} where N}} where T<:AbstractString":"    withenv(f::Function, kv::Pair...)\n\nExecute `f` in an environment that is temporarily modified (not replaced as in `setenv`)\nby zero or more `\"var\"=>val` arguments `kv`. `withenv` is generally used via the\n`withenv(kv...) do ... end` syntax. A value of `nothing` can be used to temporarily unset an\nenvironment variable (if it is set). When `withenv` returns, the original environment has\nbeen restored.\n"}],"Base.mapreduce":[{"Tuple{Any,Any,Any}":"    mapreduce(f, op, itrs...; [init])\n\nApply function `f` to each element(s) in `itrs`, and then reduce the result using the binary\nfunction `op`. If provided, `init` must be a neutral element for `op` that will be returned\nfor empty collections. It is unspecified whether `init` is used for non-empty collections.\nIn general, it will be necessary to provide `init` to work with empty collections.\n\n[`mapreduce`](@ref) is functionally equivalent to calling\n`reduce(op, map(f, itr); init=init)`, but will in general execute faster since no\nintermediate collection needs to be created. See documentation for [`reduce`](@ref) and\n[`map`](@ref).\n\n!!! compat \"Julia 1.2\"\n    `mapreduce` with multiple iterators requires Julia 1.2 or later.\n\n# Examples\n```jldoctest\njulia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9\n14\n```\n\nThe associativity of the reduction is implementation-dependent. Additionally, some\nimplementations may reuse the return value of `f` for elements that appear multiple times in\n`itr`. Use [`mapfoldl`](@ref) or [`mapfoldr`](@ref) instead for\nguaranteed left or right associativity and invocation of `f` for every value.\n"},{"Tuple{Any,Any,AbstractArray}":"    mapreduce(f, op, A::AbstractArray...; dims=:, [init])\n\nEvaluates to the same as `reduce(op, map(f, A); dims=dims, init=init)`, but is generally\nfaster because the intermediate array is avoided.\n\n!!! compat \"Julia 1.2\"\n    `mapreduce` with multiple iterators requires Julia 1.2 or later.\n\n# Examples\n```jldoctest\njulia> a = reshape(Vector(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> mapreduce(isodd, *, a, dims=1)\n1×4 Array{Bool,2}:\n 0  0  0  0\n\njulia> mapreduce(isodd, |, a, dims=1)\n1×4 Array{Bool,2}:\n 1  1  1  1\n```\n"}],"Base.foreach":[{"Tuple{Any}":"    foreach(f, c...) -> Nothing\n\nCall function `f` on each element of iterable `c`.\nFor multiple iterable arguments, `f` is called elementwise.\n`foreach` should be used instead of `map` when the results of `f` are not\nneeded, for example in `foreach(println, array)`.\n\n# Examples\n```jldoctest\njulia> a = 1:3:7;\n\njulia> foreach(x -> println(x^2), a)\n1\n16\n49\n```\n"}],"Base.issingletontype":[{"Tuple{Any}":"    Base.issingletontype(T)\n\nDetermine whether type `T` has exactly one possible instance; for example, a\nstruct type with no fields.\n"}],"Base.hcat":[{"Tuple":"    hcat(A...)\n\nConcatenate along dimension 2.\n\n# Examples\n```jldoctest\njulia> a = [1; 2; 3; 4; 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> b = [6 7; 8 9; 10 11; 12 13; 14 15]\n5×2 Array{Int64,2}:\n  6   7\n  8   9\n 10  11\n 12  13\n 14  15\n\njulia> hcat(a,b)\n5×3 Array{Int64,2}:\n 1   6   7\n 2   8   9\n 3  10  11\n 4  12  13\n 5  14  15\n\njulia> c = ([1; 2; 3], [4; 5; 6])\n([1, 2, 3], [4, 5, 6])\n\njulia> hcat(c...)\n3×2 Array{Int64,2}:\n 1  4\n 2  5\n 3  6\n```\n"}],"Base.append!":[{"Tuple{Array{T,1} where T,AbstractArray{T,1} where T}":"    append!(collection, collection2) -> collection.\n\nFor an ordered container `collection`, add the elements of `collection2` to the end of it.\n\n# Examples\n```jldoctest\njulia> append!([1],[2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> append!([1, 2, 3], [4, 5, 6])\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n```\n\nUse [`push!`](@ref) to add individual items to `collection` which are not already\nthemselves in another collection. The result of the preceding example is equivalent to\n`push!([1, 2, 3], 4, 5, 6)`.\n"}],"Base.precompile":[{"Tuple{Any,Tuple}":"    precompile(f, args::Tuple{Vararg{Any}})\n\nCompile the given function `f` for the argument tuple (of types) `args`, but do not execute it.\n"}],"Base.findlast":[{"Tuple{Any}":"    findlast(A)\n\nReturn the index or key of the last `true` value in `A`.\nReturn `nothing` if there is no `true` value in `A`.\n\nIndices or keys are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [true, false, true, false]\n4-element Array{Bool,1}:\n 1\n 0\n 1\n 0\n\njulia> findlast(A)\n3\n\njulia> A = falses(2,2);\n\njulia> findlast(A) # returns nothing, but not printed in the REPL\n\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n 1  0\n 1  0\n\njulia> findlast(A)\nCartesianIndex(2, 1)\n```\n"},{"Tuple{Function,Any}":"    findlast(predicate::Function, A)\n\nReturn the index or key of the last element of `A` for which `predicate` returns `true`.\nReturn `nothing` if there is no such element.\n\nIndices or keys are of the same type as those returned by [`keys(A)`](@ref)\nand [`pairs(A)`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [1, 2, 3, 4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> findlast(isodd, A)\n3\n\njulia> findlast(x -> x > 5, A) # returns nothing, but not printed in the REPL\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> findlast(isodd, A)\nCartesianIndex(2, 1)\n```\n"},{"Tuple{AbstractString,AbstractString}":"    findlast(pattern::AbstractString, string::AbstractString)\n\nFind the last occurrence of `pattern` in `string`. Equivalent to\n[`findprev(pattern, string, lastindex(string))`](@ref).\n\n# Examples\n```jldoctest\njulia> findlast(\"o\", \"Hello to the world\")\n15:15\n\njulia> findfirst(\"Julia\", \"JuliaLang\")\n1:5\n```\n"},{"Tuple{AbstractChar,AbstractString}":"    findlast(ch::AbstractChar, string::AbstractString)\n\nFind the last occurrence of character `ch` in `string`.\n\n!!! compat \"Julia 1.3\"\n    This method requires at least Julia 1.3.\n\n# Examples\n```jldoctest\njulia> findlast('p', \"happy\")\n4\n\njulia> findlast('z', \"happy\") === nothing\ntrue\n```\n"}],"Base.Cushort":[{"Union{}":"    Cushort\n\nEquivalent to the native `unsigned short` c-type ([`UInt16`](@ref)).\n"}],"Base.datatype_haspadding":[{"Tuple{DataType}":"    Base.datatype_haspadding(dt::DataType) -> Bool\n\nReturn whether the fields of instances of this type are packed in memory,\nwith no intervening padding bytes.\nCan be called on any `isconcretetype`.\n"}],"Base.@s_str":[{"Tuple{Any}":"    @s_str -> SubstitutionString\n\nConstruct a substitution string, used for regular expression substitutions.  Within the\nstring, sequences of the form `\\N` refer to the Nth capture group in the regex, and\n`\\g<groupname>` refers to a named capture group with name `groupname`.\n\n```jldoctest\njulia> msg = \"#Hello# from Julia\";\n\njulia> replace(msg, r\"#(.+)# from (?<from>\\w+)\" => s\"FROM: \\g<from>; MESSAGE: \\1\")\n\"FROM: Julia; MESSAGE: Hello\"\n```\n"}],"Base.@__FILE__":[{"Tuple{}":"    @__FILE__ -> AbstractString\n\nExpand to a string with the path to the file containing the\nmacrocall, or an empty string if evaluated by `julia -e <expr>`.\nReturn `nothing` if the macro was missing parser source information.\nAlternatively see [`PROGRAM_FILE`](@ref).\n"}],"Base.uabs":[{"Tuple{Integer}":"    uabs(x::Integer)\n\nReturn the absolute value of `x`, possibly returning a different type should the\noperation be susceptible to overflow. This typically arises when `x` is a two's complement\nsigned integer, so that `abs(typemin(x)) == typemin(x) < 0`, in which case the result of\n`uabs(x)` will be an unsigned integer of the same size.\n"}],"Base.Semaphore":[{"Union{}":"    Semaphore(sem_size)\n\nCreate a counting semaphore that allows at most `sem_size`\nacquires to be in use at any time.\nEach acquire must be matched with a release.\n"}],"Base.reset":[{"Union{Tuple{T}, Tuple{T}} where T<:IO":"    reset(s)\n\nReset a stream `s` to a previously marked position, and remove the mark. Return the\npreviously marked position. Throw an error if the stream is not marked.\n\nSee also [`mark`](@ref), [`unmark`](@ref), [`ismarked`](@ref).\n"}],"Base.canonicalize2":[{"Tuple{Any,Any}":"    hi, lo = canonicalize2(big, little)\n\nGenerate a representation where all the nonzero bits in `hi` are more\nsignificant than any of the nonzero bits in `lo`. `big` must be larger\nin absolute value than `little`.\n"}],"Base.include":[{"Union{}":"    Base.include([m::Module,] path::AbstractString)\n\nEvaluate the contents of the input source file in the global scope of module `m`.\nEvery module (except those defined with [`baremodule`](@ref)) has its own 1-argument\ndefinition of `include`, which evaluates the file in that module.\nReturns the result of the last evaluated expression of the input file. During including,\na task-local include path is set to the directory containing the file. Nested calls to\n`include` will search relative to that path. This function is typically used to load source\ninteractively, or to combine files in packages that are broken into multiple source files.\n"}],"Base.Irrational":[{"Union{}":"    Irrational{sym} <: AbstractIrrational\n\nNumber type representing an exact irrational value denoted by the\nsymbol `sym`.\n"}],"Base.@irrational":[{"Tuple{Any,Any,Any}":"\t@irrational sym val def\n\t@irrational(sym, val, def)\n\nDefine a new `Irrational` value, `sym`, with pre-computed `Float64` value `val`,\nand arbitrary-precision definition in terms of `BigFloat`s given be the expression `def`.\n"}],"Base.mod":[{"Tuple{Integer,Base.OneTo}":"    mod(x::Integer, r::AbstractUnitRange)\n\nFind `y` in the range `r` such that ``x ≡ y (mod n)``, where `n = length(r)`,\ni.e. `y = mod(x - first(r), n) + first(r)`.\n\nSee also: [`mod1`](@ref).\n\n# Examples\n```jldoctest\njulia> mod(0, Base.OneTo(3))\n3\n\njulia> mod(3, 0:2)\n0\n```\n\n!!! compat \"Julia 1.3\"\n     This method requires at least Julia 1.3.\n"},{"Tuple{Integer,Type{#s662} where #s662<:Integer}":"    rem(x::Integer, T::Type{<:Integer}) -> T\n    mod(x::Integer, T::Type{<:Integer}) -> T\n    %(x::Integer, T::Type{<:Integer}) -> T\n\nFind `y::T` such that `x` ≡ `y` (mod n), where n is the number of integers representable\nin `T`, and `y` is an integer in `[typemin(T),typemax(T)]`.\nIf `T` can represent any integer (e.g. `T == BigInt`), then this operation corresponds to\na conversion to `T`.\n\n# Examples\n```jldoctest\njulia> 129 % Int8\n-127\n```\n"},{"Union{Tuple{T}, Tuple{T,T}} where T<:Integer":"    mod(x, y)\n    rem(x, y, RoundDown)\n\nThe reduction of `x` modulo `y`, or equivalently, the remainder of `x` after floored\ndivision by `y`, i.e. `x - y*fld(x,y)` if computed without intermediate rounding.\n\nThe result will have the same sign as `y`, and magnitude less than `abs(y)` (with some\nexceptions, see note below).\n\n!!! note\n\n    When used with floating point values, the exact result may not be representable by the\n    type, and so rounding error may occur. In particular, if the exact result is very\n    close to `y`, then it may be rounded to `y`.\n\n```jldoctest\njulia> mod(8, 3)\n2\n\njulia> mod(9, 3)\n0\n\njulia> mod(8.9, 3)\n2.9000000000000004\n\njulia> mod(eps(), 3)\n2.220446049250313e-16\n\njulia> mod(-eps(), 3)\n3.0\n```\n"}],"Base.Cptrdiff_t":[{"Union{}":"    Cptrdiff_t\n\nEquivalent to the native `ptrdiff_t` c-type (`Int`).\n"}],"Base.resize!":[{"Tuple{Array{T,1} where T,Integer}":"    resize!(a::Vector, n::Integer) -> Vector\n\nResize `a` to contain `n` elements. If `n` is smaller than the current collection\nlength, the first `n` elements will be retained. If `n` is larger, the new elements are not\nguaranteed to be initialized.\n\n# Examples\n```jldoctest\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Array{Int64,1}:\n 6\n 5\n 4\n\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\n\njulia> length(a)\n8\n\njulia> a[1:6]\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n```\n"}],"Base.fieldoffset":[{"Tuple{DataType,Integer}":"    fieldoffset(type, i)\n\nThe byte offset of field `i` of a type relative to the data start. For example, we could\nuse it in the following manner to summarize information about a struct:\n\n```jldoctest\njulia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];\n\njulia> structinfo(Base.Filesystem.StatStruct)\n12-element Array{Tuple{UInt64,Symbol,DataType},1}:\n (0x0000000000000000, :device, UInt64)\n (0x0000000000000008, :inode, UInt64)\n (0x0000000000000010, :mode, UInt64)\n (0x0000000000000018, :nlink, Int64)\n (0x0000000000000020, :uid, UInt64)\n (0x0000000000000028, :gid, UInt64)\n (0x0000000000000030, :rdev, UInt64)\n (0x0000000000000038, :size, Int64)\n (0x0000000000000040, :blksize, Int64)\n (0x0000000000000048, :blocks, Int64)\n (0x0000000000000050, :mtime, Float64)\n (0x0000000000000058, :ctime, Float64)\n```\n"}],"Base.isreadonly":[{"Tuple{Any}":"    isreadonly(io) -> Bool\n\nDetermine whether a stream is read-only.\n\n# Examples\n```jldoctest\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> isreadonly(io)\ntrue\n\njulia> io = IOBuffer();\n\njulia> isreadonly(io)\nfalse\n```\n"}],"Base.@isdefined":[{"Tuple{Symbol}":"    @isdefined s -> Bool\n\nTests whether variable `s` is defined in the current scope.\n\nSee also [`isdefined`](@ref).\n\n# Examples\n```jldoctest\njulia> function f()\n           println(@isdefined x)\n           x = 3\n           println(@isdefined x)\n       end\nf (generic function with 1 method)\n\njulia> f()\nfalse\ntrue\n```\n"}],"Base.minimum!":[{"Tuple{Any,Any}":"    minimum!(r, A)\n\nCompute the minimum value of `A` over the singleton dimensions of `r`, and write results to `r`.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> minimum!([1; 1], A)\n2-element Array{Int64,1}:\n 1\n 3\n\njulia> minimum!([1 1], A)\n1×2 Array{Int64,2}:\n 1  2\n```\n"}],"Base.Clong":[{"Union{}":"    Clong\n\nEquivalent to the native `signed long` c-type.\n"}],"Base.replace!":[{"Tuple{Union{Function, Type},Any}":"    replace!(new::Function, A; [count::Integer])\n\nReplace each element `x` in collection `A` by `new(x)`.\nIf `count` is specified, then replace at most `count` values in total\n(replacements being defined as `new(x) !== x`).\n\n# Examples\n```jldoctest\njulia> replace!(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\n4-element Array{Int64,1}:\n 2\n 2\n 6\n 4\n\njulia> replace!(Dict(1=>2, 3=>4)) do kv\n           first(kv) < 3 ? first(kv)=>3 : kv\n       end\nDict{Int64,Int64} with 2 entries:\n  3 => 4\n  1 => 3\n\njulia> replace!(x->2x, Set([3, 6]))\nSet{Int64} with 2 elements:\n  6\n  12\n```\n"},{"Tuple{Any,Vararg{Pair,N} where N}":"    replace!(A, old_new::Pair...; [count::Integer])\n\nFor each pair `old=>new` in `old_new`, replace all occurrences\nof `old` in collection `A` by `new`.\nEquality is determined using [`isequal`](@ref).\nIf `count` is specified, then replace at most `count` occurrences in total.\nSee also [`replace`](@ref replace(A, old_new::Pair...)).\n\n# Examples\n```jldoctest\njulia> replace!([1, 2, 1, 3], 1=>0, 2=>4, count=2)\n4-element Array{Int64,1}:\n 0\n 4\n 1\n 3\n\njulia> replace!(Set([1, 2, 3]), 1=>0)\nSet{Int64} with 3 elements:\n  0\n  2\n  3\n```\n"}],"Base.=>":[{"Union{}":"    Pair(x, y)\n    x => y\n\nConstruct a `Pair` object with type `Pair{typeof(x), typeof(y)}`. The elements\nare stored in the fields `first` and `second`. They can also be accessed via\niteration (but a `Pair` is treated as a single \"scalar\" for broadcasting operations).\n\nSee also: [`Dict`](@ref)\n\n# Examples\n```jldoctest\njulia> p = \"foo\" => 7\n\"foo\" => 7\n\njulia> typeof(p)\nPair{String,Int64}\n\njulia> p.first\n\"foo\"\n\njulia> for x in p\n           println(x)\n       end\nfoo\n7\n```\n"}],"Base.in":[{"Union{}":"    in(item, collection) -> Bool\n    ∈(item, collection) -> Bool\n    ∋(collection, item) -> Bool\n\nDetermine whether an item is in the given collection, in the sense that it is\n[`==`](@ref) to one of the values generated by iterating over the collection.\nReturns a `Bool` value, except if `item` is [`missing`](@ref) or `collection`\ncontains `missing` but not `item`, in which case `missing` is returned\n([three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic),\nmatching the behavior of [`any`](@ref) and [`==`](@ref)).\n\nSome collections follow a slightly different definition. For example,\n[`Set`](@ref)s check whether the item [`isequal`](@ref) to one of the elements.\n[`Dict`](@ref)s look for `key=>value` pairs, and the key is compared using\n[`isequal`](@ref). To test for the presence of a key in a dictionary,\nuse [`haskey`](@ref) or `k in keys(dict)`. For these collections, the result\nis always a `Bool` and never `missing`.\n\n# Examples\n```jldoctest\njulia> a = 1:3:20\n1:3:19\n\njulia> 4 in a\ntrue\n\njulia> 5 in a\nfalse\n\njulia> missing in [1, 2]\nmissing\n\njulia> 1 in [2, missing]\nmissing\n\njulia> 1 in [1, missing]\ntrue\n\njulia> missing in Set([1, 2])\nfalse\n```\n"},{"Tuple{Any}":"    in(x)\n\nCreate a function that checks whether its argument is [`in`](@ref) `x`, i.e.\na function equivalent to `y -> y in x`.\n\nThe returned function is of type `Base.Fix2{typeof(in)}`, which can be\nused to implement specialized methods.\n"}],"Base.@timed":[{"Tuple{Any}":"    @timed\n\nA macro to execute an expression, and return the value of the expression, elapsed time,\ntotal bytes allocated, garbage collection time, and an object with various memory allocation\ncounters.\n\nSee also [`@time`](@ref), [`@timev`](@ref), [`@elapsed`](@ref), and\n[`@allocated`](@ref).\n\n```julia-repl\njulia> val, t, bytes, gctime, memallocs = @timed rand(10^6);\n\njulia> t\n0.006634834\n\njulia> bytes\n8000256\n\njulia> gctime\n0.0055765\n\njulia> fieldnames(typeof(memallocs))\n(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)\n\njulia> memallocs.total_time\n5576500\n```\n"}],"Base.reduce":[{"Tuple{Any,AbstractArray}":"    reduce(f, A; dims=:, [init])\n\nReduce 2-argument function `f` along dimensions of `A`. `dims` is a vector specifying the\ndimensions to reduce, and the keyword argument `init` is the initial value to use in the\nreductions. For `+`, `*`, `max` and `min` the `init` argument is optional.\n\nThe associativity of the reduction is implementation-dependent; if you need a particular\nassociativity, e.g. left-to-right, you should write your own loop or consider using\n[`foldl`](@ref) or [`foldr`](@ref). See documentation for [`reduce`](@ref).\n\n# Examples\n```jldoctest\njulia> a = reshape(Vector(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reduce(max, a, dims=2)\n4×1 Array{Int64,2}:\n 13\n 14\n 15\n 16\n\njulia> reduce(max, a, dims=1)\n1×4 Array{Int64,2}:\n 4  8  12  16\n```\n"},{"Tuple{Any,Any}":"    reduce(op, itr; [init])\n\nReduce the given collection `itr` with the given binary operator `op`. If provided, the\ninitial value `init` must be a neutral element for `op` that will be returned for empty\ncollections. It is unspecified whether `init` is used for non-empty collections.\n\nFor empty collections, providing `init` will be necessary, except for some special cases\n(e.g. when `op` is one of `+`, `*`, `max`, `min`, `&`, `|`) when Julia can determine the\nneutral element of `op`.\n\nReductions for certain commonly-used operators may have special implementations, and\nshould be used instead: `maximum(itr)`, `minimum(itr)`, `sum(itr)`, `prod(itr)`,\n `any(itr)`, `all(itr)`.\n\nThe associativity of the reduction is implementation dependent. This means that you can't\nuse non-associative operations like `-` because it is undefined whether `reduce(-,[1,2,3])`\nshould be evaluated as `(1-2)-3` or `1-(2-3)`. Use [`foldl`](@ref) or\n[`foldr`](@ref) instead for guaranteed left or right associativity.\n\nSome operations accumulate error. Parallelism will be easier if the reduction can be\nexecuted in groups. Future versions of Julia might change the algorithm. Note that the\nelements are not reordered if you use an ordered collection.\n\n# Examples\n```jldoctest\njulia> reduce(*, [2; 3; 4])\n24\n\njulia> reduce(*, [2; 3; 4]; init=-1)\n-24\n```\n"}],"Base.sign":[{"Tuple{Number}":"    sign(x)\n\nReturn zero if `x==0` and ``x/|x|`` otherwise (i.e., ±1 for real `x`).\n"}],"Base.CFunction":[{"Union{}":"    CFunction struct\n\nGarbage-collection handle for the return value from `@cfunction`\nwhen the first argument is annotated with '\\$'.\nLike all `cfunction` handles, it should be passed to `ccall` as a `Ptr{Cvoid}`,\nand will be converted automatically at the call site to the appropriate type.\n\nSee [`@cfunction`](@ref).\n"}],"Base.reverse!":[{"Union{Tuple{AbstractArray{T,1} where T}, Tuple{AbstractArray{T,1} where T,Any}, Tuple{AbstractArray{T,1} where T,Any,Any}}":"    reverse!(v [, start=1 [, stop=length(v) ]]) -> v\n\nIn-place version of [`reverse`](@ref).\n\n# Examples\n```jldoctest\njulia> A = Vector(1:5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> reverse!(A);\n\njulia> A\n5-element Array{Int64,1}:\n 5\n 4\n 3\n 2\n 1\n```\n"}],"Base.pointer":[{"Union{}":"    pointer(array [, index])\n\nGet the native address of an array or string, optionally at a given location `index`.\n\nThis function is \"unsafe\". Be careful to ensure that a Julia reference to\n`array` exists as long as this pointer will be used. The [`GC.@preserve`](@ref)\nmacro should be used to protect the `array` argument from garbage collection\nwithin a given block of code.\n\nCalling [`Ref(array[, index])`](@ref Ref) is generally preferable to this function as it guarantees validity.\n"}],"Base.cumsum":[{"Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T":"    cumsum(A; dims::Integer)\n\nCumulative sum along the dimension `dims`. See also [`cumsum!`](@ref)\nto use a preallocated output array, both for performance and to control the precision of the\noutput (e.g. to avoid overflow).\n\n# Examples\n```jldoctest\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> cumsum(a, dims=1)\n2×3 Array{Int64,2}:\n 1  2  3\n 5  7  9\n\njulia> cumsum(a, dims=2)\n2×3 Array{Int64,2}:\n 1  3   6\n 4  9  15\n```\n"},{"Tuple{AbstractArray{T,1} where T}":"    cumsum(x::AbstractVector)\n\nCumulative sum a vector. See also [`cumsum!`](@ref)\nto use a preallocated output array, both for performance and to control the precision of the\noutput (e.g. to avoid overflow).\n\n# Examples\n```jldoctest\njulia> cumsum([1, 1, 1])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> cumsum([fill(1, 2) for i in 1:3])\n3-element Array{Array{Int64,1},1}:\n [1, 1]\n [2, 2]\n [3, 3]\n```\n"}],"Base.ReentrantLock":[{"Union{}":"    ReentrantLock()\n\nCreates a re-entrant lock for synchronizing [`Task`](@ref)s.\nThe same task can acquire the lock as many times as required.\nEach [`lock`](@ref) must be matched with an [`unlock`](@ref).\n"}],"Base.Pair":[{"Union{}":"    Pair(x, y)\n    x => y\n\nConstruct a `Pair` object with type `Pair{typeof(x), typeof(y)}`. The elements\nare stored in the fields `first` and `second`. They can also be accessed via\niteration (but a `Pair` is treated as a single \"scalar\" for broadcasting operations).\n\nSee also: [`Dict`](@ref)\n\n# Examples\n```jldoctest\njulia> p = \"foo\" => 7\n\"foo\" => 7\n\njulia> typeof(p)\nPair{String,Int64}\n\njulia> p.first\n\"foo\"\n\njulia> for x in p\n           println(x)\n       end\nfoo\n7\n```\n"}],"Base.identity":[{"Tuple{Any}":"    identity(x)\n\nThe identity function. Returns its argument.\n\n# Examples\n```jldoctest\njulia> identity(\"Well, what did you expect?\")\n\"Well, what did you expect?\"\n```\n"}],"Base.mapfoldr":[{"Tuple{Any,Any,Any}":"    mapfoldr(f, op, itr; [init])\n\nLike [`mapreduce`](@ref), but with guaranteed right associativity, as in [`foldr`](@ref). If\nprovided, the keyword argument `init` will be used exactly once. In general, it will be\nnecessary to provide `init` to work with empty collections.\n"}],"Base.reduce_empty":[{"Tuple{Any,Any}":"    Base.reduce_empty(op, T)\n\nThe value to be returned when calling [`reduce`](@ref), [`foldl`](@ref) or [`foldr`](@ref)\nwith reduction `op` over an empty array with element type of `T`.\n\nIf not defined, this will throw an `ArgumentError`.\n"}],"Base.floatmax":[{"Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat":"    floatmax(T)\n\nThe highest finite value representable by the given floating-point DataType `T`.\n\n# Examples\n```jldoctest\njulia> floatmax(Float16)\nFloat16(6.55e4)\n\njulia> floatmax(Float32)\n3.4028235f38\n```\n"}],"Base.FlatteningRF":[{"Union{}":"    FlatteningRF(rf) -> rf′\n\nCreate a flattening reducing function that is roughly equivalent to\n`rf′(acc, x) = foldl(rf, x; init=acc)`.\n"}],"Base.ones":[{"Union{}":"    ones([T=Float64,] dims::Tuple)\n    ones([T=Float64,] dims...)\n\nCreate an `Array`, with element type `T`, of all ones with size specified by `dims`.\nSee also: [`fill`](@ref), [`zeros`](@ref).\n\n# Examples\n```jldoctest\njulia> ones(1,2)\n1×2 Array{Float64,2}:\n 1.0  1.0\n\njulia> ones(ComplexF64, 2, 3)\n2×3 Array{Complex{Float64},2}:\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n```\n"}],"Base.delete!":[{"Tuple{Any,Any}":"    delete!(collection, key)\n\nDelete the mapping for the given key in a collection, if any, and return the collection.\n\n# Examples\n```jldoctest\njulia> d = Dict(\"a\"=>1, \"b\"=>2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> delete!(d, \"b\")\nDict{String,Int64} with 1 entry:\n  \"a\" => 1\n\njulia> delete!(d, \"b\") # d is left unchanged\nDict{String,Int64} with 1 entry:\n  \"a\" => 1\n```\n"}],"Base.symdiff":[{"Tuple{Any,Vararg{Any,N} where N}":"    symdiff(s, itrs...)\n\nConstruct the symmetric difference of elements in the passed in sets.\nWhen `s` is not an `AbstractSet`, the order is maintained.\nNote that in this case the multiplicity of elements matters.\n\n# Examples\n```jldoctest\njulia> symdiff([1,2,3], [3,4,5], [4,5,6])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\njulia> symdiff([1,2,1], [2, 1, 2])\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> symdiff(unique([1,2,1]), unique([2, 1, 2]))\n0-element Array{Int64,1}\n```\n"}],"Base.hasproperty":[{"Tuple{Any,Symbol}":"    hasproperty(x, s::Symbol)\n\nReturn a boolean indicating whether the object `x` has `s` as one of its own properties.\n\n!!! compat \"Julia 1.2\"\n     This function requires at least Julia 1.2.\n"}],"Base.supertype":[{"Tuple{DataType}":"    supertype(T::DataType)\n\nReturn the supertype of DataType `T`.\n\n# Examples\n```jldoctest\njulia> supertype(Int32)\nSigned\n```\n"}],"Base.<<":[{"Tuple{BitArray{1},Int64}":"    <<(B::BitVector, n) -> BitVector\n\nLeft bit shift operator, `B << n`. For `n >= 0`, the result is `B`\nwith elements shifted `n` positions backwards, filling with `false`\nvalues. If `n < 0`, elements are shifted forwards. Equivalent to\n`B >> -n`.\n\n# Examples\n```jldoctest\njulia> B = BitVector([true, false, true, false, false])\n5-element BitArray{1}:\n 1\n 0\n 1\n 0\n 0\n\njulia> B << 1\n5-element BitArray{1}:\n 0\n 1\n 0\n 0\n 0\n\njulia> B << -1\n5-element BitArray{1}:\n 0\n 1\n 0\n 1\n 0\n```\n"},{"Tuple{Integer,Integer}":"    <<(x, n)\n\nLeft bit shift operator, `x << n`. For `n >= 0`, the result is `x` shifted left\nby `n` bits, filling with `0`s. This is equivalent to `x * 2^n`. For `n < 0`,\nthis is equivalent to `x >> -n`.\n\n# Examples\n```jldoctest\njulia> Int8(3) << 2\n12\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> bitstring(Int8(12))\n\"00001100\"\n```\nSee also [`>>`](@ref), [`>>>`](@ref).\n"}],"Base.length":[{"Union{}":"    length(collection) -> Integer\n\nReturn the number of elements in the collection.\n\nUse [`lastindex`](@ref) to get the last valid index of an indexable collection.\n\n# Examples\n```jldoctest\njulia> length(1:5)\n5\n\njulia> length([1, 2, 3, 4])\n4\n\njulia> length([1 2; 3 4])\n4\n```\n"},{"Tuple{AbstractArray}":"    length(A::AbstractArray)\n\nReturn the number of elements in the array, defaults to `prod(size(A))`.\n\n# Examples\n```jldoctest\njulia> length([1, 2, 3, 4])\n4\n\njulia> length([1 2; 3 4])\n4\n```\n"},{"Tuple{AbstractString}":"    length(s::AbstractString) -> Int\n    length(s::AbstractString, i::Integer, j::Integer) -> Int\n\nThe number of characters in string `s` from indices `i` through `j`. This is\ncomputed as the number of code unit indices from `i` to `j` which are valid\ncharacter indices. With only a single string argument, this computes the\nnumber of characters in the entire string. With `i` and `j` arguments it\ncomputes the number of indices between `i` and `j` inclusive that are valid\nindices in the string `s`. In addition to in-bounds values, `i` may take the\nout-of-bounds value `ncodeunits(s) + 1` and `j` may take the out-of-bounds\nvalue `0`.\n\nSee also: [`isvalid`](@ref), [`ncodeunits`](@ref), [`lastindex`](@ref),\n[`thisind`](@ref), [`nextind`](@ref), [`prevind`](@ref)\n\n# Examples\n```jldoctest\njulia> length(\"jμΛIα\")\n5\n```\n"}],"Base.prevfloat":[{"Tuple{AbstractFloat}":"    prevfloat(x::AbstractFloat)\n\nReturn the largest floating point number `y` of the same type as `x` such `y < x`. If no\nsuch `y` exists (e.g. if `x` is `-Inf` or `NaN`), then return `x`.\n"},{"Tuple{AbstractFloat,Integer}":"    prevfloat(x::AbstractFloat, n::Integer)\n\nThe result of `n` iterative applications of `prevfloat` to `x` if `n >= 0`, or `-n`\napplications of `nextfloat` if `n < 0`.\n"}],"Base.eachcol":[{"Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}":"    eachcol(A::AbstractVecOrMat)\n\nCreate a generator that iterates over the second dimension of matrix `A`, returning the\ncolumns as views.\n\nSee also [`eachrow`](@ref) and [`eachslice`](@ref).\n\n!!! compat \"Julia 1.1\"\n     This function requires at least Julia 1.1.\n"}],"Base.pkgdir":[{"Tuple{Module}":"   pkgdir(m::Module)\n\nReturn the root directory of the package that imported module `m`,\nor `nothing` if `m` was not imported from a package.\n"}],"Base.IOStream":[{"Union{}":"    IOStream\n\nA buffered IO stream wrapping an OS file descriptor.\nMostly used to represent files returned by [`open`](@ref).\n"}],"Base.stride":[{"Tuple{AbstractArray,Integer}":"    stride(A, k::Integer)\n\nReturn the distance in memory (in number of elements) between adjacent elements in dimension `k`.\n\n# Examples\n```jldoctest\njulia> A = fill(1, (3,4,5));\n\njulia> stride(A,2)\n3\n\njulia> stride(A,3)\n12\n```\n"}],"Base.real":[{"Tuple{Complex}":"    real(z)\n\nReturn the real part of the complex number `z`.\n\n# Examples\n```jldoctest\njulia> real(1 + 3im)\n1\n```\n"},{"Tuple{Type}":"    real(T::Type)\n\nReturn the type that represents the real part of a value of type `T`.\ne.g: for `T == Complex{R}`, returns `R`.\nEquivalent to `typeof(real(zero(T)))`.\n\n# Examples\n```jldoctest\njulia> real(Complex{Int})\nInt64\n\njulia> real(Float64)\nFloat64\n```\n"}],"Base.IteratorSize":[{"Tuple{Any}":"    IteratorSize(itertype::Type) -> IteratorSize\n\nGiven the type of an iterator, return one of the following values:\n\n* `SizeUnknown()` if the length (number of elements) cannot be determined in advance.\n* `HasLength()` if there is a fixed, finite length.\n* `HasShape{N}()` if there is a known length plus a notion of multidimensional shape (as for an array).\n   In this case `N` should give the number of dimensions, and the [`axes`](@ref) function is valid\n   for the iterator.\n* `IsInfinite()` if the iterator yields values forever.\n\nThe default value (for iterators that do not define this function) is `HasLength()`.\nThis means that most iterators are assumed to implement [`length`](@ref).\n\nThis trait is generally used to select between algorithms that pre-allocate space for their\nresult, and algorithms that resize their result incrementally.\n\n```jldoctest\njulia> Base.IteratorSize(1:5)\nBase.HasShape{1}()\n\njulia> Base.IteratorSize((2,3))\nBase.HasLength()\n```\n"}],"Base.TwicePrecision":[{"Union{}":"    TwicePrecision{T}(hi::T, lo::T)\n    TwicePrecision{T}((num, denom))\n\nA number with twice the precision of `T`, e.g., quad-precision if `T =\nFloat64`. `hi` represents the high bits (most significant bits) and\n`lo` the low bits (least significant bits). Rational values\n`num//denom` can be approximated conveniently using the syntax\n`TwicePrecision{T}((num, denom))`.\n\nWhen used with `T<:Union{Float16,Float32,Float64}` to construct an \"exact\"\n`StepRangeLen`, `ref` should be the range element with smallest\nmagnitude and `offset` set to the corresponding index.  For\nefficiency, multiplication of `step` by the index is not performed at\ntwice precision: `step.hi` should have enough trailing zeros in its\n`bits` representation that `(0:len-1)*step.hi` is exact (has no\nroundoff error).  If `step` has an exact rational representation\n`num//denom`, then you can construct `step` using\n\n    step = TwicePrecision{T}((num, denom), nb)\n\nwhere `nb` is the number of trailing zero bits of `step.hi`.  For\nranges, you can set `nb = ceil(Int, log2(len-1))`.\n"}],"Base.setindex":[{"Tuple{NamedTuple,Any,Symbol}":"    setindex(nt::NamedTuple, val, key::Symbol)\n\nConstructs a new `NamedTuple` with the key `key` set to `val`.\nIf `key` is already in the keys of `nt`, `val` replaces the old value.\n\n```jldoctest\njulia> nt = (a = 3,)\n(a = 3,)\n\njulia> Base.setindex(nt, 33, :b)\n(a = 3, b = 33)\n\njulia> Base.setindex(nt, 4, :a)\n(a = 4,)\n\njulia> Base.setindex(nt, \"a\", :a)\n(a = \"a\",)\n```\n"},{"Tuple{Tuple,Any,Integer}":"    setindex(c::Tuple, v, i::Integer)\n\nCreates a new tuple similar to `x` with the value at index `i` set to `v`.\nThrows a `BoundsError` when out of bounds.\n\n# Examples\n```jldoctest\njulia> Base.setindex((1, 2, 6), 2, 3) == (1, 2, 2)\ntrue\n```\n"}],"Base.readlines":[{"Tuple{AbstractString}":"    readlines(io::IO=stdin; keep::Bool=false)\n    readlines(filename::AbstractString; keep::Bool=false)\n\nRead all lines of an I/O stream or a file as a vector of strings. Behavior is\nequivalent to saving the result of reading [`readline`](@ref) repeatedly with the same\narguments and saving the resulting lines as a vector of strings.\n\n# Examples\n```jldoctest\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readlines(\"my_file.txt\")\n2-element Array{String,1}:\n \"JuliaLang is a GitHub organization.\"\n \"It has many members.\"\n\njulia> readlines(\"my_file.txt\", keep=true)\n2-element Array{String,1}:\n \"JuliaLang is a GitHub organization.\\n\"\n \"It has many members.\\n\"\n\njulia> rm(\"my_file.txt\")\n```\n"}],"Base.GenericCondition":[{"Union{}":"    GenericCondition\n\nAbstract implementation of a condition object\nfor synchonizing tasks objects with a given lock.\n"}],"Base.UUID":[{"Union{}":"    Represents a Universally Unique Identifier (UUID).\n    Can be built from one `UInt128` (all byte values), two `UInt64`, or four `UInt32`.\n    Conversion from a string will check the UUID validity.\n"}],"Base.@views":[{"Tuple{Any}":"    @views expression\n\nConvert every array-slicing operation in the given expression\n(which may be a `begin`/`end` block, loop, function, etc.)\nto return a view. Scalar indices, non-array types, and\nexplicit [`getindex`](@ref) calls (as opposed to `array[...]`) are\nunaffected.\n\n!!! note\n    The `@views` macro only affects `array[...]` expressions\n    that appear explicitly in the given `expression`, not array slicing that\n    occurs in functions called by that code.\n\n# Examples\n```jldoctest\njulia> A = zeros(3, 3);\n\njulia> @views for row in 1:3\n           b = A[row, :]\n           b[:] .= row\n       end\n\njulia> A\n3×3 Array{Float64,2}:\n 1.0  1.0  1.0\n 2.0  2.0  2.0\n 3.0  3.0  3.0\n```\n"}],"Base.merge":[{"Tuple{AbstractDict,Vararg{AbstractDict,N} where N}":"    merge(d::AbstractDict, others::AbstractDict...)\n\nConstruct a merged collection from the given collections. If necessary, the\ntypes of the resulting collection will be promoted to accommodate the types of\nthe merged collections. If the same key is present in another collection, the\nvalue for that key will be the value it has in the last collection listed.\n\n# Examples\n```jldoctest\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String,Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String,Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(a, b)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 4711.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> merge(b, a)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 42.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n```\n"},{"Tuple{NamedTuple,Any}":"    merge(a::NamedTuple, iterable)\n\nInterpret an iterable of key-value pairs as a named tuple, and perform a merge.\n\n```jldoctest\njulia> merge((a=1, b=2, c=3), [:b=>4, :d=>5])\n(a = 1, b = 4, c = 3, d = 5)\n```\n"},{"Tuple{Function,AbstractDict,Vararg{AbstractDict,N} where N}":"    merge(combine, d::AbstractDict, others::AbstractDict...)\n\nConstruct a merged collection from the given collections. If necessary, the\ntypes of the resulting collection will be promoted to accommodate the types of\nthe merged collections. Values with the same key will be combined using the\ncombiner function.\n\n# Examples\n```jldoctest\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String,Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String,Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(+, a, b)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 4753.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n```\n"},{"Union{Tuple{bn}, Tuple{an}, Tuple{NamedTuple{an,T} where T<:Tuple,NamedTuple{bn,T} where T<:Tuple}} where bn where an":"    merge(a::NamedTuple, bs::NamedTuple...)\n\nConstruct a new named tuple by merging two or more existing ones, in a left-associative\nmanner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields\npresent in both the leftmost and rightmost named tuples take the same position as they are found in the\nleftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that\ncontains that field. Fields present in only the rightmost named tuple of a pair are appended at the end.\nA fallback is implemented for when only a single named tuple is supplied,\nwith signature `merge(a::NamedTuple)`.\n\n!!! compat \"Julia 1.1\"\n    Merging 3 or more `NamedTuple` requires at least Julia 1.1.\n\n# Examples\n```jldoctest\njulia> merge((a=1, b=2, c=3), (b=4, d=5))\n(a = 1, b = 4, c = 3, d = 5)\n```\n\n```jldoctest\njulia> merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))\n(a = 1, b = 3, c = (d = 2,))\n```\n"}],"Base.readchomp":[{"Tuple{Any}":"    readchomp(x)\n\nRead the entirety of `x` as a string and remove a single trailing newline\nif there is one. Equivalent to `chomp(read(x, String))`.\n\n# Examples\n```jldoctest\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end;\n\njulia> readchomp(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\\nIt has many members.\"\n\njulia> rm(\"my_file.txt\");\n```\n"}],"Base.Missing":[{"Union{}":"    Missing\n\nA type with no fields whose singleton instance [`missing`](@ref) is used\nto represent missing values.\n"}],"Base.//":[{"Tuple{Integer,Integer}":"    //(num, den)\n\nDivide two integers or rational numbers, giving a [`Rational`](@ref) result.\n\n# Examples\n```jldoctest\njulia> 3 // 5\n3//5\n\njulia> (3 // 5) // (2 // 1)\n3//10\n```\n"}],"Base.bitsunionsize":[{"Tuple{Union}":"    Base.bitsunionsize(U::Union)\n\nFor a `Union` of [`isbitstype`](@ref) types, return the size of the largest type; assumes `Base.isbitsunion(U) == true`.\n\n# Examples\n```jldoctest\njulia> Base.bitsunionsize(Union{Float64, UInt8})\n0x0000000000000008\n\njulia> Base.bitsunionsize(Union{Float64, UInt8, Int128})\n0x0000000000000010\n```\n"}],"Base.invperm":[{"Tuple{AbstractArray{T,1} where T}":"    invperm(v)\n\nReturn the inverse permutation of `v`.\nIf `B = A[v]`, then `A == B[invperm(v)]`.\n\n# Examples\n```jldoctest\njulia> v = [2; 4; 3; 1];\n\njulia> invperm(v)\n4-element Array{Int64,1}:\n 4\n 1\n 3\n 2\n\njulia> A = ['a','b','c','d'];\n\njulia> B = A[v]\n4-element Array{Char,1}:\n 'b'\n 'd'\n 'c'\n 'a'\n\njulia> B[invperm(v)]\n4-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n 'd'\n```\n"}],"Base.lstrip":[{"Tuple{Any,AbstractString}":"    lstrip([pred=isspace,] str::AbstractString) -> SubString\n    lstrip(str::AbstractString, chars) -> SubString\n\nRemove leading characters from `str`, either those specified by `chars` or those for\nwhich the function `pred` returns `true`.\n\nThe default behaviour is to remove leading whitespace and delimiters: see\n[`isspace`](@ref) for precise details.\n\nThe optional `chars` argument specifies which characters to remove: it can be a single\ncharacter, or a vector or set of characters.\n\n# Examples\n```jldoctest\njulia> a = lpad(\"March\", 20)\n\"               March\"\n\njulia> lstrip(a)\n\"March\"\n```\n"}],"Base.nextfloat":[{"Tuple{Union{Float16, Float32, Float64},Integer}":"    nextfloat(x::AbstractFloat, n::Integer)\n\nThe result of `n` iterative applications of `nextfloat` to `x` if `n >= 0`, or `-n`\napplications of `prevfloat` if `n < 0`.\n"},{"Tuple{AbstractFloat}":"    nextfloat(x::AbstractFloat)\n\nReturn the smallest floating point number `y` of the same type as `x` such `x < y`. If no\nsuch `y` exists (e.g. if `x` is `Inf` or `NaN`), then return `x`.\n"}],"Base.Cuintmax_t":[{"Union{}":"    Cuintmax_t\n\nEquivalent to the native `uintmax_t` c-type ([`UInt64`](@ref)).\n"}],"Base.unsafe_copyto!":[{"Union{Tuple{T}, Tuple{Ptr{T},Ptr{T},Any}} where T":"    unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)\n\nCopy `N` elements from a source pointer to a destination, with no checking. The size of an\nelement is determined by the type of the pointers.\n\nThe `unsafe` prefix on this function indicates that no validation is performed on the\npointers `dest` and `src` to ensure that they are valid. Incorrect usage may corrupt or\nsegfault your program, in the same manner as C.\n"},{"Union{Tuple{T}, Tuple{Array{T,N} where N,Any,Array{T,N} where N,Any,Any}} where T":"    unsafe_copyto!(dest::Array, do, src::Array, so, N)\n\nCopy `N` elements from a source array to a destination, starting at offset `so` in the\nsource and `do` in the destination (1-indexed).\n\nThe `unsafe` prefix on this function indicates that no validation is performed to ensure\nthat N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in\nthe same manner as C.\n"}],"Base.eachline":[{"Union{Tuple{}, Tuple{IO}}":"    eachline(io::IO=stdin; keep::Bool=false)\n    eachline(filename::AbstractString; keep::Bool=false)\n\nCreate an iterable `EachLine` object that will yield each line from an I/O stream\nor a file. Iteration calls [`readline`](@ref) on the stream argument repeatedly with\n`keep` passed through, determining whether trailing end-of-line characters are\nretained. When called with a file name, the file is opened once at the beginning of\niteration and closed at the end. If iteration is interrupted, the file will be\nclosed when the `EachLine` object is garbage collected.\n\n# Examples\n```jldoctest\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\n It has many members.\\n\");\n       end;\n\njulia> for line in eachline(\"my_file.txt\")\n           print(line)\n       end\nJuliaLang is a GitHub organization. It has many members.\n\njulia> rm(\"my_file.txt\");\n```\n"}],"Base.isreal":[{"Tuple{Real}":"    isreal(x) -> Bool\n\nTest whether `x` or all its elements are numerically equal to some real number\nincluding infinities and NaNs. `isreal(x)` is true if `isequal(x, real(x))`\nis true.\n\n# Examples\n```jldoctest\njulia> isreal(5.)\ntrue\n\njulia> isreal(Inf + 0im)\ntrue\n\njulia> isreal([4.; complex(0,1)])\nfalse\n```\n"}],"Base.StepRangeLen":[{"Union{}":"    StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}\n    StepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}\n\nA range `r` where `r[i]` produces values of type `T` (in the second\nform, `T` is deduced automatically), parameterized by a `ref`erence\nvalue, a `step`, and the `len`gth. By default `ref` is the starting\nvalue `r[1]`, but alternatively you can supply it as the value of\n`r[offset]` for some other index `1 <= offset <= len`. In conjunction\nwith `TwicePrecision` this can be used to implement ranges that are\nfree of roundoff error.\n"}],"Base.last":[{"Tuple{Any}":"    last(coll)\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is\naccomplished by calling [`lastindex`](@ref) to get the last index. Return the end\npoint of an [`AbstractRange`](@ref) even if it is empty.\n\n# Examples\n```jldoctest\njulia> last(1:2:10)\n9\n\njulia> last([1; 2; 3; 4])\n4\n```\n"},{"Tuple{AbstractString,Integer}":"    last(s::AbstractString, n::Integer)\n\nGet a string consisting of the last `n` characters of `s`.\n\n```jldoctest\njulia> last(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 1)\n\"0\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 3)\n\"²>0\"\n```\n"}],"Base.ltoh":[{"Tuple{Any}":"    ltoh(x)\n\nConvert the endianness of a value from Little-endian to that used by the Host.\n"}]}