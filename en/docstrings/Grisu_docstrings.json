{"Base.Grisu.print_shortest":[{"Tuple{IO,AbstractFloat,Bool}":"    print_shortest(io::IO, x)\n\nPrint the shortest possible representation, with the minimum number of consecutive non-zero\ndigits, of number `x`, ensuring that it would parse to the exact same number.\n"}],"Base.Grisu.grisu":[{"Union{Tuple{AbstractFloat,Any,Any}, Tuple{AbstractFloat,Any,Any,Any}, Tuple{AbstractFloat,Any,Any,Any,Any}}":"    (len, point, neg) = Grisu.grisu(v::AbstractFloat, mode, requested_digits, [buffer], [bignums])\n\nConvert the number `v` to decimal using the Grisu algorithm.\n\n`mode` can be one of:\n - `Grisu.SHORTEST`: convert to the shortest decimal representation which can be \"round-tripped\" back to `v`.\n - `Grisu.FIXED`: round to `requested_digits` digits.\n - `Grisu.PRECISION`: round to `requested_digits` significant digits.\n\nThe characters are written as bytes to `buffer`, with a terminating NUL byte, and `bignums` are used internally as part of the correction step. You can call `Grisu.getbuf()` to obtain a suitable task-local buffer.\n\nThe returned tuple contains:\n\n - `len`: the number of digits written to `buffer` (excluding NUL)\n - `point`: the location of the radix point relative to the start of the array (e.g. if\n   `point == 3`, then the radix point should be inserted between the 3rd and 4th\n   digit). Note that this can be negative (for very small values), or greater than `len`\n   (for very large values).\n - `neg`: the signbit of `v` (see [`signbit`](@ref)).\n"}]}