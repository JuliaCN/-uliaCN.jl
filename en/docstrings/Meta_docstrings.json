{"Base.Meta.lower":[{"Tuple{Module,Any}":"    lower(m, x)\n\nTakes the expression `x` and returns an equivalent expression in lowered form\nfor executing in module `m`.\nSee also [`code_lowered`](@ref).\n"}],"Base.Meta.parse":[{"Tuple{AbstractString}":"    parse(str; raise=true, depwarn=true)\n\nParse the expression string greedily, returning a single expression. An error is thrown if\nthere are additional characters after the first expression. If `raise` is `true` (default),\nsyntax errors will raise an error; otherwise, `parse` will return an expression that will\nraise an error upon evaluation.  If `depwarn` is `false`, deprecation warnings will be\nsuppressed.\n\n```jldoctest\njulia> Meta.parse(\"x = 3\")\n:(x = 3)\n\njulia> Meta.parse(\"x = \")\n:($(Expr(:incomplete, \"incomplete: premature end of input\")))\n\njulia> Meta.parse(\"1.0.2\")\nERROR: Base.Meta.ParseError(\"invalid numeric constant \\\"1.0.\\\"\")\nStacktrace:\n[...]\n\njulia> Meta.parse(\"1.0.2\"; raise = false)\n:($(Expr(:error, \"invalid numeric constant \\\"1.0.\\\"\")))\n```\n"},{"Tuple{AbstractString,Integer}":"    parse(str, start; greedy=true, raise=true, depwarn=true)\n\nParse the expression string and return an expression (which could later be passed to eval\nfor execution). `start` is the index of the first character to start parsing. If `greedy` is\n`true` (default), `parse` will try to consume as much input as it can; otherwise, it will\nstop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically\nvalid expressions will return `Expr(:incomplete, \"(error message)\")`. If `raise` is `true`\n(default), syntax errors other than incomplete expressions will raise an error. If `raise`\nis `false`, `parse` will return an expression that will raise an error upon evaluation. If\n`depwarn` is `false`, deprecation warnings will be suppressed.\n\n```jldoctest\njulia> Meta.parse(\"x = 3, y = 5\", 7)\n(:(y = 5), 13)\n\njulia> Meta.parse(\"x = 3, y = 5\", 5)\n(:((3, y) = 5), 13)\n```\n"}],"Base.Meta.show_sexpr":[{"Tuple{Any}":"    Meta.show_sexpr([io::IO,], ex)\n\nShow expression `ex` as a lisp style S-expression.\n\n# Examples\n```jldoctest\njulia> Meta.show_sexpr(:(f(x, g(y,z))))\n(:call, :f, :x, (:call, :g, :y, :z))\n```\n"}],"Base.Meta.quot":[{"Tuple{Any}":"    Meta.quot(ex)::Expr\n\nQuote expression `ex` to produce an expression with head `quote`. This can for instance be used to represent objects of type `Expr` in the AST.\nSee also the manual section about [QuoteNode](@ref man-quote-node).\n\n# Examples\n```jldoctest\njulia> eval(Meta.quot(:x))\n:x\n\njulia> dump(Meta.quot(:x))\nExpr\n  head: Symbol quote\n  args: Array{Any}((1,))\n    1: Symbol x\n\njulia> eval(Meta.quot(:(1+2)))\n:(1 + 2)\n```\n"}],"Base.Meta.@lower":[{"Tuple{Any}":"    @lower [m] x\n\nReturn lowered form of the expression `x` in module `m`.\nBy default `m` is the module in which the macro is called.\nSee also [`lower`](@ref).\n"}],"Base.Meta.ParseError":[{"Union{}":"    ParseError(msg)\n\nThe expression passed to the [`parse`](@ref) function could not be interpreted as a valid Julia\nexpression.\n"}],"Base.Meta.@dump":[{"Tuple{Any}":"    @dump expr\n\nShow every part of the representation of the given expression. Equivalent to\n[`dump(:(expr))`](@ref dump).\n"}],"Base.Meta.isexpr":[{"Tuple{Any,Symbol}":"    Meta.isexpr(ex, head[, n])::Bool\n\nCheck if `ex` is an expression with head `head` and `n` arguments.\n\n# Examples\n```jldoctest\njulia> ex = :(f(x))\n:(f(x))\n\njulia> Meta.isexpr(ex, :block)\nfalse\n\njulia> Meta.isexpr(ex, :call)\ntrue\n\njulia> Meta.isexpr(ex, [:block, :call]) # multiple possible heads\ntrue\n\njulia> Meta.isexpr(ex, :call, 1)\nfalse\n\njulia> Meta.isexpr(ex, :call, 2)\ntrue\n```\n"}],"Base.Meta.partially_inline!":[{"Tuple{Array{Any,1},Array{Any,1},Any,Array{Any,1},Int64,Int64,Symbol}":"    partially_inline!(code::Vector{Any}, slot_replacements::Vector{Any},\n                      type_signature::Type{<:Tuple}, static_param_values::Vector{Any},\n                      slot_offset::Int, statement_offset::Int,\n                      boundscheck::Symbol)\n\nReturn `code` after performing an in-place partial inlining pass on the Julia IR stored\nwithin it.\n\nThe kind of inlining transformations performed by this function are those that are generally\npossible given only a runtime type signature for a method invocation and the corresponding\nmethod's lowered IR. Thus, this function is mainly useful when preparing Julia IR to be\nemitted from a `@generated` function.\n\nThe performed transformations are:\n\n- replace slot numbers in the range `1:length(slot_replacements)` with the corresponding items in `slot_replacements`\n- increment other slot numbers by `slot_offset`\n- substitute static parameter placeholders (e.g. `Expr(:static_parameter, 1)`) with the corresponding\nvalues in `static_param_values`\n- increment any statement indices present in the IR (`GotoNode`s, `SSAValue`s, etc.) by `statement_offset`\n(useful when the caller plans to prepend new statements to the IR)\n- turn off boundschecking (if `boundscheck === :off`) or propagate boundschecking (if `boundscheck === :propagate`)\n\nThis function is similar to `Core.Compiler.ssa_substitute!`, but works on pre-type-inference\nIR instead of the optimizer's IR.\n"}]}