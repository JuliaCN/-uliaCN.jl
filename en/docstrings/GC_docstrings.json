{"Base.GC.gc":[{"Union{Tuple{}, Tuple{Bool}}":"    GC.gc([full=true])\n\nPerform garbage collection. The argument `full` determines the kind of\ncollection: A full collection (default) sweeps all objects, which makes the\nnext GC scan much slower, while an incremental collection may only sweep\nso-called young objects.\n\n!!! warning\n    Excessive use will likely lead to poor performance.\n"}],"Base.GC.enable":[{"Tuple{Bool}":"    GC.enable(on::Bool)\n\nControl whether garbage collection is enabled using a boolean argument (`true` for enabled,\n`false` for disabled). Return previous GC state.\n\n!!! warning\n    Disabling garbage collection should be used only with caution, as it can cause memory\n    use to grow without bound.\n"}],"Base.GC.@preserve":[{"Tuple":"    GC.@preserve x1 x2 ... xn expr\n\nTemporarily protect the given objects from being garbage collected, even if they would\notherwise be unreferenced.\n\nThe last argument is the expression during which the object(s) will be preserved.\nThe previous arguments are the objects to preserve.\n"}],"Base.GC.safepoint":[{"Tuple{}":"    GC.safepoint()\n\nInserts a point in the program where garbage collection may run.\nThis can be useful in rare cases in multi-threaded programs where some threads\nare allocating memory (and hence may need to run GC) but other threads are doing\nonly simple operations (no allocation, task switches, or I/O).\nCalling this function periodically in non-allocating threads allows garbage\ncollection to run.\n\n!!! compat \"Julia 1.4\"\n    This function is available as of Julia 1.4.\n"}]}