{"Base.Threads.atomic_max!":[{"Union{}":"    Threads.atomic_max!(x::Atomic{T}, val::T) where T\n\nAtomically store the maximum of `x` and `val` in `x`\n\nPerforms `x[] = max(x[], val)` atomically. Returns the **old** value.\n\nFor further details, see LLVM's `atomicrmw max` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_max!(x, 7)\n5\n\njulia> x[]\n7\n```\n"}],"Base.Threads.resize_nthreads!":[{"Union{Tuple{AbstractArray{T,1} where T}, Tuple{AbstractArray{T,1} where T,Any}}":"    resize_nthreads!(A, copyvalue=A[1])\n\nResize the array `A` to length [`nthreads()`](@ref).   Any new\nelements that are allocated are initialized to `deepcopy(copyvalue)`,\nwhere `copyvalue` defaults to `A[1]`.\n\nThis is typically used to allocate per-thread variables, and\nshould be called in `__init__` if `A` is a global constant.\n"}],"Base.Threads.atomic_fence":[{"Tuple{}":"    Threads.atomic_fence()\n\nInsert a sequential-consistency memory fence\n\nInserts a memory fence with sequentially-consistent ordering\nsemantics. There are algorithms where this is needed, i.e. where an\nacquire/release ordering is insufficient.\n\nThis is likely a very expensive operation. Given that all other atomic\noperations in Julia already have acquire/release semantics, explicit\nfences should not be necessary in most cases.\n\nFor further details, see LLVM's `fence` instruction.\n"}],"Base.Threads.Atomic":[{"Union{}":"    Threads.Atomic{T}\n\nHolds a reference to an object of type `T`, ensuring that it is only\naccessed atomically, i.e. in a thread-safe manner.\n\nOnly certain \"simple\" types can be used atomically, namely the\nprimitive boolean, integer, and float-point types. These are `Bool`,\n`Int8`...`Int128`, `UInt8`...`UInt128`, and `Float16`...`Float64`.\n\nNew atomic objects can be created from a non-atomic values; if none is\nspecified, the atomic object is initialized with zero.\n\nAtomic objects can be accessed using the `[]` notation:\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> x[] = 1\n1\n\njulia> x[]\n1\n```\n\nAtomic operations use an `atomic_` prefix, such as [`atomic_add!`](@ref),\n[`atomic_xchg!`](@ref), etc.\n"}],"Base.Threads.atomic_nand!":[{"Union{}":"    Threads.atomic_nand!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-nand (not-and) `x` with `val`\n\nPerforms `x[] = ~(x[] & val)` atomically. Returns the **old** value.\n\nFor further details, see LLVM's `atomicrmw nand` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_nand!(x, 2)\n3\n\njulia> x[]\n-3\n```\n"}],"Base.Threads.atomic_min!":[{"Union{}":"    Threads.atomic_min!(x::Atomic{T}, val::T) where T\n\nAtomically store the minimum of `x` and `val` in `x`\n\nPerforms `x[] = min(x[], val)` atomically. Returns the **old** value.\n\nFor further details, see LLVM's `atomicrmw min` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(7)\nBase.Threads.Atomic{Int64}(7)\n\njulia> Threads.atomic_min!(x, 5)\n7\n\njulia> x[]\n5\n```\n"}],"Base.Threads.@spawn":[{"Tuple{Any}":"    Threads.@spawn expr\n\nCreate and run a [`Task`](@ref) on any available thread. To wait for the task to\nfinish, call [`wait`](@ref) on the result of this macro, or call [`fetch`](@ref)\nto wait and then obtain its return value.\n\nValues can be interpolated into `@spawn` via `$`, which copies the value directly into the\nconstructed underlying closure. This allows you to insert the _value_ of a variable,\nisolating the aysnchronous code from changes to the variable's value in the current task.\n\n!!! note\n    This feature is currently considered experimental.\n\n!!! compat \"Julia 1.3\"\n    This macro is available as of Julia 1.3.\n\n!!! compat \"Julia 1.4\"\n    Interpolating values via `$` is available as of Julia 1.4.\n"}],"Base.Threads.Condition":[{"Union{}":"    Threads.Condition([lock])\n\nA thread-safe version of [`Base.Condition`](@ref).\n\n!!! compat \"Julia 1.2\"\n    This functionality requires at least Julia 1.2.\n"}],"Base.Threads.atomic_sub!":[{"Union{}":"    Threads.atomic_sub!(x::Atomic{T}, val::T) where T <: ArithmeticTypes\n\nAtomically subtract `val` from `x`\n\nPerforms `x[] -= val` atomically. Returns the **old** value. Not defined for\n`Atomic{Bool}`.\n\nFor further details, see LLVM's `atomicrmw sub` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_sub!(x, 2)\n3\n\njulia> x[]\n1\n```\n"}],"Base.Threads.threadid":[{"Tuple{}":"    Threads.threadid()\n\nGet the ID number of the current thread of execution. The master thread has ID `1`.\n"}],"Base.Threads.atomic_cas!":[{"Union{}":"    Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T\n\nAtomically compare-and-set `x`\n\nAtomically compares the value in `x` with `cmp`. If equal, write\n`newval` to `x`. Otherwise, leaves `x` unmodified. Returns the old\nvalue in `x`. By comparing the returned value to `cmp` (via `===`) one\nknows whether `x` was modified and now holds the new value `newval`.\n\nFor further details, see LLVM's `cmpxchg` instruction.\n\nThis function can be used to implement transactional semantics. Before\nthe transaction, one records the value in `x`. After the transaction,\nthe new value is stored only if `x` has not been modified in the mean\ntime.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_cas!(x, 4, 2);\n\njulia> x\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_cas!(x, 3, 2);\n\njulia> x\nBase.Threads.Atomic{Int64}(2)\n```\n"}],"Base.Threads.atomic_xor!":[{"Union{}":"    Threads.atomic_xor!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-xor (exclusive-or) `x` with `val`\n\nPerforms `x[] $= val` atomically. Returns the **old** value.\n\nFor further details, see LLVM's `atomicrmw xor` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_xor!(x, 7)\n5\n\njulia> x[]\n2\n```\n"}],"Base.Threads.atomic_and!":[{"Union{}":"    Threads.atomic_and!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-and `x` with `val`\n\nPerforms `x[] &= val` atomically. Returns the **old** value.\n\nFor further details, see LLVM's `atomicrmw and` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_and!(x, 2)\n3\n\njulia> x[]\n2\n```\n"}],"Base.Threads.nthreads":[{"Tuple{}":"    Threads.nthreads()\n\nGet the number of threads available to the Julia process. This is the inclusive upper bound\non `threadid()`.\n"}],"Base.Threads.atomic_add!":[{"Union{}":"    Threads.atomic_add!(x::Atomic{T}, val::T) where T <: ArithmeticTypes\n\nAtomically add `val` to `x`\n\nPerforms `x[] += val` atomically. Returns the **old** value. Not defined for\n`Atomic{Bool}`.\n\nFor further details, see LLVM's `atomicrmw add` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_add!(x, 2)\n3\n\njulia> x[]\n5\n```\n"}],"Base.Threads.@threads":[{"Tuple":"    Threads.@threads\n\nA macro to parallelize a for-loop to run with multiple threads. This spawns `nthreads()`\nnumber of threads, splits the iteration space amongst them, and iterates in parallel.\nA barrier is placed at the end of the loop which waits for all the threads to finish\nexecution, and the loop returns.\n"}],"Base.Threads.atomic_or!":[{"Union{}":"    Threads.atomic_or!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-or `x` with `val`\n\nPerforms `x[] |= val` atomically. Returns the **old** value.\n\nFor further details, see LLVM's `atomicrmw or` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_or!(x, 7)\n5\n\njulia> x[]\n7\n```\n"}],"Base.Threads.SpinLock":[{"Union{}":"    SpinLock()\n\nCreate a non-reentrant, test-and-test-and-set spin lock.\nRecursive use will result in a deadlock.\nThis kind of lock should only be used around code that takes little time\nto execute and does not block (e.g. perform I/O).\nIn general, [`ReentrantLock`](@ref) should be used instead.\n\nEach [`lock`](@ref) must be matched with an [`unlock`](@ref).\n\nTest-and-test-and-set spin locks are quickest up to about 30ish\ncontending threads. If you have more contention than that, different\nsynchronization approaches should be considered.\n"}],"Base.Threads.atomic_xchg!":[{"Union{}":"    Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T\n\nAtomically exchange the value in `x`\n\nAtomically exchanges the value in `x` with `newval`. Returns the **old**\nvalue.\n\nFor further details, see LLVM's `atomicrmw xchg` instruction.\n\n# Examples\n```jldoctest\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_xchg!(x, 2)\n3\n\njulia> x[]\n2\n```\n"}]}