{"Base.Iterators.dropwhile":[{"Tuple{Any,Any}":"    dropwhile(pred, iter)\n\nAn iterator that drops element from `iter` as long as predicate `pred` is true,\nafterwards, returns every element.\n\n!!! compat \"Julia 1.4\"\n    This function requires at least Julia 1.4.\n\n# Examples\n\n```jldoctest\njulia> s = collect(1:5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> collect(Iterators.dropwhile(<(3),s))\n3-element Array{Int64,1}:\n 3\n 4\n 5\n```\n"}],"Base.Iterators.partition":[{"Tuple{Any,Integer}":"    partition(collection, n)\n\nIterate over a collection `n` elements at a time.\n\n# Examples\n```jldoctest\njulia> collect(Iterators.partition([1,2,3,4,5], 2))\n3-element Array{SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true},1}:\n [1, 2]\n [3, 4]\n [5]\n```\n"}],"Base.Iterators.only":[{"Tuple{Any}":"    only(x)\n\nReturns the one and only element of collection `x`, and throws an `ArgumentError` if the\ncollection has zero or multiple elements.\n\nSee also: [`first`](@ref), [`last`](@ref).\n\n!!! compat \"Julia 1.4\"\n    This method requires at least Julia 1.4.\n"}],"Base.Iterators.product":[{"Tuple":"    product(iters...)\n\nReturn an iterator over the product of several iterators. Each generated element is\na tuple whose `i`th element comes from the `i`th argument iterator. The first iterator\nchanges the fastest.\n\n# Examples\n```jldoctest\njulia> collect(Iterators.product(1:2, 3:5))\n2×3 Array{Tuple{Int64,Int64},2}:\n (1, 3)  (1, 4)  (1, 5)\n (2, 3)  (2, 4)  (2, 5)\n```\n"}],"Base.Iterators.enumerate":[{"Tuple{Any}":"    enumerate(iter)\n\nAn iterator that yields `(i, x)` where `i` is a counter starting at 1,\nand `x` is the `i`th value from the given iterator. It's useful when\nyou need not only the values `x` over which you are iterating, but\nalso the number of iterations so far. Note that `i` may not be valid\nfor indexing `iter`; it's also possible that `x != iter[i]`, if `iter`\nhas indices that do not start at 1. See the `pairs(IndexLinear(),\niter)` method if you want to ensure that `i` is an index.\n\n# Examples\n```jldoctest\njulia> a = [\"a\", \"b\", \"c\"];\n\njulia> for (index, value) in enumerate(a)\n           println(\"$index $value\")\n       end\n1 a\n2 b\n3 c\n```\n"}],"Base.Iterators.countfrom":[{"Tuple{Number,Number}":"    countfrom(start=1, step=1)\n\nAn iterator that counts forever, starting at `start` and incrementing by `step`.\n\n# Examples\n```jldoctest\njulia> for v in Iterators.countfrom(5, 2)\n           v > 10 && break\n           println(v)\n       end\n5\n7\n9\n```\n"}],"Base.Iterators.take":[{"Tuple{Any,Integer}":"    take(iter, n)\n\nAn iterator that generates at most the first `n` elements of `iter`.\n\n# Examples\n```jldoctest\njulia> a = 1:2:11\n1:2:11\n\njulia> collect(a)\n6-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> collect(Iterators.take(a,3))\n3-element Array{Int64,1}:\n 1\n 3\n 5\n```\n"}],"Base.Iterators.takewhile":[{"Tuple{Any,Any}":"    takewhile(pred, iter)\n\nAn iterator that generates element from `iter` as long as predicate `pred` is true,\nafterwards, drops every element.\n\n!!! compat \"Julia 1.4\"\n    This function requires at least Julia 1.4.\n\n# Examples\n\n```jldoctest\njulia> s = collect(1:5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> collect(Iterators.takewhile(<(3),s))\n2-element Array{Int64,1}:\n 1\n 2\n```\n"}],"Base.Iterators.accumulate":[{"Tuple{Any,Any}":"    Iterators.accumulate(f, itr)\n\nGiven a 2-argument function `f` and an iterator `itr`, return a new\niterator that successively applies `f` to the previous value and the\nnext element of `itr`.\n\nThis is effectively a lazy version of [`Base.accumulate`](@ref).\n\n# Examples\n```jldoctest\njulia> f = Iterators.accumulate(+, [1,2,3,4])\nBase.Iterators.Accumulate{typeof(+),Array{Int64,1}}(+, [1, 2, 3, 4])\n\njulia> foreach(println, f)\n1\n3\n6\n10\n```\n"}],"Base.Iterators.cycle":[{"Tuple{Any}":"    cycle(iter)\n\nAn iterator that cycles through `iter` forever.\nIf `iter` is empty, so is `cycle(iter)`.\n\n# Examples\n```jldoctest\njulia> for (i, v) in enumerate(Iterators.cycle(\"hello\"))\n           print(v)\n           i > 10 && break\n       end\nhellohelloh\n```\n"}],"Base.Iterators.rest":[{"Tuple{Any,Any}":"    rest(iter, state)\n\nAn iterator that yields the same elements as `iter`, but starting at the given `state`.\n\n# Examples\n```jldoctest\njulia> collect(Iterators.rest([1,2,3,4], 2))\n3-element Array{Int64,1}:\n 2\n 3\n 4\n```\n"}],"Base.Iterators.zip":[{"Tuple":"    zip(iters...)\n\nRun multiple iterators at the same time, until any of them is exhausted. The value type of\nthe `zip` iterator is a tuple of values of its subiterators.\n\n!!! note\n    `zip` orders the calls to its subiterators in such a way that stateful iterators will\n    not advance when another iterator finishes in the current iteration.\n\n# Examples\n```jldoctest\njulia> a = 1:5\n1:5\n\njulia> b = [\"e\",\"d\",\"b\",\"c\",\"a\"]\n5-element Array{String,1}:\n \"e\"\n \"d\"\n \"b\"\n \"c\"\n \"a\"\n\njulia> c = zip(a,b)\nBase.Iterators.Zip{Tuple{UnitRange{Int64},Array{String,1}}}((1:5, [\"e\", \"d\", \"b\", \"c\", \"a\"]))\n\njulia> length(c)\n5\n\njulia> first(c)\n(1, \"e\")\n```\n"}],"Base.Iterators.repeated":[{"Tuple{Any,Integer}":"    repeated(x[, n::Int])\n\nAn iterator that generates the value `x` forever. If `n` is specified, generates `x` that\nmany times (equivalent to `take(repeated(x), n)`).\n\n# Examples\n```jldoctest\njulia> a = Iterators.repeated([1 2], 4);\n\njulia> collect(a)\n4-element Array{Array{Int64,2},1}:\n [1 2]\n [1 2]\n [1 2]\n [1 2]\n```\n"}],"Base.Iterators.peel":[{"Tuple{Any}":"    peel(iter)\n\nReturns the first element and an iterator over the remaining elements.\n\n# Examples\n```jldoctest\njulia> (a, rest) = Iterators.peel(\"abc\");\n\njulia> a\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> collect(rest)\n2-element Array{Char,1}:\n 'b'\n 'c'\n```\n"}],"Base.Iterators.Stateful":[{"Union{}":"    Stateful(itr)\n\nThere are several different ways to think about this iterator wrapper:\n\n1. It provides a mutable wrapper around an iterator and\n   its iteration state.\n2. It turns an iterator-like abstraction into a `Channel`-like\n   abstraction.\n3. It's an iterator that mutates to become its own rest iterator\n   whenever an item is produced.\n\n`Stateful` provides the regular iterator interface. Like other mutable iterators\n(e.g. [`Channel`](@ref)), if iteration is stopped early (e.g. by a [`break`](@ref) in a [`for`](@ref) loop),\niteration can be resumed from the same spot by continuing to iterate over the\nsame iterator object (in contrast, an immutable iterator would restart from the\nbeginning).\n\n# Examples\n```jldoctest\njulia> a = Iterators.Stateful(\"abcdef\");\n\njulia> isempty(a)\nfalse\n\njulia> popfirst!(a)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> collect(Iterators.take(a, 3))\n3-element Array{Char,1}:\n 'b'\n 'c'\n 'd'\n\njulia> collect(a)\n2-element Array{Char,1}:\n 'e'\n 'f'\n```\n\n```jldoctest\njulia> a = Iterators.Stateful([1,1,1,2,3,4]);\n\njulia> for x in a; x == 1 || break; end\n\njulia> Base.peek(a)\n3\n\njulia> sum(a) # Sum the remaining elements\n7\n```\n"}],"Base.Iterators.drop":[{"Tuple{Any,Integer}":"    drop(iter, n)\n\nAn iterator that generates all but the first `n` elements of `iter`.\n\n# Examples\n```jldoctest\njulia> a = 1:2:11\n1:2:11\n\njulia> collect(a)\n6-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> collect(Iterators.drop(a,4))\n2-element Array{Int64,1}:\n  9\n 11\n```\n"}],"Base.Iterators.reverse":[{"Tuple{Any}":"    Iterators.reverse(itr)\n\nGiven an iterator `itr`, then `reverse(itr)` is an iterator over the\nsame collection but in the reverse order.\n\nThis iterator is \"lazy\" in that it does not make a copy of the collection in\norder to reverse it; see [`Base.reverse`](@ref) for an eager implementation.\n\nNot all iterator types `T` support reverse-order iteration.  If `T`\ndoesn't, then iterating over `Iterators.reverse(itr::T)` will throw a [`MethodError`](@ref)\nbecause of the missing [`iterate`](@ref) methods for `Iterators.Reverse{T}`.\n(To implement these methods, the original iterator\n`itr::T` can be obtained from `r = Iterators.reverse(itr)` by `r.itr`.)\n\n# Examples\n```jldoctest\njulia> foreach(println, Iterators.reverse(1:5))\n5\n4\n3\n2\n1\n```\n"}],"Base.Iterators.flatten":[{"Tuple{Any}":"    flatten(iter)\n\nGiven an iterator that yields iterators, return an iterator that yields the\nelements of those iterators.\nPut differently, the elements of the argument iterator are concatenated.\n\n# Examples\n```jldoctest\njulia> collect(Iterators.flatten((1:2, 8:9)))\n4-element Array{Int64,1}:\n 1\n 2\n 8\n 9\n```\n"}],"Base.Iterators.Pairs":[{"Union{}":"    Iterators.Pairs(values, keys) <: AbstractDict{eltype(keys), eltype(values)}\n\nTransforms an indexable container into an Dictionary-view of the same data.\nModifying the key-space of the underlying data may invalidate this object.\n"}],"Base.Iterators.filter":[{"Tuple{Any,Any}":"    Iterators.filter(flt, itr)\n\nGiven a predicate function `flt` and an iterable object `itr`, return an\niterable object which upon iteration yields the elements `x` of `itr` that\nsatisfy `flt(x)`. The order of the original iterator is preserved.\n\nThis function is *lazy*; that is, it is guaranteed to return in ``Θ(1)`` time\nand use ``Θ(1)`` additional space, and `flt` will not be called by an\ninvocation of `filter`. Calls to `flt` will be made when iterating over the\nreturned iterable object. These calls are not cached and repeated calls will be\nmade when reiterating.\n\nSee [`Base.filter`](@ref) for an eager implementation of filtering for arrays.\n\n# Examples\n```jldoctest\njulia> f = Iterators.filter(isodd, [1, 2, 3, 4, 5])\nBase.Iterators.Filter{typeof(isodd),Array{Int64,1}}(isodd, [1, 2, 3, 4, 5])\n\njulia> foreach(println, f)\n1\n3\n5\n```\n"}]}