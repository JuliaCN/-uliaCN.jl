{"Base.Multimedia.TextDisplay":[{"Union{}":"    TextDisplay(io::IO)\n\nReturns a `TextDisplay <: AbstractDisplay`, which displays any object as the text/plain MIME type\n(by default), writing the text representation to the given I/O stream. (This is how\nobjects are printed in the Julia REPL.)\n"}],"Base.Multimedia.redisplay":[{"Tuple{Any}":"    redisplay(x)\n    redisplay(d::AbstractDisplay, x)\n    redisplay(mime, x)\n    redisplay(d::AbstractDisplay, mime, x)\n\nBy default, the `redisplay` functions simply call [`display`](@ref).\nHowever, some display backends may override `redisplay` to modify an existing\ndisplay of `x` (if any).\nUsing `redisplay` is also a hint to the backend that `x` may be redisplayed\nseveral times, and the backend may choose to defer the display until\n(for example) the next interactive prompt.\n"}],"Base.Multimedia.MIME":[{"Union{}":"    MIME\n\nA type representing a standard internet data format. \"MIME\" stands for\n\"Multipurpose Internet Mail Extensions\", since the standard was originally\nused to describe multimedia attachments to email messages.\n\nA `MIME` object can be passed as the second argument to [`show`](@ref) to\nrequest output in that format.\n\n# Examples\n```jldoctest\njulia> show(stdout, MIME(\"text/plain\"), \"hi\")\n\"hi\"\n```\n"}],"Base.Multimedia.popdisplay":[{"Tuple{}":"    popdisplay()\n    popdisplay(d::AbstractDisplay)\n\nPop the topmost backend off of the display-backend stack, or the topmost copy of `d` in the\nsecond variant.\n"}],"Base.Multimedia.AbstractDisplay":[{"Union{}":"    AbstractDisplay\n\nAbstract supertype for rich display output devices. [`TextDisplay`](@ref) is a subtype\nof this.\n"}],"Base.Multimedia.pushdisplay":[{"Tuple{AbstractDisplay}":"    pushdisplay(d::AbstractDisplay)\n\nPushes a new display `d` on top of the global display-backend stack. Calling `display(x)` or\n`display(mime, x)` will display `x` on the topmost compatible backend in the stack (i.e.,\nthe topmost backend that does not throw a [`MethodError`](@ref)).\n"}],"Base.Multimedia.showable":[{"Union{Tuple{mime}, Tuple{MIME{mime},Any}} where mime":"    showable(mime, x)\n\nReturns a boolean value indicating whether or not the object `x` can be written\nas the given `mime` type.\n\n(By default, this is determined automatically by the existence of the\ncorresponding [`show`](@ref) method for `typeof(x)`.  Some types provide custom `showable`\nmethods; for example, if the available MIME formats depend on the *value* of `x`.)\n\n# Examples\n```jldoctest\njulia> showable(MIME(\"text/plain\"), rand(5))\ntrue\n\njulia> showable(\"img/png\", rand(5))\nfalse\n```\n"}],"Base.Multimedia.istextmime":[{"Tuple{MIME}":"    istextmime(m::MIME)\n\nDetermine whether a MIME type is text data. MIME types are assumed to be binary\ndata except for a set of types known to be text data (possibly Unicode).\n\n# Examples\n```jldoctest\njulia> istextmime(MIME(\"text/plain\"))\ntrue\n\njulia> istextmime(MIME(\"img/png\"))\nfalse\n```\n"}],"Base.Multimedia.@MIME_str":[{"Tuple{Any}":"    @MIME_str\n\nA convenience macro for writing [`MIME`](@ref) types, typically used when\nadding methods to [`show`](@ref).\nFor example the syntax `show(io::IO, ::MIME\"text/html\", x::MyType) = ...`\ncould be used to define how to write an HTML representation of `MyType`.\n"}],"Base.Multimedia.display":[{"Tuple{Any}":"    display(x)\n    display(d::AbstractDisplay, x)\n    display(mime, x)\n    display(d::AbstractDisplay, mime, x)\n\nAbstractDisplay `x` using the topmost applicable display in the display stack, typically using the\nrichest supported multimedia output for `x`, with plain-text [`stdout`](@ref) output as a fallback.\nThe `display(d, x)` variant attempts to display `x` on the given display `d` only, throwing\na [`MethodError`](@ref) if `d` cannot display objects of this type.\n\nIn general, you cannot assume that `display` output goes to `stdout` (unlike [`print(x)`](@ref) or\n[`show(x)`](@ref)).  For example, `display(x)` may open up a separate window with an image.\n`display(x)` means \"show `x` in the best way you can for the current output device(s).\"\nIf you want REPL-like text output that is guaranteed to go to `stdout`, use\n[`show(stdout, \"text/plain\", x)`](@ref) instead.\n\nThere are also two variants with a `mime` argument (a MIME type string, such as\n`\"image/png\"`), which attempt to display `x` using the requested MIME type *only*, throwing\na `MethodError` if this type is not supported by either the display(s) or by `x`. With these\nvariants, one can also supply the \"raw\" data in the requested MIME type by passing\n`x::AbstractString` (for MIME types with text-based storage, such as text/html or\napplication/postscript) or `x::Vector{UInt8}` (for binary MIME types).\n"}],"Base.Multimedia.displayable":[{"Tuple{AbstractDisplay,AbstractString}":"    displayable(mime) -> Bool\n    displayable(d::AbstractDisplay, mime) -> Bool\n\nReturns a boolean value indicating whether the given `mime` type (string) is displayable by\nany of the displays in the current display stack, or specifically by the display `d` in the\nsecond variant.\n"}]}