{"Base.Filesystem.pwd":[{"Tuple{}":"    pwd() -> AbstractString\n\nGet the current working directory.\n\n# Examples\n```julia-repl\njulia> pwd()\n\"/home/JuliaUser\"\n\njulia> cd(\"/home/JuliaUser/Projects/julia\")\n\njulia> pwd()\n\"/home/JuliaUser/Projects/julia\"\n```\n"}],"Base.Filesystem.mktempdir":[{"Union{Tuple{Function}, Tuple{Function,AbstractString}}":"    mktempdir(f::Function, parent=tempdir(); prefix=\"jl_\")\n\nApply the function `f` to the result of [`mktempdir(parent; prefix)`](@ref) and remove the\ntemporary directory all of its contents upon completion.\n"},{"Union{Tuple{}, Tuple{AbstractString}}":"    mktempdir(parent=tempdir(); prefix=\"jl_\", cleanup=true) -> path\n\nCreate a temporary directory in the `parent` directory with a name\nconstructed from the given prefix and a random suffix, and return its path.\nAdditionally, any trailing `X` characters may be replaced with random characters.\nIf `parent` does not exist, throw an error. The `cleanup` option controls whether\nthe temporary directory is automatically deleted when the process exits.\n"}],"Base.Filesystem.symlink":[{"Tuple{AbstractString,AbstractString}":"    symlink(target::AbstractString, link::AbstractString)\n\nCreates a symbolic link to `target` with the name `link`.\n\n!!! note\n    This function raises an error under operating systems that do not support\n    soft symbolic links, such as Windows XP.\n"}],"Base.Filesystem.splitdrive":[{"Tuple{AbstractString}":"    splitdrive(path::AbstractString) -> (AbstractString, AbstractString)\n\nOn Windows, split a path into the drive letter part and the path part. On Unix systems, the\nfirst component is always the empty string.\n"}],"Base.Filesystem.ispath":[{"Tuple{Base.Filesystem.StatStruct}":"    ispath(path) -> Bool\n\nReturn `true` if a valid filesystem entity exists at `path`,\notherwise returns `false`.\nThis is the generalization of [`isfile`](@ref), [`isdir`](@ref) etc.\n"}],"Base.Filesystem.issetgid":[{"Tuple{Base.Filesystem.StatStruct}":"    issetgid(path) -> Bool\n\nReturn `true` if `path` has the setgid flag set, `false` otherwise.\n"}],"Base.Filesystem.readdir":[{"Tuple{AbstractString}":"    readdir(dir::AbstractString=pwd();\n        join::Bool = false,\n        sort::Bool = true,\n    ) -> Vector{String}\n\nReturn the names in the directory `dir` or the current working directory if not\ngiven. When `join` is false, `readdir` returns just the names in the directory\nas is; when `join` is true, it returns `joinpath(dir, name)` for each `name` so\nthat the returned strings are full paths. If you want to get absolute paths\nback, call `readdir` with an absolute directory path and `join` set to true.\n\nBy default, `readdir` sorts the list of names it returns. If you want to skip\nsorting the names and get them in the order that the file system lists them,\nyou can use `readir(dir, sort=false)` to opt out of sorting.\n\n!!! compat \"Julia 1.4\"\n    The `join` and `sort` keyword arguments require at least Julia 1.4.\n\n# Examples\n```julia-repl\njulia> cd(\"/home/JuliaUser/dev/julia\")\n\njulia> readdir()\n30-element Array{String,1}:\n \".appveyor.yml\"\n \".git\"\n \".gitattributes\"\n ⋮\n \"ui\"\n \"usr\"\n \"usr-staging\"\n\njulia> readdir(join=true)\n30-element Array{String,1}:\n \"/home/JuliaUser/dev/julia/.appveyor.yml\"\n \"/home/JuliaUser/dev/julia/.git\"\n \"/home/JuliaUser/dev/julia/.gitattributes\"\n ⋮\n \"/home/JuliaUser/dev/julia/ui\"\n \"/home/JuliaUser/dev/julia/usr\"\n \"/home/JuliaUser/dev/julia/usr-staging\"\n\njulia> readdir(\"base\")\n145-element Array{String,1}:\n \".gitignore\"\n \"Base.jl\"\n \"Enums.jl\"\n ⋮\n \"version_git.sh\"\n \"views.jl\"\n \"weakkeydict.jl\"\n\njulia> readdir(\"base\", join=true)\n145-element Array{String,1}:\n \"base/.gitignore\"\n \"base/Base.jl\"\n \"base/Enums.jl\"\n ⋮\n \"base/version_git.sh\"\n \"base/views.jl\"\n \"base/weakkeydict.jl\"```\n\njulia> readdir(abspath(\"base\"), join=true)\n145-element Array{String,1}:\n \"/home/JuliaUser/dev/julia/base/.gitignore\"\n \"/home/JuliaUser/dev/julia/base/Base.jl\"\n \"/home/JuliaUser/dev/julia/base/Enums.jl\"\n ⋮\n \"/home/JuliaUser/dev/julia/base/version_git.sh\"\n \"/home/JuliaUser/dev/julia/base/views.jl\"\n \"/home/JuliaUser/dev/julia/base/weakkeydict.jl\"\n```\n"}],"Base.Filesystem.expanduser":[{"Tuple{AbstractString}":"    expanduser(path::AbstractString) -> AbstractString\n\nOn Unix systems, replace a tilde character at the start of a path with the current user's home directory.\n"}],"Base.Filesystem.splitext":[{"Tuple{String}":"    splitext(path::AbstractString) -> (AbstractString, AbstractString)\n\nIf the last component of a path contains a dot, split the path into everything before the\ndot and everything including and after the dot. Otherwise, return a tuple of the argument\nunmodified and the empty string.\n\n# Examples\n```jldoctest\njulia> splitext(\"/home/myuser/example.jl\")\n(\"/home/myuser/example\", \".jl\")\n\njulia> splitext(\"/home/myuser/example\")\n(\"/home/myuser/example\", \"\")\n```\n"}],"Base.Filesystem.lstat":[{"Tuple":"    lstat(file)\n\nLike [`stat`](@ref), but for symbolic links gets the info for the link\nitself rather than the file it refers to.\nThis function must be called on a file path rather than a file object or a file\ndescriptor.\n"}],"Base.Filesystem.issetuid":[{"Tuple{Base.Filesystem.StatStruct}":"    issetuid(path) -> Bool\n\nReturn `true` if `path` has the setuid flag set, `false` otherwise.\n"}],"Base.Filesystem.mv":[{"Tuple{AbstractString,AbstractString}":"    mv(src::AbstractString, dst::AbstractString; force::Bool=false)\n\nMove the file, link, or directory from `src` to `dst`.\n`force=true` will first remove an existing `dst`.\nReturn `dst`.\n\n# Examples\n```jldoctest; filter = r\"Stacktrace:(\\n \\[[0-9]+\\].*)*\"\njulia> write(\"hello.txt\", \"world\");\n\njulia> mv(\"hello.txt\", \"goodbye.txt\")\n\"goodbye.txt\"\n\njulia> \"hello.txt\" in readdir()\nfalse\n\njulia> readline(\"goodbye.txt\")\n\"world\"\n\njulia> write(\"hello.txt\", \"world2\");\n\njulia> mv(\"hello.txt\", \"goodbye.txt\")\nERROR: ArgumentError: 'goodbye.txt' exists. `force=true` is required to remove 'goodbye.txt' before moving.\nStacktrace:\n [1] #checkfor_mv_cp_cptree#10(::Bool, ::Function, ::String, ::String, ::String) at ./file.jl:293\n[...]\n\njulia> mv(\"hello.txt\", \"goodbye.txt\", force=true)\n\"goodbye.txt\"\n\njulia> rm(\"goodbye.txt\");\n\n```\n"}],"Base.Filesystem.issticky":[{"Tuple{Base.Filesystem.StatStruct}":"    issticky(path) -> Bool\n\nReturn `true` if `path` has the sticky bit set, `false` otherwise.\n"}],"Base.Filesystem.filesize":[{"Tuple{Base.Filesystem.StatStruct}":"    filesize(path...)\n\nEquivalent to `stat(file).size`.\n"}],"Base.Filesystem.tempdir":[{"Tuple{}":"    tempdir()\n\nGets the path of the temporary directory. On Windows, `tempdir()` uses the first environment\nvariable found in the ordered list `TMP`, `TEMP`, `USERPROFILE`. On all other operating\nsystems, `tempdir()` uses the first environment variable found in the ordered list `TMPDIR`,\n`TMP`, `TEMP`, and `TEMPDIR`. If none of these are found, the path `\"/tmp\"` is used.\n"}],"Base.Filesystem.joinpath":[{"Union{}":"    joinpath(parts::AbstractString...) -> String\n\nJoin path components into a full path. If some argument is an absolute path or\n(on Windows) has a drive specification that doesn't match the drive computed for\nthe join of the preceding paths, then prior components are dropped.\n\nNote on Windows since there is a current directory for each drive, `joinpath(\"c:\", \"foo\")`\nrepresents a path relative to the current directory on drive \"c:\" so this is equal to \"c:foo\",\nnot \"c:\\foo\". Furthermore, `joinpath` treats this as a non-absolute path and ignores the drive\nletter casing, hence `joinpath(\"C:\\A\",\"c:b\") = \"C:\\A\\b\"`.\n\n# Examples\n```jldoctest\njulia> joinpath(\"/home/myuser\", \"example.jl\")\n\"/home/myuser/example.jl\"\n```\n"}],"Base.Filesystem.filemode":[{"Tuple{Base.Filesystem.StatStruct}":"    filemode(file)\n\nEquivalent to `stat(file).mode`.\n"}],"Base.Filesystem.splitpath":[{"Tuple{AbstractString}":"    splitpath(path::AbstractString) -> Vector{String}\n\nSplit a file path into all its path components. This is the opposite of\n`joinpath`. Returns an array of substrings, one for each directory or file in\nthe path, including the root directory if present.\n\n!!! compat \"Julia 1.1\"\n    This function requires at least Julia 1.1.\n\n# Examples\n```jldoctest\njulia> splitpath(\"/home/myuser/example.jl\")\n4-element Array{String,1}:\n \"/\"\n \"home\"\n \"myuser\"\n \"example.jl\"\n```\n"}],"Base.Filesystem.ischardev":[{"Tuple{Base.Filesystem.StatStruct}":"    ischardev(path) -> Bool\n\nReturn `true` if `path` is a character device, `false` otherwise.\n"}],"Base.Filesystem.homedir":[{"Tuple{}":"    homedir() -> String\n\nReturn the current user's home directory.\n\n!!! note\n    `homedir` determines the home directory via `libuv`'s `uv_os_homedir`. For details\n    (for example on how to specify the home directory via environment variables), see the\n    [`uv_os_homedir` documentation](http://docs.libuv.org/en/v1.x/misc.html#c.uv_os_homedir).\n"}],"Base.Filesystem.walkdir":[{"Tuple{Any}":"    walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)\n\nReturn an iterator that walks the directory tree of a directory.\nThe iterator returns a tuple containing `(rootpath, dirs, files)`.\nThe directory tree can be traversed top-down or bottom-up.\nIf `walkdir` encounters a [`SystemError`](@ref)\nit will rethrow the error by default.\nA custom error handling function can be provided through `onerror` keyword argument.\n`onerror` is called with a `SystemError` as argument.\n\n# Examples\n```julia\nfor (root, dirs, files) in walkdir(\".\")\n    println(\"Directories in $root\")\n    for dir in dirs\n        println(joinpath(root, dir)) # path to directories\n    end\n    println(\"Files in $root\")\n    for file in files\n        println(joinpath(root, file)) # path to files\n    end\nend\n```\n\n```julia-repl\njulia> mkpath(\"my/test/dir\");\n\njulia> itr = walkdir(\"my\");\n\njulia> (root, dirs, files) = first(itr)\n(\"my\", [\"test\"], String[])\n\njulia> (root, dirs, files) = first(itr)\n(\"my/test\", [\"dir\"], String[])\n\njulia> (root, dirs, files) = first(itr)\n(\"my/test/dir\", String[], String[])\n```\n"}],"Base.Filesystem.mkdir":[{"Tuple{AbstractString}":"    mkdir(path::AbstractString; mode::Unsigned = 0o777)\n\nMake a new directory with name `path` and permissions `mode`. `mode` defaults to `0o777`,\nmodified by the current file creation mask. This function never creates more than one\ndirectory. If the directory already exists, or some intermediate directories do not exist,\nthis function throws an error. See [`mkpath`](@ref) for a function which creates all\nrequired intermediate directories.\nReturn `path`.\n\n# Examples\n```julia-repl\njulia> mkdir(\"testingdir\")\n\"testingdir\"\n\njulia> cd(\"testingdir\")\n\njulia> pwd()\n\"/home/JuliaUser/testingdir\"\n```\n"}],"Base.Filesystem.basename":[{"Tuple{AbstractString}":"    basename(path::AbstractString) -> AbstractString\n\nGet the file name part of a path.\n\n# Examples\n```jldoctest\njulia> basename(\"/home/myuser/example.jl\")\n\"example.jl\"\n```\n\nSee also: [`dirname`](@ref)\n"}],"Base.Filesystem.readlink":[{"Tuple{AbstractString}":"    readlink(path::AbstractString) -> AbstractString\n\nReturn the target location a symbolic link `path` points to.\n"}],"Base.Filesystem.ismount":[{"Tuple":"    ismount(path) -> Bool\n\nReturn `true` if `path` is a mount point, `false` otherwise.\n"}],"Base.Filesystem.isfile":[{"Tuple{Base.Filesystem.StatStruct}":"    isfile(path) -> Bool\n\nReturn `true` if `path` is a regular file, `false` otherwise.\n\n# Examples\n```jldoctest\njulia> isfile(homedir())\nfalse\n\njulia> f = open(\"test_file.txt\", \"w\");\n\njulia> isfile(f)\ntrue\n\njulia> close(f); rm(\"test_file.txt\")\n```\n\nSee also: [`isdir`](@ref) and [`ispath`](@ref).\n"}],"Base.Filesystem.cd":[{"Tuple{AbstractString}":"    cd(dir::AbstractString=homedir())\n\nSet the current working directory.\n\n# Examples\n```julia-repl\njulia> cd(\"/home/JuliaUser/Projects/julia\")\n\njulia> pwd()\n\"/home/JuliaUser/Projects/julia\"\n\njulia> cd()\n\njulia> pwd()\n\"/home/JuliaUser\"\n```\n"},{"Tuple{Function}":"    cd(f::Function, dir::AbstractString=homedir())\n\nTemporarily change the current working directory to `dir`, apply function `f` and\nfinally return to the original directory.\n\n# Examples\n```julia-repl\njulia> pwd()\n\"/home/JuliaUser\"\n\njulia> cd(readdir, \"/home/JuliaUser/Projects/julia\")\n34-element Array{String,1}:\n \".circleci\"\n \".freebsdci.sh\"\n \".git\"\n \".gitattributes\"\n \".github\"\n ⋮\n \"test\"\n \"ui\"\n \"usr\"\n \"usr-staging\"\n\njulia> pwd()\n\"/home/JuliaUser\"\n```\n"}],"Base.Filesystem.operm":[{"Tuple{Base.Filesystem.StatStruct}":"    operm(file)\n\nLike [`uperm`](@ref) but gets the permissions for people who neither own the file nor are a member of\nthe group owning the file\n"}],"Base.Filesystem.abspath":[{"Tuple{AbstractString,Vararg{AbstractString,N} where N}":"    abspath(path::AbstractString, paths::AbstractString...) -> String\n\nConvert a set of paths to an absolute path by joining them together and adding the\ncurrent directory if necessary. Equivalent to `abspath(joinpath(path, paths...))`.\n"},{"Tuple{String}":"    abspath(path::AbstractString) -> String\n\nConvert a path to an absolute path by adding the current directory if necessary.\nAlso normalizes the path as in [`normpath`](@ref).\n"}],"Base.Filesystem.gperm":[{"Tuple{Base.Filesystem.StatStruct}":"    gperm(file)\n\nLike [`uperm`](@ref) but gets the permissions of the group owning the file.\n"}],"Base.Filesystem.issocket":[{"Tuple{Base.Filesystem.StatStruct}":"    issocket(path) -> Bool\n\nReturn `true` if `path` is a socket, `false` otherwise.\n"}],"Base.Filesystem.rm":[{"Tuple{AbstractString}":"    rm(path::AbstractString; force::Bool=false, recursive::Bool=false)\n\nDelete the file, link, or empty directory at the given path. If `force=true` is passed, a\nnon-existing path is not treated as error. If `recursive=true` is passed and the path is a\ndirectory, then all contents are removed recursively.\n\n# Examples\n```jldoctest\njulia> mkpath(\"my/test/dir\");\n\njulia> rm(\"my\", recursive=true)\n\njulia> rm(\"this_file_does_not_exist\", force=true)\n\njulia> rm(\"this_file_does_not_exist\")\nERROR: IOError: unlink: no such file or directory (ENOENT)\nStacktrace:\n[...]\n```\n"}],"Base.Filesystem.isdir":[{"Tuple{Base.Filesystem.StatStruct}":"    isdir(path) -> Bool\n\nReturn `true` if `path` is a directory, `false` otherwise.\n\n# Examples\n```jldoctest\njulia> isdir(homedir())\ntrue\n\njulia> isdir(\"not/a/directory\")\nfalse\n```\n\nSee also: [`isfile`](@ref) and [`ispath`](@ref).\n"}],"Base.Filesystem.isabspath":[{"Tuple{AbstractString}":"    isabspath(path::AbstractString) -> Bool\n\nDetermine whether a path is absolute (begins at the root directory).\n\n# Examples\n```jldoctest\njulia> isabspath(\"/home\")\ntrue\n\njulia> isabspath(\"home\")\nfalse\n```\n"}],"Base.Filesystem.isdirpath":[{"Tuple{String}":"    isdirpath(path::AbstractString) -> Bool\n\nDetermine whether a path refers to a directory (for example, ends with a path separator).\n\n# Examples\n```jldoctest\njulia> isdirpath(\"/home\")\nfalse\n\njulia> isdirpath(\"/home/\")\ntrue\n```\n"}],"Base.Filesystem.touch":[{"Tuple{AbstractString}":"    touch(path::AbstractString)\n\nUpdate the last-modified timestamp on a file to the current time.\n\nIf the file does not exist a new file is created.\n\nReturn `path`.\n\n# Examples\n```julia-repl\njulia> write(\"my_little_file\", 2);\n\njulia> mtime(\"my_little_file\")\n1.5273815391135583e9\n\njulia> touch(\"my_little_file\");\n\njulia> mtime(\"my_little_file\")\n1.527381559163435e9\n```\n\nWe can see the [`mtime`](@ref) has been modified by `touch`.\n"}],"Base.Filesystem.contractuser":[{"Tuple{AbstractString}":"    contractuser(path::AbstractString) -> AbstractString\n\nOn Unix systems, if the path starts with `homedir()`, replace it with a tilde character.\n"}],"Base.Filesystem.isblockdev":[{"Tuple{Base.Filesystem.StatStruct}":"    isblockdev(path) -> Bool\n\nReturn `true` if `path` is a block device, `false` otherwise.\n"}],"Base.Filesystem.isfifo":[{"Tuple{Base.Filesystem.StatStruct}":"    isfifo(path) -> Bool\n\nReturn `true` if `path` is a FIFO, `false` otherwise.\n"}],"Base.Filesystem.mktemp":[{"Tuple{Any}":"    mktemp(parent=tempdir(); cleanup=true) -> (path, io)\n\nReturn `(path, io)`, where `path` is the path of a new temporary file in `parent`\nand `io` is an open file object for this path. The `cleanup` option controls whether\nthe temporary file is automatically deleted when the process exits.\n"},{"Union{Tuple{Function}, Tuple{Function,AbstractString}}":"    mktemp(f::Function, parent=tempdir())\n\nApply the function `f` to the result of [`mktemp(parent)`](@ref) and remove the\ntemporary file upon completion.\n"}],"Base.Filesystem.chmod":[{"Tuple{AbstractString,Integer}":"    chmod(path::AbstractString, mode::Integer; recursive::Bool=false)\n\nChange the permissions mode of `path` to `mode`. Only integer `mode`s (e.g. `0o777`) are\ncurrently supported. If `recursive=true` and the path is a directory all permissions in\nthat directory will be recursively changed.\nReturn `path`.\n"}],"Base.Filesystem.uperm":[{"Tuple{Base.Filesystem.StatStruct}":"    uperm(file)\n\nGet the permissions of the owner of the file as a bitfield of\n\n| Value | Description        |\n|:------|:-------------------|\n| 01    | Execute Permission |\n| 02    | Write Permission   |\n| 04    | Read Permission    |\n\nFor allowed arguments, see [`stat`](@ref).\n"}],"Base.Filesystem.normpath":[{"Tuple{AbstractString,Vararg{AbstractString,N} where N}":"    normpath(path::AbstractString, paths::AbstractString...) -> String\n\nConvert a set of paths to a normalized path by joining them together and removing\n\".\" and \"..\" entries. Equivalent to `normpath(joinpath(path, paths...))`.\n"},{"Tuple{String}":"    normpath(path::AbstractString) -> String\n\nNormalize a path, removing \".\" and \"..\" entries.\n\n# Examples\n```jldoctest\njulia> normpath(\"/home/myuser/../example.jl\")\n\"/home/example.jl\"\n```\n"}],"Base.Filesystem.cp":[{"Tuple{AbstractString,AbstractString}":"    cp(src::AbstractString, dst::AbstractString; force::Bool=false, follow_symlinks::Bool=false)\n\nCopy the file, link, or directory from `src` to `dst`.\n`force=true` will first remove an existing `dst`.\n\nIf `follow_symlinks=false`, and `src` is a symbolic link, `dst` will be created as a\nsymbolic link. If `follow_symlinks=true` and `src` is a symbolic link, `dst` will be a copy\nof the file or directory `src` refers to.\nReturn `dst`.\n"}],"Base.Filesystem.relpath":[{"Union{Tuple{String}, Tuple{String,String}}":"    relpath(path::AbstractString, startpath::AbstractString = \".\") -> AbstractString\n\nReturn a relative filepath to `path` either from the current directory or from an optional\nstart directory. This is a path computation: the filesystem is not accessed to confirm the\nexistence or nature of `path` or `startpath`.\n"}],"Base.Filesystem.tempname":[{"Tuple{}":"    tempname(parent=tempdir(); cleanup=true) -> String\n\nGenerate a temporary file path. This function only returns a path; no file is\ncreated. The path is likely to be unique, but this cannot be guaranteed due to\nthe very remote posibility of two simultaneous calls to `tempname` generating\nthe same file name. The name is guaranteed to differ from all files already\nexisting at the time of the call to `tempname`.\n\nWhen called with no arguments, the temporary name will be an absolute path to a\ntemporary name in the system temporary directory as given by `tempdir()`. If a\n`parent` directory argument is given, the temporary path will be in that\ndirectory instead.\n\nThe `cleanup` option controls whether the process attempts to delete the\nreturned path automatically when the process exits. Note that the `tempname`\nfunction does not create any file or directory at the returned location, so\nthere is nothing to cleanup unless you create a file or directory there. If\nyou do and `clean` is `true` it will be deleted upon process termination.\n\n!!! compat \"Julia 1.4\"\n    The `parent` and `cleanup` arguments were added in 1.4. Prior to Julia 1.4\n    the path `tempname` would never be cleaned up at process termination.\n\n!!! warning\n\n    This can lead to security holes if another process obtains the same\n    file name and creates the file before you are able to. Open the file with\n    `JL_O_EXCL` if this is a concern. Using [`mktemp()`](@ref) is also\n    recommended instead.\n"}],"Base.Filesystem.realpath":[{"Tuple{AbstractString}":"    realpath(path::AbstractString) -> String\n\nCanonicalize a path by expanding symbolic links and removing \".\" and \"..\" entries.\nOn case-insensitive case-preserving filesystems (typically Mac and Windows), the\nfilesystem's stored case for the path is returned.\n\n(This function throws an exception if `path` does not exist in the filesystem.)\n"}],"Base.Filesystem.dirname":[{"Tuple{AbstractString}":"    dirname(path::AbstractString) -> AbstractString\n\nGet the directory part of a path. Trailing characters ('/' or '\\') in the path are\ncounted as part of the path.\n\n# Examples\n```jldoctest\njulia> dirname(\"/home/myuser\")\n\"/home\"\n\njulia> dirname(\"/home/myuser/\")\n\"/home/myuser\"\n```\n\nSee also: [`basename`](@ref)\n"}],"Base.Filesystem.mkpath":[{"Tuple{AbstractString}":"    mkpath(path::AbstractString; mode::Unsigned = 0o777)\n\nCreate all directories in the given `path`, with permissions `mode`. `mode` defaults to\n`0o777`, modified by the current file creation mask.\nReturn `path`.\n\n# Examples\n```julia-repl\njulia> mkdir(\"testingdir\")\n\"testingdir\"\n\njulia> cd(\"testingdir\")\n\njulia> pwd()\n\"/home/JuliaUser/testingdir\"\n\njulia> mkpath(\"my/test/dir\")\n\"my/test/dir\"\n\njulia> readdir()\n1-element Array{String,1}:\n \"my\"\n\njulia> cd(\"my\")\n\njulia> readdir()\n1-element Array{String,1}:\n \"test\"\n\njulia> readdir(\"test\")\n1-element Array{String,1}:\n \"dir\"\n```\n"}],"Base.Filesystem.splitdir":[{"Tuple{String}":"    splitdir(path::AbstractString) -> (AbstractString, AbstractString)\n\nSplit a path into a tuple of the directory name and file name.\n\n# Examples\n```jldoctest\njulia> splitdir(\"/home/myuser\")\n(\"/home\", \"myuser\")\n```\n"}],"Base.Filesystem.chown":[{"Union{Tuple{AbstractString,Integer}, Tuple{AbstractString,Integer,Integer}}":"    chown(path::AbstractString, owner::Integer, group::Integer=-1)\n\nChange the owner and/or group of `path` to `owner` and/or `group`. If the value entered for `owner` or `group`\nis `-1` the corresponding ID will not change. Only integer `owner`s and `group`s are currently supported.\nReturn `path`.\n"}],"Base.Filesystem.islink":[{"Tuple{Base.Filesystem.StatStruct}":"    islink(path) -> Bool\n\nReturn `true` if `path` is a symbolic link, `false` otherwise.\n"}],"Base.Filesystem.ctime":[{"Tuple{Base.Filesystem.StatStruct}":"    ctime(file)\n\nEquivalent to `stat(file).ctime`.\n"}],"Base.Filesystem.mtime":[{"Tuple{Base.Filesystem.StatStruct}":"    mtime(file)\n\nEquivalent to `stat(file).mtime`.\n"}]}