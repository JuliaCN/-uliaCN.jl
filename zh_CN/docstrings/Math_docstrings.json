{"Base.Math.sec":[{"Tuple{Number}":"    sec(x)\n\nCompute the secant of `x`, where `x` is in radians.\n"}],"Base.Math.sincos":[{"Union{Tuple{T}, Tuple{T}} where T<:Union{Float32, Float64}":"    sincos(x)\n\nSimultaneously compute the sine and cosine of `x`, where the `x` is in radians.\n"}],"Base.Math.cosd":[{"Tuple{Any}":"    cosd(x)\nCompute cosine of `x`, where `x` is in degrees. "}],"Base.Math.exponent":[{"Union{Tuple{T}, Tuple{T}} where T<:Union{Float16, Float32, Float64}":"    exponent(x) -> Int\n\nGet the exponent of a normalized floating-point number.\n"}],"Base.Math.sinpi":[{"Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat":"    sinpi(x)\n\nCompute ``\\sin(\\pi x)`` more accurately than `sin(pi*x)`, especially for large `x`.\n"}],"Base.Math.hypot":[{"Tuple{Number,Number}":"    hypot(x, y)\n\nCompute the hypotenuse ``\\sqrt{|x|^2+|y|^2}`` avoiding overflow and underflow.\n\nThis code is an implementation of the algorithm described in:\nAn Improved Algorithm for `hypot(a,b)`\nby Carlos F. Borges\nThe article is available online at ArXiv at the link\n  https://arxiv.org/abs/1904.09481\n\n# Examples\n```jldoctest; filter = r\"Stacktrace:(\\n \\[[0-9]+\\].*)*\"\njulia> a = Int64(10)^10;\n\njulia> hypot(a, a)\n1.4142135623730951e10\n\njulia> √(a^2 + a^2) # a^2 overflows\nERROR: DomainError with -2.914184810805068e18:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\njulia> hypot(3, 4im)\n5.0\n```\n"},{"Tuple{Vararg{Number,N} where N}":"    hypot(x...)\n\nCompute the hypotenuse ``\\sqrt{\\sum |x_i|^2}`` avoiding overflow and underflow.\n\n# Examples\n```jldoctest\njulia> hypot(-5.7)\n5.7\n\njulia> hypot(3, 4im, 12.0)\n13.0\n```\n"}],"Base.Math.asech":[{"Tuple{Number}":"    asech(x)\nCompute the inverse hyperbolic secant of `x`. "}],"Base.Math.clamp":[{"Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H}} where H where L where X":"    clamp(x, lo, hi)\n\nReturn `x` if `lo <= x <= hi`. If `x > hi`, return `hi`. If `x < lo`, return `lo`. Arguments\nare promoted to a common type.\n\n# Examples\n```jldoctest\njulia> clamp.([pi, 1.0, big(10.)], 2., 9.)\n3-element Array{BigFloat,1}:\n 3.141592653589793238462643383279502884197169399375105820974944592307816406286198\n 2.0\n 9.0\n\njulia> clamp.([11,8,5],10,6) # an example where lo > hi\n3-element Array{Int64,1}:\n  6\n  6\n 10\n```\n"}],"Base.Math.rem2pi":[{"Union{}":"    rem2pi(x, r::RoundingMode)\n\nCompute the remainder of `x` after integer division by `2π`, with the quotient rounded\naccording to the rounding mode `r`. In other words, the quantity\n\n    x - 2π*round(x/(2π),r)\n\nwithout any intermediate rounding. This internally uses a high precision approximation of\n2π, and so will give a more accurate result than `rem(x,2π,r)`\n\n- if `r == RoundNearest`, then the result is in the interval ``[-π, π]``. This will generally\n  be the most accurate result. See also [`RoundNearest`](@ref).\n\n- if `r == RoundToZero`, then the result is in the interval ``[0, 2π]`` if `x` is positive,.\n  or ``[-2π, 0]`` otherwise. See also [`RoundToZero`](@ref).\n\n- if `r == RoundDown`, then the result is in the interval ``[0, 2π]``.\n  See also [`RoundDown`](@ref).\n- if `r == RoundUp`, then the result is in the interval ``[-2π, 0]``.\n  See also [`RoundUp`](@ref).\n\n# Examples\n```jldoctest\njulia> rem2pi(7pi/4, RoundNearest)\n-0.7853981633974485\n\njulia> rem2pi(7pi/4, RoundDown)\n5.497787143782138\n```\n"}],"Base.Math.acscd":[{"Tuple{Any}":"    acscd(x)\n\nCompute the inverse cosecant of `x`, where the output is in degrees. "}],"Base.Math.fromfraction":[{"Tuple{Int128}":"    fromfraction(f::Int128)\n\nCompute a tuple of values `(z1,z2)` such that\n    ``z1 + z2 == f / 2^128``\nand the significand of `z1` has 27 trailing zeros.\n"}],"Base.Math.cos_kernel":[{"Tuple{Base.Math.DoubleFloat64}":"    cos_kernel(y)\n\nCompute the cosine on the interval y∈[-π/4; π/4].\n"}],"Base.Math.deg2rad":[{"Tuple{AbstractFloat}":"    deg2rad(x)\n\nConvert `x` from degrees to radians.\n\n# Examples\n```jldoctest\njulia> deg2rad(90)\n1.5707963267948966\n```\n"}],"Base.Math.sind":[{"Tuple{Any}":"    sind(x)\nCompute sine of `x`, where `x` is in degrees. "}],"Base.Math.sincosd":[{"Tuple{Real}":"    sincosd(x)\n\nSimultaneously compute the sine and cosine of `x`, where `x` is in degrees.\n\n!!! compat \"Julia 1.3\"\n    This function requires at least Julia 1.3.\n"}],"Base.Math.rem_pio2_kernel":[{"Tuple{Float64}":"    rem_pio2_kernel(x)\n\nReturn the remainder of `x` modulo π/2 as a double-double pair, along with a `k`\nsuch that ``k \\mod 3 == K \\mod 3`` where ``K*π/2 = x - rem``. Note, that it is\nonly meant for use when ``|x|>=π/4``, and that ``π/2`` is always subtracted or\nadded for ``π/4<|x|<=π/2`` instead of simply returning `x`.\n"}],"Base.Math.ldexp":[{"Union{Tuple{T}, Tuple{T,Integer}} where T<:Union{Float16, Float32, Float64}":"    ldexp(x, n)\n\nCompute ``x \\times 2^n``.\n\n# Examples\n```jldoctest\njulia> ldexp(5., 2)\n20.0\n```\n"}],"Base.Math.asecd":[{"Tuple{Any}":"    asecd(x)\n\nCompute the inverse secant of `x`, where the output is in degrees. "}],"Base.Math.evalpoly":[{"Tuple{Any,Tuple}":"    evalpoly(x, p)\n\nEvaluate the polynomial ``\\sum_k p[k] x^{k-1}`` for the coefficients `p[1]`, `p[2]`, ...;\nthat is, the coefficients are given in ascending order by power of `x`.\nLoops are unrolled at compile time if the number of coefficients is statically known, i.e.\nwhen `p` is a `Tuple`.\nThis function generates efficient code using Horner's method if `x` is real, or using\na Goertzel-like [^DK62] algorithm if `x` is complex.\n\n[^DK62]: Donald Knuth, Art of Computer Programming, Volume 2: Seminumerical Algorithms, Sec. 4.6.4.\n\n!!! compat \"Julia 1.4\"\n    This function requires Julia 1.4 or later.\n\n# Example\n```jldoctest\njulia> evalpoly(2, (1, 2, 3))\n17\n```\n"}],"Base.Math.@evalpoly":[{"Tuple{Any,Vararg{Any,N} where N}":"    @evalpoly(z, c...)\n\nEvaluate the polynomial ``\\sum_k c[k] z^{k-1}`` for the coefficients `c[1]`, `c[2]`, ...;\nthat is, the coefficients are given in ascending order by power of `z`.  This macro expands\nto efficient inline code that uses either Horner's method or, for complex `z`, a more\nefficient Goertzel-like algorithm.\n\n# Examples\n```jldoctest\njulia> @evalpoly(3, 1, 0, 1)\n10\n\njulia> @evalpoly(2, 1, 0, 1)\n5\n\njulia> @evalpoly(2, 1, 1, 1)\n7\n```\n"}],"Base.Math.rad2deg":[{"Tuple{AbstractFloat}":"    rad2deg(x)\n\nConvert `x` from radians to degrees.\n\n# Examples\n```jldoctest\njulia> rad2deg(pi)\n180.0\n```\n"}],"Base.Math.coth":[{"Tuple{Number}":"    coth(x)\n\nCompute the hyperbolic cotangent of `x`.\n"}],"Base.Math.sin_kernel":[{"Tuple{Base.Math.DoubleFloat64}":"    sin_kernel(yhi, ylo)\n\nComputes the sine on the interval [-π/4; π/4].\n"}],"Base.Math.tand":[{"Tuple{Any}":"    tand(x)\nCompute tangent of `x`, where `x` is in degrees. "}],"Base.Math.significand":[{"Union{Tuple{T}, Tuple{T}} where T<:Union{Float16, Float32, Float64}":"    significand(x)\n\nExtract the `significand(s)` (a.k.a. mantissa), in binary representation, of a\nfloating-point number. If `x` is a non-zero finite number, then the result will be\na number of the same type on the interval ``[1,2)``. Otherwise `x` is returned.\n\n# Examples\n```jldoctest\njulia> significand(15.2)/15.2\n0.125\n\njulia> significand(15.2)*8\n15.2\n```\n"}],"Base.Math.clamp!":[{"Tuple{AbstractArray,Any,Any}":"    clamp!(array::AbstractArray, lo, hi)\n\nRestrict values in `array` to the specified range, in-place.\nSee also [`clamp`](@ref).\n"}],"Base.Math._frexp_exp":[{"Union{Tuple{T}, Tuple{T}} where T<:Union{Float32, Float64}":"    exp_x, k2 = _frexp_exp(x)\n\nCalculate exp(x) as exp_x*2^k2 and return exp_x = exp(x-kr*log(w))*2^ks where kr\nis a type dependant range reduction constant, ks scales exp_x towards the largest\nfinite number, and k2 is used to absorb the remaning scale to allow for exp(x)\nto be outside the normal floating point range.\n\nThis function is intended for use in our hyperbolic and exponential functions.\n"}],"Base.Math.csc":[{"Tuple{Number}":"    csc(x)\n\nCompute the cosecant of `x`, where `x` is in radians.\n"}],"Base.Math.acsch":[{"Tuple{Number}":"    acsch(x)\nCompute the inverse hyperbolic cosecant of `x`. "}],"Base.Math.cot":[{"Tuple{Number}":"    cot(x)\n\nCompute the cotangent of `x`, where `x` is in radians.\n"}],"Base.Math.poshighword":[{"Tuple{Float64}":"    poshighword(x)\n\nReturn positive part of the high word of `x` as a `UInt32`.\n"}],"Base.Math.cosc":[{"Tuple{Number}":"    cosc(x)\n\nCompute ``\\cos(\\pi x) / x - \\sin(\\pi x) / (\\pi x^2)`` if ``x \\neq 0``, and ``0`` if\n``x = 0``. This is the derivative of `sinc(x)`.\n"}],"Base.Math.sinc":[{"Tuple{Number}":"    sinc(x)\n\n当 ``x \\neq 0`` 时，计算 ``\\sin(\\pi x) / (\\pi x)`` ，当 ``x = 0`` 时，返回 ``1`` 。\n"}],"Base.Math.asec":[{"Tuple{Number}":"    asec(x)\nCompute the inverse secant of `x`, where the output is in radians. "}],"Base.Math.atand":[{"Tuple{Any}":"    atand(y)\n    atand(y,x)\n\nCompute the inverse tangent of `y` or `y/x`, respectively, where the output is in degrees.\n"}],"Base.Math._ldexp_exp":[{"Union{Tuple{T}, Tuple{T,Any}} where T<:Union{Float32, Float64}":"    _ldexp_exp(x, l2)\nReturns exp(x) * 2^l2. The function is intended for large arguments, x, where\nx >= ln(prevfloat(typemax(x)) and care is needed to avoid overflow.\n\nThe present implementation is narrowly tailored for our hyperbolic and\nexponential functions.  We assume l2 is small (0 or -1), and the caller\nhas filtered out very large x, for which overflow would be inevitable.\n"}],"Base.Math.mod2pi":[{"Tuple{Any}":"    mod2pi(x)\n\nModulus after division by `2π`, returning in the range ``[0,2π)``.\n\nThis function computes a floating point representation of the modulus after division by\nnumerically exact `2π`, and is therefore not exactly the same as `mod(x,2π)`, which would\ncompute the modulus of `x` relative to division by the floating-point number `2π`.\n\n!!! note\n    Depending on the format of the input value, the closest representable value to 2π may\n    be less than 2π. For example, the expression `mod2pi(2π)` will not return `0`, because\n    the intermediate value of `2*π` is a `Float64` and `2*Float64(π) < 2*big(π)`. See\n    [`rem2pi`](@ref) for more refined control of this behavior.\n\n# Examples\n```jldoctest\njulia> mod2pi(9*pi/4)\n0.7853981633974481\n```\n"}],"Base.Math.acsc":[{"Tuple{Number}":"    acsc(x)\nCompute the inverse cosecant of `x`, where the output is in radians. "}],"Base.Math.secd":[{"Tuple{Number}":"    secd(x)\n\nCompute the secant of `x`, where `x` is in degrees.\n"}],"Base.Math.highword":[{"Tuple{Float64}":"    highword(x)\n\nReturn the high word of `x` as a `UInt32`.\n"}],"Base.Math.cotd":[{"Tuple{Number}":"    cotd(x)\n\nCompute the cotangent of `x`, where `x` is in degrees.\n"}],"Base.Math.csch":[{"Tuple{Number}":"    csch(x)\n\nCompute the hyperbolic cosecant of `x`.\n"}],"Base.Math.acotd":[{"Tuple{Any}":"    acotd(x)\n\nCompute the inverse cotangent of `x`, where the output is in degrees. "}],"Base.Math.asind":[{"Tuple{Any}":"    asind(x)\n\nCompute the inverse sine of `x`, where the output is in degrees. "}],"Base.Math.modf":[{"Tuple{Any}":"    modf(x)\n\nReturn a tuple `(fpart, ipart)` of the fractional and integral parts of a number. Both parts\nhave the same sign as the argument.\n\n# Examples\n```jldoctest\njulia> modf(3.5)\n(0.5, 3.0)\n\njulia> modf(-3.5)\n(-0.5, -3.0)\n```\n"}],"Base.Math.frexp":[{"Union{Tuple{T}, Tuple{T}} where T<:Union{Float16, Float32, Float64}":"    frexp(val)\n\nReturn `(x,exp)` such that `x` has a magnitude in the interval ``[1/2, 1)`` or 0,\nand `val` is equal to ``x \\times 2^{exp}``.\n"}],"Base.Math._approx_cbrt":[{"Union{Tuple{T}, Tuple{T}} where T<:Union{Float32, Float64}":"    _approx_cbrt(x)\n\nApproximate `cbrt` to 5 bits precision\n\n    cbrt(2^e * (1+m)) ≈ 2^(e÷3) * (1 + (e%3+m)÷3)\n\nwhere:\n - `e` is integral and >= 0\n - `m` is real and in [0, 1),\n - `÷` is integer division\n - `%` is integer remainder\n\nThe RHS is always >= the LHS and has a maximum relative error of about 1 in 16.\nAdding a bias of -0.03306235651 to the `(e%3+m)÷3` term reduces the error to about 1 in\n32.\n\nWith the IEEE floating point representation, for finite positive normal values, ordinary\ninteger division of the value in bits magically gives almost exactly the RHS of the above\nprovided we first subtract the exponent bias and later add it back.  We do the\nsubtraction virtually to keep e >= 0 so that ordinary integer division rounds towards\nminus infinity; this is also efficient. All operations can be done in 32-bit.\n\nThese implementations assume that NaNs, infinities and zeros have already been filtered.\n"}],"Base.Math.acoth":[{"Tuple{Number}":"    acoth(x)\nCompute the inverse hyperbolic cotangent of `x`. "}],"Base.Math.sech":[{"Tuple{Number}":"    sech(x)\n\nCompute the hyperbolic secant of `x`.\n"}],"Base.Math.cospi":[{"Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat":"    cospi(x)\n\nCompute ``\\cos(\\pi x)`` more accurately than `cos(pi*x)`, especially for large `x`.\n"}],"Base.Math.cbrt":[{"Tuple{Real}":"    cbrt(x::Real)\n\nReturn the cube root of `x`, i.e. ``x^{1/3}``. Negative values are accepted\n(returning the negative real root when ``x < 0``).\n\nThe prefix operator `∛` is equivalent to `cbrt`.\n\n# Examples\n```jldoctest\njulia> cbrt(big(27))\n3.0\n\njulia> cbrt(big(-27))\n-3.0\n```\n"}],"Base.Math.acosd":[{"Tuple{Any}":"    acosd(x)\n\nCompute the inverse cosine of `x`, where the output is in degrees. "}],"Base.Math.cscd":[{"Tuple{Number}":"    cscd(x)\n\nCompute the cosecant of `x`, where `x` is in degrees.\n"}],"Base.Math.@horner":[{"Tuple{Any,Vararg{Any,N} where N}":"    @horner(x, p...)\n\nEvaluate `p[1] + x * (p[2] + x * (....))`, i.e. a polynomial via Horner's rule.\n"}],"Base.Math.acot":[{"Tuple{Number}":"    acot(x)\nCompute the inverse cotangent of `x`, where the output is in radians. "}]}