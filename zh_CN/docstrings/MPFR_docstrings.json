{"Base.MPFR.unsafe_cast":[{"Tuple{Any,BigFloat,RoundingMode}":"    MPFR.unsafe_cast(T, x::BigFloat, r::RoundingMode)\n\nConvert `x` to integer type `T`, rounding the direction of `r`. If the value is not\nrepresentable by T, an arbitrary value will be returned.\n"}],"Base.MPFR.MPFRRoundingMode":[{"Union{}":"    MPFR.MPFRRoundingMode\n\nMatches the `mpfr_rnd_t` enum provided by MPFR, see\nhttps://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes\n\nThis is for internal use, and ensures that `ROUNDING_MODE[]` is type-stable.\n"}],"Base.MPFR.setprecision":[{"Tuple{Type{BigFloat},Integer}":"    setprecision([T=BigFloat,] precision::Int)\n\nSet the precision (in bits) to be used for `T` arithmetic.\n\n!!! warning\n\n    This function is not thread-safe. It will affect code running on all threads, but\n    its behavior is undefined if called concurrently with computations that use the\n    setting.\n"},{"Union{Tuple{T}, Tuple{Function,Type{T},Integer}} where T":"    setprecision(f::Function, [T=BigFloat,] precision::Integer)\n\nChange the `T` arithmetic precision (in bits) for the duration of `f`.\nIt is logically equivalent to:\n\n    old = precision(BigFloat)\n    setprecision(BigFloat, precision)\n    f()\n    setprecision(BigFloat, old)\n\nOften used as `setprecision(T, precision) do ... end`\n\nNote: `nextfloat()`, `prevfloat()` do not use the precision mentioned by\n`setprecision`\n"}],"Base.MPFR.BigFloat":[{"Union{}":"    BigFloat <: AbstractFloat\n\nArbitrary precision floating point number type.\n"},{"Tuple{Any,RoundingMode}":"    BigFloat(x::Union{Real, AbstractString} [, rounding::RoundingMode=rounding(BigFloat)]; [precision::Integer=precision(BigFloat)])\n\nCreate an arbitrary precision floating point number from `x`, with precision\n`precision`. The `rounding` argument specifies the direction in which the result should be\nrounded if the conversion cannot be done exactly. If not provided, these are set by the current global values.\n\n`BigFloat(x::Real)` is the same as `convert(BigFloat,x)`, except if `x` itself is already\n`BigFloat`, in which case it will return a value with the precision set to the current\nglobal precision; `convert` will always return `x`.\n\n`BigFloat(x::AbstractString)` is identical to [`parse`](@ref). This is provided for\nconvenience since decimal literals are converted to `Float64` when parsed, so\n`BigFloat(2.1)` may not yield what you expect.\n\n!!! compat \"Julia 1.1\"\n    `precision` as a keyword argument requires at least Julia 1.1.\n    In Julia 1.0 `precision` is the second positional argument (`BigFloat(x, precision)`).\n\n# Examples\n```jldoctest\njulia> BigFloat(2.1) # 2.1 here is a Float64\n2.100000000000000088817841970012523233890533447265625\n\njulia> BigFloat(\"2.1\") # the closest BigFloat to 2.1\n2.099999999999999999999999999999999999999999999999999999999999999999999999999986\n\njulia> BigFloat(\"2.1\", RoundUp)\n2.100000000000000000000000000000000000000000000000000000000000000000000000000021\n\njulia> BigFloat(\"2.1\", RoundUp, precision=128)\n2.100000000000000000000000000000000000007\n```\n\n# See also\n- [`@big_str`](@ref)\n- [`rounding`](@ref) and [`setrounding`](@ref)\n- [`precision`](@ref) and [`setprecision`](@ref)\n"}]}