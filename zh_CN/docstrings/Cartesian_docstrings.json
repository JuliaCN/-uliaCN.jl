{"Base.Cartesian.@nextract":[{"Tuple{Int64,Symbol,Symbol}":"    @nextract N esym isym\n\nGenerate `N` variables `esym_1`, `esym_2`, ..., `esym_N` to extract values from `isym`.\n`isym` can be either a `Symbol` or anonymous-function expression.\n\n`@nextract 2 x y` would generate\n\n    x_1 = y[1]\n    x_2 = y[2]\n\nwhile `@nextract 3 x d->y[2d-1]` yields\n\n    x_1 = y[1]\n    x_2 = y[3]\n    x_3 = y[5]\n\n"}],"Base.Cartesian.@nall":[{"Tuple{Int64,Expr}":"    @nall N expr\n\nCheck whether all of the expressions generated by the anonymous-function expression `expr`\nevaluate to `true`.\n\n`@nall 3 d->(i_d > 1)` would generate the expression `(i_1 > 1 && i_2 > 1 && i_3 > 1)`. This\ncan be convenient for bounds-checking.\n"}],"Base.Cartesian.@nif":[{"Tuple{Any,Any,Vararg{Any,N} where N}":"    @nif N conditionexpr expr\n    @nif N conditionexpr expr elseexpr\n\nGenerates a sequence of `if ... elseif ... else ... end` statements. For example:\n\n    @nif 3 d->(i_d >= size(A,d)) d->(error(\"Dimension \", d, \" too big\")) d->println(\"All OK\")\n\nwould generate:\n\n    if i_1 > size(A, 1)\n        error(\"Dimension \", 1, \" too big\")\n    elseif i_2 > size(A, 2)\n        error(\"Dimension \", 2, \" too big\")\n    else\n        println(\"All OK\")\n    end\n"}],"Base.Cartesian.@ncall":[{"Tuple{Int64,Any,Vararg{Any,N} where N}":"    @ncall N f sym...\n\nGenerate a function call expression. `sym` represents any number of function arguments, the\nlast of which may be an anonymous-function expression and is expanded into `N` arguments.\n\nFor example, `@ncall 3 func a` generates\n\n    func(a_1, a_2, a_3)\n\nwhile `@ncall 2 func a b i->c[i]` yields\n\n    func(a, b, c[1], c[2])\n\n"}],"Base.Cartesian.@nloops":[{"Tuple{Any,Any,Any,Vararg{Any,N} where N}":"    @nloops N itersym rangeexpr bodyexpr\n    @nloops N itersym rangeexpr preexpr bodyexpr\n    @nloops N itersym rangeexpr preexpr postexpr bodyexpr\n\nGenerate `N` nested loops, using `itersym` as the prefix for the iteration variables.\n`rangeexpr` may be an anonymous-function expression, or a simple symbol `var` in which case\nthe range is `axes(var, d)` for dimension `d`.\n\nOptionally, you can provide \"pre\" and \"post\" expressions. These get executed first and last,\nrespectively, in the body of each loop. For example:\n\n    @nloops 2 i A d -> j_d = min(i_d, 5) begin\n        s += @nref 2 A j\n    end\n\nwould generate:\n\n    for i_2 = axes(A, 2)\n        j_2 = min(i_2, 5)\n        for i_1 = axes(A, 1)\n            j_1 = min(i_1, 5)\n            s += A[j_1, j_2]\n        end\n    end\n\nIf you want just a post-expression, supply [`nothing`](@ref) for the pre-expression. Using\nparentheses and semicolons, you can supply multi-statement expressions.\n"}],"Base.Cartesian.@ntuple":[{"Tuple{Int64,Any}":"    @ntuple N expr\n\nGenerates an `N`-tuple. `@ntuple 2 i` would generate `(i_1, i_2)`, and `@ntuple 2 k->k+1`\nwould generate `(2,3)`.\n"}],"Base.Cartesian.@nany":[{"Tuple{Int64,Expr}":"    @nany N expr\n\nCheck whether any of the expressions generated by the anonymous-function expression `expr`\nevaluate to `true`.\n\n`@nany 3 d->(i_d > 1)` would generate the expression `(i_1 > 1 || i_2 > 1 || i_3 > 1)`.\n"}],"Base.Cartesian.@nexprs":[{"Tuple{Int64,Expr}":"    @nexprs N expr\n\nGenerate `N` expressions. `expr` should be an anonymous-function expression.\n\n# Examples\n```jldoctest\njulia> @macroexpand Base.Cartesian.@nexprs 4 i -> y[i] = A[i+j]\nquote\n    y[1] = A[1 + j]\n    y[2] = A[2 + j]\n    y[3] = A[3 + j]\n    y[4] = A[4 + j]\nend\n```\n"}],"Base.Cartesian.@nref":[{"Tuple{Int64,Symbol,Any}":"    @nref N A indexexpr\n\nGenerate expressions like `A[i_1, i_2, ...]`. `indexexpr` can either be an iteration-symbol\nprefix, or an anonymous-function expression.\n\n# Examples\n```jldoctest\njulia> @macroexpand Base.Cartesian.@nref 3 A i\n:(A[i_1, i_2, i_3])\n```\n"}]}