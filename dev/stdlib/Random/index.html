<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>随机数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/Random/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../Base64/">Base64</a></li><li><a class="tocitem" href="../CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../Dates/">Dates</a></li><li><a class="tocitem" href="../DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../Distributed/">分布式计算</a></li><li><a class="tocitem" href="../FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../Libdl/">动态链接器</a></li><li><a class="tocitem" href="../LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../Logging/">日志记录</a></li><li><a class="tocitem" href="../Markdown/">Markdown</a></li><li><a class="tocitem" href="../Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../Pkg/">Pkg</a></li><li><a class="tocitem" href="../Printf/">Printf</a></li><li><a class="tocitem" href="../Profile/">性能分析</a></li><li><a class="tocitem" href="../REPL/">Julia REPL</a></li><li class="is-active"><a class="tocitem" href>随机数</a><ul class="internal"><li><a class="tocitem" href="#Random-generation-functions-1"><span>Random generation functions</span></a></li><li><a class="tocitem" href="#Subsequences,-permutations-and-shuffling-1"><span>Subsequences, permutations and shuffling</span></a></li><li><a class="tocitem" href="#Generators-(creation-and-seeding)-1"><span>Generators (creation and seeding)</span></a></li><li><a class="tocitem" href="#Hooking-into-the-Random-API-1"><span>Hooking into the <code>Random</code> API</span></a></li></ul></li><li><a class="tocitem" href="../SHA/">SHA</a></li><li><a class="tocitem" href="../Serialization/">序列化</a></li><li><a class="tocitem" href="../SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../Sockets/">套接字</a></li><li><a class="tocitem" href="../SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../Statistics/">统计</a></li><li><a class="tocitem" href="../Test/">单元测试</a></li><li><a class="tocitem" href="../UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href>随机数</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>随机数</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/stdlib-zh_cn/translate/#zh_CN/Randommd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="随机数-1"><a class="docs-heading-anchor" href="#随机数-1">随机数</a><a class="docs-heading-anchor-permalink" href="#随机数-1" title="Permalink"></a></h1><p>Random number generation in Julia uses the <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/#dSFMT">Mersenne Twister library</a> via <code>MersenneTwister</code> objects. Julia has a global RNG, which is used by default. Other RNG types can be plugged in by inheriting the <code>AbstractRNG</code> type; they can then be used to have multiple streams of random numbers. Besides <code>MersenneTwister</code>, Julia also provides the <code>RandomDevice</code> RNG type, which is a wrapper over the OS provided entropy.</p><p>Most functions related to random generation accept an optional <code>AbstractRNG</code> object as first argument, which defaults to the global one if not provided. Moreover, some of them accept optionally dimension specifications <code>dims...</code> (which can be given as a tuple) to generate arrays of random values.</p><p>A <code>MersenneTwister</code> or <code>RandomDevice</code> RNG can generate uniformly random numbers of the following types: <a href="../../base/numbers/#Core.Float16"><code>Float16</code></a>, <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a>, <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>, <a href="../../base/numbers/#Base.MPFR.BigFloat"><code>BigFloat</code></a>, <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a>, <a href="../../base/numbers/#Core.Int8"><code>Int8</code></a>, <a href="../../base/numbers/#Core.UInt8"><code>UInt8</code></a>, <a href="../../base/numbers/#Core.Int16"><code>Int16</code></a>, <a href="../../base/numbers/#Core.UInt16"><code>UInt16</code></a>, <a href="../../base/numbers/#Core.Int32"><code>Int32</code></a>, <a href="../../base/numbers/#Core.UInt32"><code>UInt32</code></a>, <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>, <a href="../../base/numbers/#Core.UInt64"><code>UInt64</code></a>, <a href="../../base/numbers/#Core.Int128"><code>Int128</code></a>, <a href="../../base/numbers/#Core.UInt128"><code>UInt128</code></a>, <a href="../../base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a> (or complex numbers of those types). Random floating point numbers are generated uniformly in <span>$[0, 1)$</span>. As <code>BigInt</code> represents unbounded integers, the interval must be specified (e.g. <code>rand(big.(1:6))</code>).</p><p>Additionally, normal and exponential distributions are implemented for some <code>AbstractFloat</code> and <code>Complex</code> types, see <a href="#Base.randn"><code>randn</code></a> and <a href="#Random.randexp"><code>randexp</code></a> for details.</p><h2 id="Random-generation-functions-1"><a class="docs-heading-anchor" href="#Random-generation-functions-1">Random generation functions</a><a class="docs-heading-anchor-permalink" href="#Random-generation-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rand([rng=GLOBAL_RNG], [S], [dims...])</code></pre><p>Pick a random element or array of random elements from the set of values specified by <code>S</code>; <code>S</code> can be</p><ul><li>an indexable collection (for example <code>1:n</code> or <code>[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]</code>),</li><li>an <code>AbstractDict</code> or <code>AbstractSet</code> object,</li><li>a string (considered as a collection of characters), or</li><li>a type: the set of values to pick from is then equivalent to <code>typemin(S):typemax(S)</code> for integers (this is not applicable to <a href="../../base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a>), and to <span>$[0, 1)$</span> for floating point numbers;</li></ul><p><code>S</code> defaults to <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> (except when <code>dims</code> is a tuple of integers, in which case <code>S</code> must be specified).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rand(Int, 2)
2-element Array{Int64,1}:
 1339893410598768192
 1575814717733606317

julia&gt; rand(MersenneTwister(0), Dict(1=&gt;2, 3=&gt;4))
1=&gt;2</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The complexity of <code>rand(rng, s::Union{AbstractDict,AbstractSet})</code> is linear in the length of <code>s</code>, unless an optimized method with constant complexity is available, which is the case for <code>Dict</code>, <code>Set</code> and <code>BitSet</code>. For more than a few calls, use <code>rand(rng, collect(s))</code> instead, or either <code>rand(rng, Dict(s))</code> or <code>rand(rng, Set(s))</code> as appropriate.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.rand!" href="#Random.rand!"><code>Random.rand!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rand!([rng=GLOBAL_RNG], A, [S=eltype(A)])</code></pre><p>Populate the array <code>A</code> with random values. If <code>S</code> is specified (<code>S</code> can be a type or a collection, cf. <a href="#Base.rand"><code>rand</code></a> for details), the values are picked randomly from <code>S</code>. This is equivalent to <code>copyto!(A, rand(rng, S, size(A)))</code> but without allocating a new array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; rand!(rng, zeros(5))
5-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592
 0.5662374165061859
 0.4600853424625171
 0.7940257103317943</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.bitrand" href="#Random.bitrand"><code>Random.bitrand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bitrand([rng=GLOBAL_RNG], [dims...])</code></pre><p>Generate a <code>BitArray</code> of random boolean values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; bitrand(rng, 10)
10-element BitArray{1}:
 false
  true
  true
  true
  true
 false
  true
 false
 false
  true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.randn" href="#Base.randn"><code>Base.randn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randn([rng=GLOBAL_RNG], [T=Float64], [dims...])</code></pre><p>Generate a normally-distributed random number of type <code>T</code> with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The <code>Base</code> module currently provides an implementation for the types <a href="../../base/numbers/#Core.Float16"><code>Float16</code></a>, <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a>, and <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> (the default), and their <a href="../../base/numbers/#Base.Complex"><code>Complex</code></a> counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; randn(rng, ComplexF64)
0.6133070881429037 - 0.6376291670853887im

julia&gt; randn(rng, ComplexF32, (2, 3))
2×3 Array{Complex{Float32},2}:
 -0.349649-0.638457im  0.376756-0.192146im  -0.396334-0.0136413im
  0.611224+1.56403im   0.355204-0.365563im  0.0905552+1.31012im</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randn!" href="#Random.randn!"><code>Random.randn!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randn!([rng=GLOBAL_RNG], A::AbstractArray) -&gt; A</code></pre><p>Fill the array <code>A</code> with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the <a href="#Base.rand"><code>rand</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; randn!(rng, zeros(5))
5-element Array{Float64,1}:
  0.8673472019512456
 -0.9017438158568171
 -0.4944787535042339
 -0.9029142938652416
  0.8644013132535154</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randexp" href="#Random.randexp"><code>Random.randexp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])</code></pre><p>Generate a random number of type <code>T</code> according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The <code>Base</code> module currently provides an implementation for the types <a href="../../base/numbers/#Core.Float16"><code>Float16</code></a>, <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a>, and <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> (the default).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; randexp(rng, Float32)
2.4835055f0

julia&gt; randexp(rng, 3, 3)
3×3 Array{Float64,2}:
 1.5167    1.30652   0.344435
 0.604436  2.78029   0.418516
 0.695867  0.693292  0.643644</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randexp!" href="#Random.randexp!"><code>Random.randexp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randexp!([rng=GLOBAL_RNG], A::AbstractArray) -&gt; A</code></pre><p>Fill the array <code>A</code> with random numbers following the exponential distribution (with scale 1).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; randexp!(rng, zeros(5))
5-element Array{Float64,1}:
 2.4835053723904896
 1.516703605376473
 0.6044364871025417
 0.6958665886385867
 1.3065196315496677</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randstring" href="#Random.randstring"><code>Random.randstring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randstring([rng=GLOBAL_RNG], [chars], [len=8])</code></pre><p>Create a random string of length <code>len</code>, consisting of characters from <code>chars</code>, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional <code>rng</code> argument specifies a random number generator, see <a href="stdlib/@ref">Random Numbers</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Random.seed!(0); randstring()
&quot;0IPrGg0J&quot;

julia&gt; randstring(MersenneTwister(0), &#39;a&#39;:&#39;z&#39;, 6)
&quot;aszvqk&quot;

julia&gt; randstring(&quot;ACGT&quot;)
&quot;TATCGGTC&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>chars</code> can be any collection of characters, of type <code>Char</code> or <code>UInt8</code> (more efficient), provided <a href="#Base.rand"><code>rand</code></a> can randomly pick characters from it.</p></div></div></div></section></article><h2 id="Subsequences,-permutations-and-shuffling-1"><a class="docs-heading-anchor" href="#Subsequences,-permutations-and-shuffling-1">Subsequences, permutations and shuffling</a><a class="docs-heading-anchor-permalink" href="#Subsequences,-permutations-and-shuffling-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Random.randsubseq" href="#Random.randsubseq"><code>Random.randsubseq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randsubseq([rng=GLOBAL_RNG,] A, p) -&gt; Vector</code></pre><p>Return a vector consisting of a random subsequence of the given array <code>A</code>, where each element of <code>A</code> is included (in order) with independent probability <code>p</code>. (Complexity is linear in <code>p*length(A)</code>, so this function is efficient even if <code>p</code> is small and <code>A</code> is large.) Technically, this process is known as &quot;Bernoulli sampling&quot; of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; randsubseq(rng, collect(1:8), 0.3)
2-element Array{Int64,1}:
 7
 8</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randsubseq!" href="#Random.randsubseq!"><code>Random.randsubseq!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randsubseq!([rng=GLOBAL_RNG,] S, A, p)</code></pre><p>Like <a href="#Random.randsubseq"><code>randsubseq</code></a>, but the results are stored in <code>S</code> (which is resized as needed).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; S = Int64[];

julia&gt; randsubseq!(rng, S, collect(1:8), 0.3);

julia&gt; S
2-element Array{Int64,1}:
 7
 8</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randperm" href="#Random.randperm"><code>Random.randperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randperm([rng=GLOBAL_RNG,] n::Integer)</code></pre><p>Construct a random permutation of length <code>n</code>. The optional <code>rng</code> argument specifies a random number generator (see <a href="stdlib/@ref">Random Numbers</a>). To randomly permute an arbitrary vector, see <a href="#Random.shuffle"><code>shuffle</code></a> or <a href="#Random.shuffle!"><code>shuffle!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; randperm(MersenneTwister(1234), 4)
4-element Array{Int64,1}:
 2
 1
 4
 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randperm!" href="#Random.randperm!"><code>Random.randperm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randperm!([rng=GLOBAL_RNG,] A::Array{&lt;:Integer})</code></pre><p>Construct in <code>A</code> a random permutation of length <code>length(A)</code>. The optional <code>rng</code> argument specifies a random number generator (see <a href="stdlib/@ref">Random Numbers</a>). To randomly permute an arbitrary vector, see <a href="#Random.shuffle"><code>shuffle</code></a> or <a href="#Random.shuffle!"><code>shuffle!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; randperm!(MersenneTwister(1234), Vector{Int}(undef, 4))
4-element Array{Int64,1}:
 2
 1
 4
 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randcycle" href="#Random.randcycle"><code>Random.randcycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randcycle([rng=GLOBAL_RNG,] n::Integer)</code></pre><p>Construct a random cyclic permutation of length <code>n</code>. The optional <code>rng</code> argument specifies a random number generator, see <a href="stdlib/@ref">Random Numbers</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; randcycle(MersenneTwister(1234), 6)
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randcycle!" href="#Random.randcycle!"><code>Random.randcycle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randcycle!([rng=GLOBAL_RNG,] A::Array{&lt;:Integer})</code></pre><p>Construct in <code>A</code> a random cyclic permutation of length <code>length(A)</code>. The optional <code>rng</code> argument specifies a random number generator, see <a href="stdlib/@ref">Random Numbers</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; randcycle!(MersenneTwister(1234), Vector{Int}(undef, 6))
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.shuffle" href="#Random.shuffle"><code>Random.shuffle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shuffle([rng=GLOBAL_RNG,] v::AbstractArray)</code></pre><p>Return a randomly permuted copy of <code>v</code>. The optional <code>rng</code> argument specifies a random number generator (see <a href="stdlib/@ref">Random Numbers</a>). To permute <code>v</code> in-place, see <a href="#Random.shuffle!"><code>shuffle!</code></a>. To obtain randomly permuted indices, see <a href="#Random.randperm"><code>randperm</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; shuffle(rng, Vector(1:10))
10-element Array{Int64,1}:
  6
  1
 10
  2
  3
  9
  5
  7
  4
  8</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.shuffle!" href="#Random.shuffle!"><code>Random.shuffle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shuffle!([rng=GLOBAL_RNG,] v::AbstractArray)</code></pre><p>In-place version of <a href="#Random.shuffle"><code>shuffle</code></a>: randomly permute <code>v</code> in-place, optionally supplying the random-number generator <code>rng</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; shuffle!(rng, Vector(1:16))
16-element Array{Int64,1}:
  2
 15
  5
 14
  1
  9
 10
  6
 11
  3
 16
  7
  4
 12
  8
 13</code></pre></div></section></article><h2 id="Generators-(creation-and-seeding)-1"><a class="docs-heading-anchor" href="#Generators-(creation-and-seeding)-1">Generators (creation and seeding)</a><a class="docs-heading-anchor-permalink" href="#Generators-(creation-and-seeding)-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Random.seed!" href="#Random.seed!"><code>Random.seed!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seed!([rng=GLOBAL_RNG], seed) -&gt; rng
seed!([rng=GLOBAL_RNG]) -&gt; rng</code></pre><p>Reseed the random number generator: <code>rng</code> will give a reproducible sequence of numbers if and only if a <code>seed</code> is provided. Some RNGs don&#39;t accept a seed, like <code>RandomDevice</code>. After the call to <code>seed!</code>, <code>rng</code> is equivalent to a newly created object initialized with the same seed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Random.seed!(1234);

julia&gt; x1 = rand(2)
2-element Array{Float64,1}:
 0.590845
 0.766797

julia&gt; Random.seed!(1234);

julia&gt; x2 = rand(2)
2-element Array{Float64,1}:
 0.590845
 0.766797

julia&gt; x1 == x2
true

julia&gt; rng = MersenneTwister(1234); rand(rng, 2) == x1
true

julia&gt; MersenneTwister(1) == Random.seed!(rng, 1)
true

julia&gt; rand(Random.seed!(rng), Bool) # not reproducible
true

julia&gt; rand(Random.seed!(rng), Bool)
false

julia&gt; rand(MersenneTwister(), Bool) # not reproducible either
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.MersenneTwister" href="#Random.MersenneTwister"><code>Random.MersenneTwister</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MersenneTwister(seed)
MersenneTwister()</code></pre><p>Create a <code>MersenneTwister</code> RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers. The <code>seed</code> may be a non-negative integer or a vector of <code>UInt32</code> integers. If no seed is provided, a randomly generated one is created (using entropy from the system). See the <a href="#Random.seed!"><code>seed!</code></a> function for reseeding an already existing <code>MersenneTwister</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; x1 = rand(rng, 2)
2-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592

julia&gt; rng = MersenneTwister(1234);

julia&gt; x2 = rand(rng, 2)
2-element Array{Float64,1}:
 0.5908446386657102
 0.7667970365022592

julia&gt; x1 == x2
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.RandomDevice" href="#Random.RandomDevice"><code>Random.RandomDevice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RandomDevice()</code></pre><p>Create a <code>RandomDevice</code> RNG object. Two such objects will always generate different streams of random numbers. The entropy is obtained from the operating system.</p></div></section></article><h2 id="Hooking-into-the-Random-API-1"><a class="docs-heading-anchor" href="#Hooking-into-the-Random-API-1">Hooking into the <code>Random</code> API</a><a class="docs-heading-anchor-permalink" href="#Hooking-into-the-Random-API-1" title="Permalink"></a></h2><p>There are two mostly orthogonal ways to extend <code>Random</code> functionalities:</p><ol><li>generating random values of custom types</li><li>creating new generators</li></ol><p>The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the <code>Random</code> module. For example, it&#39;s typically sufficient to implement one <code>rand</code> method in order to have all other usual methods work automatically.</p><p>The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.</p><h3 id="Generating-random-values-of-custom-types-1"><a class="docs-heading-anchor" href="#Generating-random-values-of-custom-types-1">Generating random values of custom types</a><a class="docs-heading-anchor-permalink" href="#Generating-random-values-of-custom-types-1" title="Permalink"></a></h3><p>There are two categories: generating values from a type (e.g. <code>rand(Int)</code>), or from a collection (e.g. <code>rand(1:3)</code>). The simple cases are explained first, and more advanced usage is presented later. We assume here that the choice of algorithm is independent of the RNG, so we use <code>AbstractRNG</code> in our signatures.</p><h4 id="Generating-values-from-a-type-1"><a class="docs-heading-anchor" href="#Generating-values-from-a-type-1">Generating values from a type</a><a class="docs-heading-anchor-permalink" href="#Generating-values-from-a-type-1" title="Permalink"></a></h4><p>Given a type <code>T</code>, it&#39;s currently assumed that if <code>rand(T)</code> is defined, an object of type <code>T</code> will be produced. In order to define random generation of values of type <code>T</code>, the following method can be defined: <code>rand(rng::AbstractRNG, ::Random.SamplerType{T})</code> (this should return what <code>rand(rng, T)</code> is expected to return).</p><p>Let&#39;s take the following example: we implement a <code>Die</code> type, with a variable number <code>n</code> of sides, numbered from <code>1</code> to <code>n</code>. We want <code>rand(Die)</code> to produce a die with a random number of up to 20 sides (and at least 4):</p><pre><code class="language-julia">struct Die
    nsides::Int # number of sides
end

Random.rand(rng::AbstractRNG, ::Random.SamplerType{Die}) = Die(rand(rng, 4:20))

# output
</code></pre><p><code>Die</code> 的标量和数组方法现在可以正常工作了：</p><pre><code class="language-julia-repl">julia&gt; rand(Die)
Die(18)

julia&gt; rand(MersenneTwister(0), Die)
Die(4)

julia&gt; rand(Die, 3)
3-element Array{Die,1}:
 Die(6)
 Die(11)
 Die(5)

julia&gt; a = Vector{Die}(undef, 3); rand!(a)
3-element Array{Die,1}:
 Die(18)
 Die(6)
 Die(8)</code></pre><h4 id="Generating-values-from-a-collection-1"><a class="docs-heading-anchor" href="#Generating-values-from-a-collection-1">Generating values from a collection</a><a class="docs-heading-anchor-permalink" href="#Generating-values-from-a-collection-1" title="Permalink"></a></h4><p>Given a collection type <code>S</code>, it&#39;s currently assumed that if <code>rand(::S)</code> is defined, an object of type <code>eltype(S)</code> will be produced. In order to define random generation out of objects of type <code>S</code>, the following method can be defined: <code>rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})</code>. Here, <code>sp</code> simply wraps an object of type <code>S</code>, which can be accessed via <code>sp[]</code>. Continuing the <code>Die</code> example, we want now to define <code>rand(d::Die)</code> to produce an <code>Int</code> corresponding to one of <code>d</code>&#39;s sides:</p><pre><code class="language-julia-repl">julia&gt; Random.rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die}) = rand(rng, 1:d[].nsides);

julia&gt; rand(Die(4))
3

julia&gt; rand(Die(4), 3)
3-element Array{Any,1}:
 3
 4
 2</code></pre><p>In the last example, a <code>Vector{Any}</code> is produced; the reason is that <code>eltype(Die) == Any</code>. The remedy is to define <code>Base.eltype(::Type{Die}) = Int</code>.</p><h4 id="Generating-values-for-an-AbstractFloat-type-1"><a class="docs-heading-anchor" href="#Generating-values-for-an-AbstractFloat-type-1">Generating values for an <code>AbstractFloat</code> type</a><a class="docs-heading-anchor-permalink" href="#Generating-values-for-an-AbstractFloat-type-1" title="Permalink"></a></h4><p><code>AbstractFloat</code> types are special-cased, because by default random values are not produced in the whole type domain, but rather in <code>[0,1)</code>. The following method should be implemented for <code>T &lt;: AbstractFloat</code>: <code>Random.rand(::AbstractRNG, ::Random.SamplerTrivial{Random.CloseOpen01{T}})</code></p><h4 id="Optimizing-generation-with-cached-computation-between-calls-1"><a class="docs-heading-anchor" href="#Optimizing-generation-with-cached-computation-between-calls-1">Optimizing generation with cached computation between calls</a><a class="docs-heading-anchor-permalink" href="#Optimizing-generation-with-cached-computation-between-calls-1" title="Permalink"></a></h4><p>When repeatedly generating random values (with the same <code>rand</code> parameters), it happens for some types that the result of a computation is used for each call. In this case, the computation can be decoupled from actually generating the values. This is the case for example with the default implementation for <code>AbstractArray</code>. Assume that <code>rand(rng, 1:20)</code> has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:</p><pre><code class="language-julia">rng = MersenneTwister()
sp = Random.Sampler(rng, 1:20) # or Random.Sampler(MersenneTwister,1:20)
for x in X
    n = rand(rng, sp) # similar to n = rand(rng, 1:20)
    # use n
end</code></pre><p>This mechanism is of course used by the default implementation of random array generation (like in <code>rand(1:20, 10)</code>). In order to implement this decoupling for a custom type, a helper type can be used. Going back to our <code>Die</code> example: <code>rand(::Die)</code> uses random generation from a range, so there is an opportunity for this optimization:</p><pre><code class="language-julia">import Random: Sampler, rand

struct SamplerDie &lt;: Sampler{Int} # generates values of type Int
    die::Die
    sp::Sampler{Int} # this is an abstract type, so this could be improved
end

Sampler(RNG::Type{&lt;:AbstractRNG}, die::Die, r::Random.Repetition) =
    SamplerDie(die, Sampler(RNG, 1:die.nsides, r))
# the `r` parameter will be explained later on

rand(rng::AbstractRNG, sp::SamplerDie) = rand(rng, sp.sp)</code></pre><p>It&#39;s now possible to get a sampler with <code>sp = Sampler(rng, die)</code>, and use <code>sp</code> instead of <code>die</code> in any <code>rand</code> call involving <code>rng</code>. In the simplistic example above, <code>die</code> doesn&#39;t need to be stored in <code>SamplerDie</code> but this is often the case in practice.</p><p>This pattern is so frequent that a helper type named <code>Random.SamplerSimple</code> is available, saving us the definition of <code>SamplerDie</code>: we could have implemented our decoupling with:</p><pre><code class="language-julia">Sampler(RNG::Type{&lt;:AbstractRNG}, die::Die, r::Random.Repetition) =
    SamplerSimple(die, Sampler(RNG, 1:die.nsides, r))

rand(rng::AbstractRNG, sp::SamplerSimple{Die}) = rand(rng, sp.data)</code></pre><p>Here, <code>sp.data</code> refers to the second parameter in the call to the <code>SamplerSimple</code> constructor (in this case equal to <code>Sampler(rng, 1:die.nsides, r)</code>), while the <code>Die</code> object can be accessed via <code>sp[]</code>.</p><p>Another helper type is currently available for other cases, <code>Random.SamplerTag</code>, but is considered as internal API, and can break at any time without proper deprecations.</p><h4 id="Using-distinct-algorithms-for-scalar-or-array-generation-1"><a class="docs-heading-anchor" href="#Using-distinct-algorithms-for-scalar-or-array-generation-1">Using distinct algorithms for scalar or array generation</a><a class="docs-heading-anchor-permalink" href="#Using-distinct-algorithms-for-scalar-or-array-generation-1" title="Permalink"></a></h4><p>In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the <code>Sampler</code> constructor. Let&#39;s assume we defined two helper types for <code>Die</code>, say <code>SamplerDie1</code> which should be used to generate only few random values, and <code>SamplerDieMany</code> for many values. We can use those types as follows:</p><pre><code class="language-julia">Sampler(RNG::Type{&lt;:AbstractRNG}, die::Die, ::Val{1}) = SamplerDie1(...)
Sampler(RNG::Type{&lt;:AbstractRNG}, die::Die, ::Val{Inf}) = SamplerDieMany(...)</code></pre><p>Of course, <code>rand</code> must also be defined on those types (i.e. <code>rand(::AbstractRNG, ::SamplerDie1)</code> and <code>rand(::AbstractRNG, ::SamplerDieMany)</code>).</p><p>Note: <code>Sampler(rng, x)</code> is simply a shorthand for <code>Sampler(rng, x, Val(Inf))</code>, and <code>Random.Repetition</code> is an alias for <code>Union{Val{1}, Val{Inf}}</code>.</p><h3 id="Creating-new-generators-1"><a class="docs-heading-anchor" href="#Creating-new-generators-1">Creating new generators</a><a class="docs-heading-anchor-permalink" href="#Creating-new-generators-1" title="Permalink"></a></h3><p>The API is not clearly defined yet, but as a rule of thumb:</p><ol><li>any <code>rand</code> method producing &quot;basic&quot; types (<code>isbitstype</code> integer and floating types in <code>Base</code>) should be defined for this specific RNG, if they are needed;</li><li>other documented <code>rand</code> methods accepting an <code>AbstractRNG</code> should work out of the box, (provided the methods from 1) what are relied on are implemented), but can of course be specialized for this RNG if there is room for optimization.</li></ol><p>Concerning 1), a <code>rand</code> method may happen to work automatically, but it&#39;s not officially supported and may break without warnings in a subsequent release.</p><p>To define a new <code>rand</code> method for an hypothetical <code>MyRNG</code> generator, and a value specification <code>s</code> (e.g. <code>s == Int</code>, or <code>s == 1:10</code>) of type <code>S==typeof(s)</code> or <code>S==Type{s}</code> if <code>s</code> is a type, the same two methods as we saw before must be defined:</p><ol><li><code>Sampler(::Type{MyRNG}, ::S, ::Repetition)</code>, which returns an object of type say <code>SamplerS</code></li><li><code>rand(rng::MyRNG, sp::SamplerS)</code></li></ol><p>It can happen that <code>Sampler(rng::AbstractRNG, ::S, ::Repetition)</code> is already defined in the <code>Random</code> module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding <code>SamplerS</code> type is considered as internal detail, and may be changed without warning.</p><h4 id="Specializing-array-generation-1"><a class="docs-heading-anchor" href="#Specializing-array-generation-1">Specializing array generation</a><a class="docs-heading-anchor-permalink" href="#Specializing-array-generation-1" title="Permalink"></a></h4><p>In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for <code>MersenneTwister</code>, which natively writes random values in an array.</p><p>To implement this specialization for <code>MyRNG</code> and for a specification <code>s</code>, producing elements of type <code>S</code>, the following method can be defined: <code>rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS)</code>, where <code>SamplerS</code> is the type of the sampler returned by <code>Sampler(MyRNG, s, Val(Inf))</code>. Instead of <code>AbstractArray</code>, it&#39;s possible to implement the functionality only for a subtype, e.g. <code>Array{S}</code>. The non-mutating array method of <code>rand</code> will automatically call this specialization internally.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../REPL/">« Julia REPL</a><a class="docs-footer-nextpage" href="../SHA/">SHA »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2020 一月 22 周三 15:24">2020 一月 22 周三</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.0.5版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
