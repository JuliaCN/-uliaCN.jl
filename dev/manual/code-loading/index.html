<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>代码加载 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/code-loading/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li class="is-active"><a class="tocitem" href>代码加载</a><ul class="internal"><li><a class="tocitem" href="#定义-1"><span>定义</span></a></li><li><a class="tocitem" href="#包的联合-1"><span>包的联合</span></a></li><li><a class="tocitem" href="#环境（Environments）-1"><span>环境（Environments）</span></a></li><li><a class="tocitem" href="#总结-1"><span>总结</span></a></li></ul></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">Dates</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>代码加载</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>代码加载</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/code-loadingmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="代码加载-1"><a class="docs-heading-anchor" href="#代码加载-1">代码加载</a><a class="docs-heading-anchor-permalink" href="#代码加载-1" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>这一章包含了加载包的技术细节。如果要安装包，使用 Julia 的内置包管理器<a href="../../stdlib/Pkg/#Pkg-1"><code>Pkg</code></a>将包加入到你的活跃环境中。如果要使用已经在你的活跃环境中的包，使用 <code>import X</code> 或 <code>using X</code>，正如在<a href="../documentation/#模块-1">模块</a>中所描述的那样。</p></div></div><h2 id="定义-1"><a class="docs-heading-anchor" href="#定义-1">定义</a><a class="docs-heading-anchor-permalink" href="#定义-1" title="Permalink"></a></h2><p>Julia加载代码有两种机制：</p><ol><li><strong>代码包含：</strong>例如 <code>include(&quot;source.jl&quot;)</code>。包含允许你把一个程序拆分为多个源文件。表达式 <code>include(&quot;source.jl&quot;)</code> 使得文件 <code>source.jl</code> 的内容在出现 <code>include</code> 调用的模块的全局作用域中执行。如果多次调用 <code>include(&quot;source.jl&quot;)</code>，<code>source.jl</code> 就被执行多次。<code>source.jl</code> 的包含路径解释为相对于出现 <code>include</code> 调用的文件路径。重定位源文件子树因此变得简单。在 REPL 中，包含路径为当前工作目录，即 <a href="../../base/file/#Base.Filesystem.pwd"><code>pwd()</code></a>。</li><li><strong>加载包：</strong>例如 <code>import X</code> 或 <code>using X</code>。<code>import</code> 通过加载包（一个独立的，可重用的 Julia 代码集合，包含在一个模块中），并导入模块内部的名称 <code>X</code>，使得模块 <code>X</code> 可用。 如果在同一个 Julia 会话中，多次导入包 <code>X</code>，那么后续导入模块为第一次导入模块的引用。但请注意，<code>import X</code> 可以在不同的上下文中加载不同的包：<code>X</code> 可以引用主工程中名为 <code>X</code> 的一个包，但它在各个依赖中可以引用不同的、名称同为 <code>X</code> 的包。更多机制说明如下。</li></ol><p>代码包含是非常直接和简单的：其在调用者的上下文中解释运行给定的源文件。包加载是建立在代码包含之上的，它具有不同的<a href="../modules/#modules-1">用途</a>。本章的其余部分将重点介绍程序包加载的行为和机制。</p><p>一个 <em>包（package）</em> 就是一个源码树，其标准布局中提供了其他 Julia 项目可以复用的功能。包可以使用 <code>import X</code> 或 <code>using X</code> 语句加载，名为 <code>X</code> 的模块在加载包代码时生成，并在包含该 import 语句的模块中可用。<code>import X</code> 中 <code>X</code> 的含义与上下文有关：程序加载哪个 <code>X</code> 包取决于 import 语句出现的位置。因此，处理 <code>import X</code> 分为两步：首先，确定在此上下文中是<strong>哪个</strong>包被定义为 <code>X</code>；其次，确定到<strong>哪里</strong>找特定的 <code>X</code> 包。</p><p>这些问题可通过查询各项目文件（<code>Project.toml</code> 或 <code>JuliaProject.toml</code>）、清单文件（<code>Manifest.toml</code> 或 <code>JuliaManifest.toml</code>），或是源文件的文件夹列在<a href="../../base/constants/#Base.LOAD_PATH"><code>LOAD_PATH</code></a> 中的项目环境解决。</p><h2 id="包的联合-1"><a class="docs-heading-anchor" href="#包的联合-1">包的联合</a><a class="docs-heading-anchor-permalink" href="#包的联合-1" title="Permalink"></a></h2><p>大多数时候，一个包可以通过它的名字唯一确定。但有时在一个项目中，可能需要使用两个有着相同名字的不同的包。尽管你可以通过重命名其中一个包来解决这个问题，但在一个大型的、共享的代码库中被迫做这件事可能是有高度破坏性的。相反，Julia的包加载机制允许相同的包名在一个应用的不同部分指向不同的包。</p><p>Julia 支持联合的包管理，这意味着多个独立的部分可以维护公有包、私有包以及包的注册表，并且项目可以依赖于一系列来自不同注册表的公有包和私有包。您也可以使用一组通用工具和工作流（workflow）来安装和管理来自各种注册表的包。Julia 附带的 <code>Pkg</code> 软件包管理器允许安装和管理项目的依赖项，它会帮助创建并操作项目文件（其描述了项目所依赖的其他项目）和清单文件（其为项目完整依赖库的确切版本的快照）。</p><p>联合管理的一个可能后果是没有包命名的中央权限。不同组织可以使用相同的名称来引用不相关的包。这并不是没有可能的，因为这些组织可能没有协作，甚至不知道彼此。由于缺乏中央命名权限，单个项目可能最终依赖着具有相同名称的不同包。Julia 的包加载机制不要求包名称是全局唯一的，即使在单个项目的依赖关系图中也是如此。相反，包由<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">通用唯一标识符</a> （UUID）进行标识，它在每个包创建时进行分配。通常，您不必直接使用这些有点麻烦的 128 位标识符，因为 <code>Pkg</code> 将负责生成和跟踪它们。但是，这些 UUID 为问题<em>「<code>X</code> 所指的包是什么？」</em>提供了确定的答案</p><p>由于去中心化的命名问题有些抽象，因此可以通过具体情境来理解问题。假设你正在开发一个名为 <code>App</code> 的应用程序，它使用两个包：<code>Pub</code> 和 <code>Priv</code>。<code>Priv</code> 是你创建的私有包，而 <code>Pub</code> 是你使用但不控制的公共包。当你创建 <code>Priv</code> 时，没有名为 <code>Priv</code> 的公共包。然而，随后一个名为 <code>Priv</code> 的不相关软件包发布并变得流行起来，而且 <code>Pub</code> 包已经开始使用它了。因此，当你下次升级 <code>Pub</code> 以获取最新的错误修复和特性时，<code>App</code> 将依赖于两个名为 <code>Priv</code> 的不同包——尽管你除了升级之外什么都没做。<code>App</code> 直接依赖于你的私有 <code>Priv</code> 包，以及通过 <code>Pub</code> 在新的公共 <code>Priv</code> 包上的间接依赖。由于这两个 <code>Priv</code> 包是不同的，但是 <code>App</code> 继续正常工作依赖于他们两者，因此表达式 <code>import Priv</code> 必须引用不同的 <code>Priv</code> 包，具体取决于它是出现在 <code>App</code> 的代码中还是出现在 <code>Pub</code> 的代码中。为了处理这种情况，Julia 的包加载机制通过 UUID 区分两个 <code>Priv</code> 包并根据它（调用 <code>import</code> 的模块）的上下文选择正确的包。这种区分的工作原理取决于环境，如以下各节所述。</p><h2 id="环境（Environments）-1"><a class="docs-heading-anchor" href="#环境（Environments）-1">环境（Environments）</a><a class="docs-heading-anchor-permalink" href="#环境（Environments）-1" title="Permalink"></a></h2><p><strong>环境</strong>决定了 <code>import X</code> 和 <code>using X</code> 语句在不同的代码上下文中的含义以及什么文件会被加载。Julia 有两类环境（environment）：</p><ol><li><strong>项目环境（project environment）</strong>是包含项目文件和清单文件（可选）的目录，并形成一个<em>显式环境</em>。项目文件确定项目的直接依赖项的名称和标识。清单文件（如果存在）提供完整的依赖关系图，包括所有直接和间接依赖关系，每个依赖的确切版本以及定位和加载正确版本的足够信息。</li><li><strong>包目录（package directory）</strong>是包含一组包的源码树子目录的目录，并形成一个<em>隐式环境</em>。如果 <code>X</code> 是包目录的子目录并且存在 <code>X/src/X.jl</code>，那么程序包 <code>X</code> 在包目录环境中可用，而 <code>X/src/X.jl</code> 是加载它使用的源文件。</li></ol><p>这些环境可以混合并用来创建<strong>堆栈环境（stacked environment）</strong>：是一组有序的项目环境和包目录，重叠为一个复合环境。然后，结合优先级规则和可见性规则，确定哪些包是可用的以及从哪里加载它们。例如，Julia 的负载路径是一个堆栈环境。</p><p>这些环境各有不同的用途：</p><ul><li>项目环境提供<strong>可迁移性</strong>。通过将项目环境以及项目源代码的其余部分存放到版本控制（例如一个 git 存储库），您可以重现项目的确切状态和所有依赖项。特别是，清单文件会记录每个依赖项的确切版本，而依赖项由其源码树的加密哈希值标识；这使得 <code>Pkg</code> 可以检索出正确的版本，并确保你正在运行准确的已记录的所有依赖项的代码。</li><li>当不需要完全仔细跟踪的项目环境时，包目录更<strong>方便</strong>。当你想要把一组包放在某处，并且希望能够直接使用它们而不必为之创建项目环境时，包目录是很实用的。</li><li>堆栈环境允许向基本环境<strong>添加</strong>工具。您可以将包含开发工具在内的环境堆到堆栈环境的末尾，使它们在 REPL 和脚本中可用，但在包内部不可用。</li></ul><p>从更高层次上，每个环境在概念上定义了三个映射：roots、graph 和 paths。当解析 <code>import X</code> 的含义时，roots 和 graph 映射用于确定 <code>X</code> 的身份，同时 paths 映射用于定位 <code>X</code> 的源代码。这三个映射的具体作用是：</p><ul><li><p><strong>roots:</strong> <code>name::Symbol</code> ⟶ <code>uuid::UUID</code></p><p>环境的 roots 映射将包名称分配给UUID，以获取环境可用于主项目的所有顶级依赖项（即可以在 <code>Main</code> 中加载的那些依赖项）。当 Julia 在主项目中遇到 <code>import X</code> 时，它会将 <code>X</code> 的标识作为 <code>roots[:X]</code>。</p></li><li><p><strong>graph:</strong> <code>context::UUID</code> ⟶ <code>name::Symbol</code> ⟶ <code>uuid::UUID</code></p><p>环境的 graph 是一个多级映射，它为每个 <code>context</code> UUID 分配一个从名称到 UUID 的映射——类似于 roots 映射，但专一于那个 <code>context</code>。当 Julia 在 UUID 为 <code>context</code> 的包代码中运行到 <code>import X</code> 时，它会将 <code>X</code> 的标识看作为 <code>graph[context][:X]</code>。正是因为如此，<code>import X</code> 可以根据 <code>context</code> 引用不同的包。</p></li><li><p><strong>paths:</strong> <code>uuid::UUID</code> × <code>name::Symbol</code> ⟶ <code>path::String</code></p><p>paths 映射会为每个包分配 UUID-name 对，即该包的入口点源文件的位置。在 <code>import X</code> 中，<code>X</code> 的标识已经通过 roots 或 graph 解析为 UUID（取决于它是从主项目还是从依赖项加载），Julia 确定要加载哪个文件来获取 <code>X</code> 是通过在环境中查找 <code>paths[uuid,:X]</code>。要包含此文件应该定义一个名为 <code>X</code> 的模块。一旦加载了此包，任何解析为相同的 <code>uuid</code> 的后续导入只会创建一个到同一个已加载的包模块的绑定。</p></li></ul><p>每种环境都以不同的方式定义这三种映射，详见以下各节。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>为了清楚地说明，本章中的示例包括 roots、graph 和 paths 的完整数据结构。但是，为了提高效率，Julia 的包加载代码并没有显式地创建它们。相反，加载一个给定包只会简单地计算所需的结构。</p></div></div><h3 id="项目环境（Project-environments）-1"><a class="docs-heading-anchor" href="#项目环境（Project-environments）-1">项目环境（Project environments）</a><a class="docs-heading-anchor-permalink" href="#项目环境（Project-environments）-1" title="Permalink"></a></h3><p>项目环境由包含名为 <code>Project.toml</code> 的项目文件的目录以及名为 <code>Manifest.toml</code> 的清单文件（可选）确定。这些文件也可以命名为 <code>JuliaProject.toml</code> 和 <code>JuliaManifest.toml</code>，此时 <code>Project.toml</code> 和 <code>Manifest.toml</code> 被忽略——这允许项目与可能需要名为 <code>Project.toml</code> 和 <code>Manifest.toml</code> 文件的其他重要工具共存。但是对于纯 Julia 项目，名称 <code>Project.toml</code> 和 <code>Manifest.toml</code> 是首选。</p><p>项目环境的 roots、graph 和 paths 映射定义如下：</p><p><strong>roots 映射</strong> 在环境中由其项目文件的内容决定，特别是它的顶级 <code>name</code> 和 <code>uuid</code> 条目及其 <code>[deps]</code> 部分（全部是可选的）。考虑以下一个假想的应用程序 <code>App</code> 的示例项目文件，如先前所述：</p><pre><code class="language-toml">name = &quot;App&quot;
uuid = &quot;8f986787-14fe-4607-ba5d-fbff2944afa9&quot;

[deps]
Priv = &quot;ba13f791-ae1d-465a-978b-69c3ad90f72b&quot;
Pub  = &quot;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&quot;</code></pre><p>如果将它表示为 Julia 字典，那么这个项目文件意味着以下 roots 映射：</p><pre><code class="language-julia">roots = Dict(
    :App  =&gt; UUID(&quot;8f986787-14fe-4607-ba5d-fbff2944afa9&quot;),
    :Priv =&gt; UUID(&quot;ba13f791-ae1d-465a-978b-69c3ad90f72b&quot;),
    :Pub  =&gt; UUID(&quot;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&quot;),
)</code></pre><p>基于这个 root 映射，在 <code>App</code> 的代码中，语句 <code>import Priv</code> 将使 Julia 查找 <code>roots[:Priv]</code>，这将得到 <code>ba13f791-ae1d-465a-978b-69c3ad90f72b</code>，也就是要在这一部分加载的 <code>Priv</code> 包的 UUID。当主应用程序解释运行到 <code>import Priv</code> 时，此 UUID 标识了要加载和使用的 <code>Priv</code> 包。</p><p><strong>依赖图（dependency graph）</strong> 在项目环境中其清单文件的内容决定，如果其存在。如果没有清单文件，则 graph 为空。清单文件包含项目的直接或间接依赖项的节（stanza）。对于每个依赖项，该文件列出该包的 UUID 以及源码树的哈希值或源代码的显式路径。考虑以下 <code>App</code> 的示例清单文件：</p><pre><code class="language-toml">[[Priv]] # 私有的那个
deps = [&quot;Pub&quot;, &quot;Zebra&quot;]
uuid = &quot;ba13f791-ae1d-465a-978b-69c3ad90f72b&quot;
path = &quot;deps/Priv&quot;

[[Priv]] # 公共的那个
uuid = &quot;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&quot;
git-tree-sha1 = &quot;1bf63d3be994fe83456a03b874b409cfd59a6373&quot;
version = &quot;0.1.5&quot;

[[Pub]]
uuid = &quot;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&quot;
git-tree-sha1 = &quot;9ebd50e2b0dd1e110e842df3b433cb5869b0dd38&quot;
version = &quot;2.1.4&quot;

  [Pub.deps]
  Priv = &quot;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&quot;
  Zebra = &quot;f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62&quot;

[[Zebra]]
uuid = &quot;f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62&quot;
git-tree-sha1 = &quot;e808e36a5d7173974b90a15a353b564f3494092f&quot;
version = &quot;3.4.2&quot;</code></pre><p>这个清单文件描述了 <code>App</code> 项目可能的完整依赖关系图：</p><ul><li>应用程序使用两个名为 <code>Priv</code> 的不同包，一个作为根依赖项的私有包，以及一个通过 <code>Pub</code> 作为间接依赖项的公共包。它们通过不同 UUID 来区分，并且有不同的依赖项：<ul><li>私有的 <code>Priv</code> 依赖于 <code>Pub</code> 和 <code>Zebra</code> 包。</li><li>公有的 <code>Priv</code> 没有依赖关系。</li></ul></li><li>该应用程序还依赖于 <code>Pub</code> 包，而后者依赖于公有的 <code>Priv</code> 以及私有的 <code>Priv</code> 包所依赖的那个 <code>Zebra</code> 包。</li></ul><p>此依赖图以字典表示后如下所示：</p><pre><code class="language-julia">graph = Dict(
    # Priv——私有的那个:
    UUID(&quot;ba13f791-ae1d-465a-978b-69c3ad90f72b&quot;) =&gt; Dict(
        :Pub   =&gt; UUID(&quot;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&quot;),
        :Zebra =&gt; UUID(&quot;f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62&quot;),
    ),
    # Priv——公共的那个:
    UUID(&quot;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&quot;) =&gt; Dict(),
    # Pub:
    UUID(&quot;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&quot;) =&gt; Dict(
        :Priv  =&gt; UUID(&quot;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&quot;),
        :Zebra =&gt; UUID(&quot;f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62&quot;),
    ),
    # Zebra:
    UUID(&quot;f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62&quot;) =&gt; Dict(),
)</code></pre><p>给定这个依赖图，当 Julia 看到 <code>Pub</code> 包中的 <code>import Priv</code> ——它有 UUID<code>c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1</code> 时，它会查找：</p><pre><code class="language-julia">graph[UUID(&quot;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&quot;)][:Priv]</code></pre><p>会得到 <code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code>，这意味着 <code>Pub</code> 包中的内容，<code>import Priv</code> 指代的是公有的 <code>Priv</code> 内容，而非应用程序直接依赖的私有包。这也是为何 <code>Priv</code> 在主项目中可指代不同的包，而不像其在某个依赖包中另有含义。在包生态中，该特性允许重名的出现。</p><p>如果在 <code>App</code> 主代码库中 <code>import Zebra</code> 会如何？因为<code>Zebra</code> 不存在于项目文件，即使它 <em>确实</em> 存在于清单文件中，其导入会是失败的。此外，<code>import Zebra</code> 这个行为若发生在公有的 <code>Priv</code> 包——UUID 为 <code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code> 的包中，同样会失败。因为公有的 <code>Priv</code> 包未在清单文件中声明依赖，故而无法加载包。仅有在清单文件：<code>Pub</code> 包和一个 <code>Priv</code> 包中作为显式依赖的包可用于加载 <code>Zebra</code>。</p><p>项目环境的 <strong>路径映射</strong> 从 manifest 文件中提取得到。而包的路径 <code>uuid</code> 和名称 <code>X</code> 则 (循序) 依据这些规则确定。</p><ol><li>如果目录中的项目文件与要求的 <code>uuid</code> 以及名称 <code>X</code> 匹配，那么可能出现以下情况的一种：</li></ol><ul><li>若该文件具有顶层 <code>路径</code> 入口，则 <code>uuid</code> 会被映射到该路径，文件的执行与包含项目文件的目录相关。</li><li>此外，<code>uuid</code> 依照包含项目文件的目录，映射至与<code>src/X.jl</code>。</li></ul><ol><li>若非上述情况，且项目文件具有对应的清单文件，且该清单文件包含匹配 <code>uuid</code> 的节（stanza），那么：</li></ol><ul><li>若其具有一个 <code>路径</code> 入口，则使用该路径（与包含清单文件的目录相关）。</li><li>若其具有一个 <code>git-tree-sha1</code> 入口，计算一个确定的 <code>uuid</code> 与 <code>git-tree-sha1</code> 函数——我们把这个函数称为 <code>slug</code>——并在每个 Julia <code>DEPOT_PATH</code> 的全局序列中的目录查询名为 <code>packages/X/$slug</code> 的目录。使用存在的第一个此类目录。</li></ul><p>若某些结果成功，源码入口点的路径会是这些结果中的某个，结果的相对路径+<code>src/X.jl</code>；否则，<code>uuid</code> 不存在路径映射。当加载 <code>X</code> 时，如果没找到源码路径，查找即告失败，用户可能会被提示安装适当的包版本或采取其他纠正措施（例如，将 <code>X</code> 声明为某种依赖性）。</p><p>在上述样例清单文件中，为找到首个 <code>Priv</code> 包的路径——该包 UUID 为 <code>ba13f791-ae1d-465a-978b-69c3ad90f72b</code>——Julia 寻找其在清单中的节（stanza）。发现其有 路径<code>入口，查看</code>App<code>项目目录中相关的</code>deps/Priv<code>——不妨设</code>App<code>代码在</code>/home/me/projects/App<code>中—则 Julia 发现</code>/home/me/projects/App/deps/Priv<code>存在，并因此从中加载</code>Priv`。</p><p>If, on the other hand, Julia was loading the <em>other</em> <code>Priv</code> package—the one with UUID <code>2d15fe94-a1f7-436c-a4d8-07a9a496e01c</code>—it finds its stanza in the manifest, see that it does <em>not</em> have a <code>path</code> entry, but that it does have a <code>git-tree-sha1</code> entry. It then computes the <code>slug</code> for this UUID/SHA-1 pair, which is <code>HDkrT</code> (the exact details of this computation aren&#39;t important, but it is consistent and deterministic). This means that the path to this <code>Priv</code> package will be <code>packages/Priv/HDkrT/src/Priv.jl</code> in one of the package depots. Suppose the contents of <code>DEPOT_PATH</code> is <code>[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]</code>, then Julia will look at the following paths to see if they exist:</p><ol><li><code>/home/me/.julia/packages/Priv/HDkrT</code></li><li><code>/usr/local/julia/packages/Priv/HDkrT</code></li></ol><p>Julia uses the first of these that exists to try to load the public <code>Priv</code> package from the file <code>packages/Priv/HDKrT/src/Priv.jl</code> in the depot where it was found.</p><p>Here is a representation of a possible paths map for our example <code>App</code> project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</p><pre><code class="language-julia">paths = Dict(
    # Priv – the private one:
    (UUID(&quot;ba13f791-ae1d-465a-978b-69c3ad90f72b&quot;), :Priv) =&gt;
        # relative entry-point inside `App` repo:
        &quot;/home/me/projects/App/deps/Priv/src/Priv.jl&quot;,
    # Priv – the public one:
    (UUID(&quot;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&quot;), :Priv) =&gt;
        # package installed in the system depot:
        &quot;/usr/local/julia/packages/Priv/HDkr/src/Priv.jl&quot;,
    # Pub:
    (UUID(&quot;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&quot;), :Pub) =&gt;
        # package installed in the user depot:
        &quot;/home/me/.julia/packages/Pub/oKpw/src/Pub.jl&quot;,
    # Zebra:
    (UUID(&quot;f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62&quot;), :Zebra) =&gt;
        # package installed in the system depot:
        &quot;/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl&quot;,
)</code></pre><p>This example map includes three different kinds of package locations (the first and third are part of the default load path):</p><ol><li>The private <code>Priv</code> package is &quot;<a href="https://stackoverflow.com/a/35109534">vendored</a>&quot; inside the <code>App</code> repository.</li><li>The public <code>Priv</code> and <code>Zebra</code> packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.</li><li>The <code>Pub</code> package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.</li></ol><h3 id="包目录-1"><a class="docs-heading-anchor" href="#包目录-1">包目录</a><a class="docs-heading-anchor-permalink" href="#包目录-1" title="Permalink"></a></h3><p>包目录提供一种更简单的，不能处理名称冲突的环境。</p><ul><li><code>X.jl</code></li><li><code>X/src/X.jl</code></li><li><code>X.jl/src/X.jl</code></li></ul><p>Which dependencies a package in a package directory can import depends on whether the package contains a project file:</p><ul><li>If it has a project file, it can only import those packages which are identified in the <code>[deps]</code> section of the project file.</li><li>If it does not have a project file, it can import any top-level package—i.e. the same packages that can be loaded in <code>Main</code> or the REPL.</li></ul><p><strong>The roots map</strong> is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder <code>X</code>...</p><ol><li>If <code>X/Project.toml</code> exists and has a <code>uuid</code> entry, then <code>uuid</code> is that value.</li><li>If <code>X/Project.toml</code> exists and but does <em>not</em> have a top-level UUID entry, <code>uuid</code> is a dummy UUID generated by hashing the canonical (real) path to <code>X/Project.toml</code>.</li><li>Otherwise (if <code>Project.toml</code> does not exist), then <code>uuid</code> is the all-zero <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Nil_UUID">nil UUID</a>.</li></ol><p><strong>The dependency graph</strong> of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:</p><ul><li>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</li><li>If a package subdirectory has a project file, then the graph entry for its UUID is the <code>[deps]</code> map of the project file, which is considered to be empty if the section is absent.</li></ul><p>As an example, suppose a package directory has the following structure and content:</p><pre><code class="language-none">Aardvark/
    src/Aardvark.jl:
        import Bobcat
        import Cobra

Bobcat/
    Project.toml:
        [deps]
        Cobra = &quot;4725e24d-f727-424b-bca0-c4307a3456fa&quot;
        Dingo = &quot;7a7925be-828c-4418-bbeb-bac8dfc843bc&quot;

    src/Bobcat.jl:
        import Cobra
        import Dingo

Cobra/
    Project.toml:
        uuid = &quot;4725e24d-f727-424b-bca0-c4307a3456fa&quot;
        [deps]
        Dingo = &quot;7a7925be-828c-4418-bbeb-bac8dfc843bc&quot;

    src/Cobra.jl:
        import Dingo

Dingo/
    Project.toml:
        uuid = &quot;7a7925be-828c-4418-bbeb-bac8dfc843bc&quot;

    src/Dingo.jl:
        # no imports</code></pre><p>Here is a corresponding roots structure, represented as a dictionary:</p><pre><code class="language-julia">roots = Dict(
    :Aardvark =&gt; UUID(&quot;00000000-0000-0000-0000-000000000000&quot;), # no project file, nil UUID
    :Bobcat   =&gt; UUID(&quot;85ad11c7-31f6-5d08-84db-0a4914d4cadf&quot;), # dummy UUID based on path
    :Cobra    =&gt; UUID(&quot;4725e24d-f727-424b-bca0-c4307a3456fa&quot;), # UUID from project file
    :Dingo    =&gt; UUID(&quot;7a7925be-828c-4418-bbeb-bac8dfc843bc&quot;), # UUID from project file
)</code></pre><p>Here is the corresponding graph structure, represented as a dictionary:</p><pre><code class="language-julia">graph = Dict(
    # Bobcat:
    UUID(&quot;85ad11c7-31f6-5d08-84db-0a4914d4cadf&quot;) =&gt; Dict(
        :Cobra =&gt; UUID(&quot;4725e24d-f727-424b-bca0-c4307a3456fa&quot;),
        :Dingo =&gt; UUID(&quot;7a7925be-828c-4418-bbeb-bac8dfc843bc&quot;),
    ),
    # Cobra:
    UUID(&quot;4725e24d-f727-424b-bca0-c4307a3456fa&quot;) =&gt; Dict(
        :Dingo =&gt; UUID(&quot;7a7925be-828c-4418-bbeb-bac8dfc843bc&quot;),
    ),
    # Dingo:
    UUID(&quot;7a7925be-828c-4418-bbeb-bac8dfc843bc&quot;) =&gt; Dict(),
)</code></pre><p>A few general rules to note:</p><ol><li>A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.</li><li>A package with a project file cannot depend on one without a project file since packages with project files can only load packages in <code>graph</code> and packages without project files do not appear in <code>graph</code>.</li><li>A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.</li></ol><p>Observe the following specific instances of these rules in our example:</p><ul><li><code>Aardvark</code> can import on any of <code>Bobcat</code>, <code>Cobra</code> or <code>Dingo</code>; it does import <code>Bobcat</code> and <code>Cobra</code>.</li><li><code>Bobcat</code> can and does import both <code>Cobra</code> and <code>Dingo</code>, which both have project files with UUIDs and are declared as dependencies in <code>Bobcat</code>&#39;s <code>[deps]</code> section.</li><li><code>Bobcat</code> cannot depend on <code>Aardvark</code> since <code>Aardvark</code> does not have a project file.</li><li><code>Cobra</code> can and does import <code>Dingo</code>, which has a project file and UUID, and is declared as a dependency in <code>Cobra</code>&#39;s  <code>[deps]</code> section.</li><li><code>Cobra</code> cannot depend on <code>Aardvark</code> or <code>Bobcat</code> since neither have real UUIDs.</li><li><code>Dingo</code> cannot import anything because it has a project file without a <code>[deps]</code> section.</li></ul><p><strong>The paths map</strong> in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is <code>/home/me/animals</code> then the <code>paths</code> map could be represented by this dictionary:</p><pre><code class="language-julia">paths = Dict(
    (UUID(&quot;00000000-0000-0000-0000-000000000000&quot;), :Aardvark) =&gt;
        &quot;/home/me/AnimalPackages/Aardvark/src/Aardvark.jl&quot;,
    (UUID(&quot;85ad11c7-31f6-5d08-84db-0a4914d4cadf&quot;), :Bobcat) =&gt;
        &quot;/home/me/AnimalPackages/Bobcat/src/Bobcat.jl&quot;,
    (UUID(&quot;4725e24d-f727-424b-bca0-c4307a3456fa&quot;), :Cobra) =&gt;
        &quot;/home/me/AnimalPackages/Cobra/src/Cobra.jl&quot;,
    (UUID(&quot;7a7925be-828c-4418-bbeb-bac8dfc843bc&quot;), :Dingo) =&gt;
        &quot;/home/me/AnimalPackages/Dingo/src/Dingo.jl&quot;,
)</code></pre><p>Since all packages in a package directory environment are, by definition, subdirectories with the expected entry-point files, their <code>paths</code> map entries always have this form.</p><h3 id="Environment-stacks-1"><a class="docs-heading-anchor" href="#Environment-stacks-1">Environment stacks</a><a class="docs-heading-anchor-permalink" href="#Environment-stacks-1" title="Permalink"></a></h3><p>The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called <em>environment stacks</em>. The Julia <code>LOAD_PATH</code> global defines an environment stack—the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in <code>LOAD_PATH</code>. It is often quite useful, however, to have access to some of your favorite tools—standard libraries, profilers, debuggers, personal utilities, etc.—even if they are not dependencies of the project you&#39;re working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.</p><p>The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have <code>stack = [env₁, env₂, …]</code> then we have:</p><pre><code class="language-julia">roots = reduce(merge, reverse([roots₁, roots₂, …]))
graph = reduce(merge, reverse([graph₁, graph₂, …]))
paths = reduce(merge, reverse([paths₁, paths₂, …]))</code></pre><p>The subscripted <code>rootsᵢ</code>, <code>graphᵢ</code> and <code>pathsᵢ</code> variables correspond to the subscripted environments, <code>envᵢ</code>, contained in <code>stack</code>. The <code>reverse</code> is present because <code>merge</code> favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:</p><ol><li>The <em>primary environment</em>—i.e. the first environment in a stack—is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.</li><li>Packages in non-primary environments can end up using incompatible versions of their dependencies even if their own environments are entirely compatible. This can happen when one of their dependencies is shadowed by a version in an earlier environment in the stack (either by graph or path, or both).</li></ol><p>Since the primary environment is typically the environment of a project you&#39;re working on, while environments later in the stack contain additional tools, this is the right trade-off: it&#39;s better to break your development tools but keep the project working. When such incompatibilities occur, you&#39;ll typically want to upgrade your dev tools to versions that are compatible with the main project.</p><h2 id="总结-1"><a class="docs-heading-anchor" href="#总结-1">总结</a><a class="docs-heading-anchor-permalink" href="#总结-1" title="Permalink"></a></h2><p>Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to <code>Pkg.add(&quot;X&quot;)</code> will add to the appropriate project and manifest files, selected via <code>Pkg.activate(&quot;Y&quot;)</code>, so that a future call to <code>import X</code> will load <code>X</code> without further thought.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../embedding/">« 嵌入 Julia</a><a class="docs-footer-nextpage" href="../profile/">性能分析 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2020 五月 28 周四 06:28">2020 五月 28 周四</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.3.1版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
